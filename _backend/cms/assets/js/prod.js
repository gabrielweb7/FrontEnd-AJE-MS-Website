"bundle";
System.registerDynamic("npm:cropperjs@1.0.0.json", [], true, function() {
  return {
    "main": "dist/cropper.common.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./dist/cropper.common.js": {
        "browser": "./dist/cropper.js"
      }
    }
  };
});

System.registerDynamic('npm:cropperjs@1.0.0/dist/cropper.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /*!
   * Cropper.js v1.0.0
   * https://github.com/fengyuanchen/cropperjs
   *
   * Copyright (c) 2017 Fengyuan Chen
   * Released under the MIT license
   *
   * Date: 2017-09-03T12:52:44.102Z
   */

  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof undefined === 'function' && define.amd ? define(factory) : global.Cropper = factory();
  })(exports, function () {
    'use strict';

    var DEFAULTS = {
      // Define the view mode of the cropper
      viewMode: 0, // 0, 1, 2, 3

      // Define the dragging mode of the cropper
      dragMode: 'crop', // 'crop', 'move' or 'none'

      // Define the aspect ratio of the crop box
      aspectRatio: NaN,

      // An object with the previous cropping result data
      data: null,

      // A selector for adding extra containers to preview
      preview: '',

      // Re-render the cropper when resize the window
      responsive: true,

      // Restore the cropped area after resize the window
      restore: true,

      // Check if the current image is a cross-origin image
      checkCrossOrigin: true,

      // Check the current image's Exif Orientation information
      checkOrientation: true,

      // Show the black modal
      modal: true,

      // Show the dashed lines for guiding
      guides: true,

      // Show the center indicator for guiding
      center: true,

      // Show the white modal to highlight the crop box
      highlight: true,

      // Show the grid background
      background: true,

      // Enable to crop the image automatically when initialize
      autoCrop: true,

      // Define the percentage of automatic cropping area when initializes
      autoCropArea: 0.8,

      // Enable to move the image
      movable: true,

      // Enable to rotate the image
      rotatable: true,

      // Enable to scale the image
      scalable: true,

      // Enable to zoom the image
      zoomable: true,

      // Enable to zoom the image by dragging touch
      zoomOnTouch: true,

      // Enable to zoom the image by wheeling mouse
      zoomOnWheel: true,

      // Define zoom ratio when zoom the image by wheeling mouse
      wheelZoomRatio: 0.1,

      // Enable to move the crop box
      cropBoxMovable: true,

      // Enable to resize the crop box
      cropBoxResizable: true,

      // Toggle drag mode between "crop" and "move" when click twice on the cropper
      toggleDragModeOnDblclick: true,

      // Size limitation
      minCanvasWidth: 0,
      minCanvasHeight: 0,
      minCropBoxWidth: 0,
      minCropBoxHeight: 0,
      minContainerWidth: 200,
      minContainerHeight: 100,

      // Shortcuts of events
      ready: null,
      cropstart: null,
      cropmove: null,
      cropend: null,
      crop: null,
      zoom: null
    };

    var TEMPLATE = '<div class="cropper-container">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-action="e"></span>' + '<span class="cropper-line line-n" data-action="n"></span>' + '<span class="cropper-line line-w" data-action="w"></span>' + '<span class="cropper-line line-s" data-action="s"></span>' + '<span class="cropper-point point-e" data-action="e"></span>' + '<span class="cropper-point point-n" data-action="n"></span>' + '<span class="cropper-point point-w" data-action="w"></span>' + '<span class="cropper-point point-s" data-action="s"></span>' + '<span class="cropper-point point-ne" data-action="ne"></span>' + '<span class="cropper-point point-nw" data-action="nw"></span>' + '<span class="cropper-point point-sw" data-action="sw"></span>' + '<span class="cropper-point point-se" data-action="se"></span>' + '</div>' + '</div>';

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    // RegExps
    var REGEXP_DATA_URL_HEAD = /^data:.*,/;
    var REGEXP_HYPHENATE = /([a-z\d])([A-Z])/g;
    var REGEXP_ORIGINS = /^(https?:)\/\/([^:/?#]+):?(\d*)/i;
    var REGEXP_SPACES = /\s+/;
    var REGEXP_SUFFIX = /^(width|height|left|top|marginLeft|marginTop)$/;
    var REGEXP_TRIM = /^\s+(.*)\s+$/;
    var REGEXP_USERAGENT = /(Macintosh|iPhone|iPod|iPad).*AppleWebKit/i;

    // Utilities
    var navigator = typeof window !== 'undefined' ? window.navigator : null;
    var IS_SAFARI_OR_UIWEBVIEW = navigator && REGEXP_USERAGENT.test(navigator.userAgent);
    var objectProto = Object.prototype;
    var toString = objectProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var fromCharCode = String.fromCharCode;

    function typeOf(obj) {
      return toString.call(obj).slice(8, -1).toLowerCase();
    }

    function isNumber(num) {
      return typeof num === 'number' && !isNaN(num);
    }

    function isUndefined(obj) {
      return typeof obj === 'undefined';
    }

    function isObject(obj) {
      return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null;
    }

    function isPlainObject(obj) {
      if (!isObject(obj)) {
        return false;
      }

      try {
        var _constructor = obj.constructor;
        var prototype = _constructor.prototype;

        return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
      } catch (e) {
        return false;
      }
    }

    function isFunction(fn) {
      return typeOf(fn) === 'function';
    }

    function isArray(arr) {
      return Array.isArray ? Array.isArray(arr) : typeOf(arr) === 'array';
    }

    function trim(str) {
      if (typeof str === 'string') {
        str = str.trim ? str.trim() : str.replace(REGEXP_TRIM, '$1');
      }

      return str;
    }

    function each(obj, callback) {
      if (obj && isFunction(callback)) {
        var i = void 0;

        if (isArray(obj) || isNumber(obj.length) /* array-like */) {
            var length = obj.length;

            for (i = 0; i < length; i += 1) {
              if (callback.call(obj, obj[i], i, obj) === false) {
                break;
              }
            }
          } else if (isObject(obj)) {
          Object.keys(obj).forEach(function (key) {
            callback.call(obj, obj[key], key, obj);
          });
        }
      }

      return obj;
    }

    function extend(obj) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (isObject(obj) && args.length > 0) {
        if (Object.assign) {
          return Object.assign.apply(Object, [obj].concat(args));
        }

        args.forEach(function (arg) {
          if (isObject(arg)) {
            Object.keys(arg).forEach(function (key) {
              obj[key] = arg[key];
            });
          }
        });
      }

      return obj;
    }

    function proxy(fn, context) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      return function () {
        for (var _len3 = arguments.length, args2 = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args2[_key3] = arguments[_key3];
        }

        return fn.apply(context, args.concat(args2));
      };
    }

    function setStyle(element, styles) {
      var style = element.style;

      each(styles, function (value, property) {
        if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
          value += 'px';
        }

        style[property] = value;
      });
    }

    function hasClass(element, value) {
      return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
    }

    function addClass(element, value) {
      if (!value) {
        return;
      }

      if (isNumber(element.length)) {
        each(element, function (elem) {
          addClass(elem, value);
        });
        return;
      }

      if (element.classList) {
        element.classList.add(value);
        return;
      }

      var className = trim(element.className);

      if (!className) {
        element.className = value;
      } else if (className.indexOf(value) < 0) {
        element.className = className + ' ' + value;
      }
    }

    function removeClass(element, value) {
      if (!value) {
        return;
      }

      if (isNumber(element.length)) {
        each(element, function (elem) {
          removeClass(elem, value);
        });
        return;
      }

      if (element.classList) {
        element.classList.remove(value);
        return;
      }

      if (element.className.indexOf(value) >= 0) {
        element.className = element.className.replace(value, '');
      }
    }

    function toggleClass(element, value, added) {
      if (!value) {
        return;
      }

      if (isNumber(element.length)) {
        each(element, function (elem) {
          toggleClass(elem, value, added);
        });
        return;
      }

      // IE10-11 doesn't support the second parameter of `classList.toggle`
      if (added) {
        addClass(element, value);
      } else {
        removeClass(element, value);
      }
    }

    function hyphenate(str) {
      return str.replace(REGEXP_HYPHENATE, '$1-$2').toLowerCase();
    }

    function getData(element, name) {
      if (isObject(element[name])) {
        return element[name];
      } else if (element.dataset) {
        return element.dataset[name];
      }

      return element.getAttribute('data-' + hyphenate(name));
    }

    function setData(element, name, data) {
      if (isObject(data)) {
        element[name] = data;
      } else if (element.dataset) {
        element.dataset[name] = data;
      } else {
        element.setAttribute('data-' + hyphenate(name), data);
      }
    }

    function removeData(element, name) {
      if (isObject(element[name])) {
        delete element[name];
      } else if (element.dataset) {
        // #128 Safari not allows to delete dataset property
        try {
          delete element.dataset[name];
        } catch (e) {
          element.dataset[name] = null;
        }
      } else {
        element.removeAttribute('data-' + hyphenate(name));
      }
    }

    function removeListener(element, type, handler) {
      var types = trim(type).split(REGEXP_SPACES);

      if (types.length > 1) {
        each(types, function (t) {
          removeListener(element, t, handler);
        });
        return;
      }

      if (element.removeEventListener) {
        element.removeEventListener(type, handler, false);
      } else if (element.detachEvent) {
        element.detachEvent('on' + type, handler);
      }
    }

    function addListener(element, type, _handler, once) {
      var types = trim(type).split(REGEXP_SPACES);
      var originalHandler = _handler;

      if (types.length > 1) {
        each(types, function (t) {
          addListener(element, t, _handler);
        });
        return;
      }

      if (once) {
        _handler = function handler() {
          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          removeListener(element, type, _handler);

          return originalHandler.apply(element, args);
        };
      }

      if (element.addEventListener) {
        element.addEventListener(type, _handler, false);
      } else if (element.attachEvent) {
        element.attachEvent('on' + type, _handler);
      }
    }

    function dispatchEvent(element, type, data) {
      if (element.dispatchEvent) {
        var event = void 0;

        // Event and CustomEvent on IE9-11 are global objects, not constructors
        if (isFunction(Event) && isFunction(CustomEvent)) {
          if (isUndefined(data)) {
            event = new Event(type, {
              bubbles: true,
              cancelable: true
            });
          } else {
            event = new CustomEvent(type, {
              detail: data,
              bubbles: true,
              cancelable: true
            });
          }
        } else if (isUndefined(data)) {
          event = document.createEvent('Event');
          event.initEvent(type, true, true);
        } else {
          event = document.createEvent('CustomEvent');
          event.initCustomEvent(type, true, true, data);
        }

        // IE9+
        return element.dispatchEvent(event);
      } else if (element.fireEvent) {
        // IE6-10 (native events only)
        return element.fireEvent('on' + type);
      }

      return true;
    }

    function getEvent(event) {
      var e = event || window.event;

      // Fix target property (IE8)
      if (!e.target) {
        e.target = e.srcElement || document;
      }

      if (!isNumber(e.pageX) && isNumber(e.clientX)) {
        var eventDoc = event.target.ownerDocument || document;
        var doc = eventDoc.documentElement;
        var body = eventDoc.body;

        e.pageX = e.clientX + ((doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0));
        e.pageY = e.clientY + ((doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0));
      }

      return e;
    }

    function getOffset(element) {
      var doc = document.documentElement;
      var box = element.getBoundingClientRect();

      return {
        left: box.left + ((window.scrollX || doc && doc.scrollLeft || 0) - (doc && doc.clientLeft || 0)),
        top: box.top + ((window.scrollY || doc && doc.scrollTop || 0) - (doc && doc.clientTop || 0))
      };
    }

    function getByTag(element, tagName) {
      return element.getElementsByTagName(tagName);
    }

    function getByClass(element, className) {
      return element.getElementsByClassName ? element.getElementsByClassName(className) : element.querySelectorAll('.' + className);
    }

    function createElement(tagName) {
      return document.createElement(tagName);
    }

    function appendChild(element, elem) {
      element.appendChild(elem);
    }

    function removeChild(element) {
      if (element.parentNode) {
        element.parentNode.removeChild(element);
      }
    }

    function empty(element) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }

    function isCrossOriginURL(url) {
      var parts = url.match(REGEXP_ORIGINS);

      return parts && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
    }

    function addTimestamp(url) {
      var timestamp = 'timestamp=' + new Date().getTime();

      return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
    }

    function getImageSize(image, callback) {
      // Modern browsers (ignore Safari)
      if (image.naturalWidth && !IS_SAFARI_OR_UIWEBVIEW) {
        callback(image.naturalWidth, image.naturalHeight);
        return;
      }

      // IE8: Don't use `new Image()` here
      var newImage = createElement('img');

      newImage.onload = function load() {
        callback(this.width, this.height);
      };

      newImage.src = image.src;
    }

    function getTransforms(data) {
      var transforms = [];
      var translateX = data.translateX;
      var translateY = data.translateY;
      var rotate = data.rotate;
      var scaleX = data.scaleX;
      var scaleY = data.scaleY;

      if (isNumber(translateX) && translateX !== 0) {
        transforms.push('translateX(' + translateX + 'px)');
      }

      if (isNumber(translateY) && translateY !== 0) {
        transforms.push('translateY(' + translateY + 'px)');
      }

      // Rotate should come first before scale to match orientation transform
      if (isNumber(rotate) && rotate !== 0) {
        transforms.push('rotate(' + rotate + 'deg)');
      }

      if (isNumber(scaleX) && scaleX !== 1) {
        transforms.push('scaleX(' + scaleX + ')');
      }

      if (isNumber(scaleY) && scaleY !== 1) {
        transforms.push('scaleY(' + scaleY + ')');
      }

      var transform = transforms.length ? transforms.join(' ') : 'none';

      return {
        WebkitTransform: transform,
        msTransform: transform,
        transform: transform
      };
    }

    function getRotatedSizes(data, reversed) {
      var deg = Math.abs(data.degree) % 180;
      var arc = (deg > 90 ? 180 - deg : deg) * Math.PI / 180;
      var sinArc = Math.sin(arc);
      var cosArc = Math.cos(arc);
      var width = data.width;
      var height = data.height;
      var aspectRatio = data.aspectRatio;
      var newWidth = void 0;
      var newHeight = void 0;

      if (!reversed) {
        newWidth = width * cosArc + height * sinArc;
        newHeight = width * sinArc + height * cosArc;
      } else {
        newWidth = width / (cosArc + sinArc / aspectRatio);
        newHeight = newWidth / aspectRatio;
      }

      return {
        width: newWidth,
        height: newHeight
      };
    }

    function getSourceCanvas(image, data, options) {
      var canvas = createElement('canvas');
      var context = canvas.getContext('2d');
      var dstX = 0;
      var dstY = 0;
      var dstWidth = data.naturalWidth;
      var dstHeight = data.naturalHeight;
      var rotate = data.rotate;
      var scaleX = data.scaleX;
      var scaleY = data.scaleY;
      var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);
      var rotatable = isNumber(rotate) && rotate !== 0;
      var advanced = rotatable || scalable;
      var canvasWidth = dstWidth * Math.abs(scaleX || 1);
      var canvasHeight = dstHeight * Math.abs(scaleY || 1);
      var translateX = void 0;
      var translateY = void 0;
      var rotated = void 0;

      if (scalable) {
        translateX = canvasWidth / 2;
        translateY = canvasHeight / 2;
      }

      if (rotatable) {
        rotated = getRotatedSizes({
          width: canvasWidth,
          height: canvasHeight,
          degree: rotate
        });

        canvasWidth = rotated.width;
        canvasHeight = rotated.height;
        translateX = canvasWidth / 2;
        translateY = canvasHeight / 2;
      }

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      if (options.fillColor) {
        context.fillStyle = options.fillColor;
        context.fillRect(0, 0, canvasWidth, canvasHeight);
      }

      if (advanced) {
        dstX = -dstWidth / 2;
        dstY = -dstHeight / 2;

        context.save();
        context.translate(translateX, translateY);
      }

      // Rotate should come first before scale as in the "getTransform" function
      if (rotatable) {
        context.rotate(rotate * Math.PI / 180);
      }

      if (scalable) {
        context.scale(scaleX, scaleY);
      }

      context.imageSmoothingEnabled = !!options.imageSmoothingEnabled;

      if (options.imageSmoothingQuality) {
        context.imageSmoothingQuality = options.imageSmoothingQuality;
      }

      context.drawImage(image, Math.floor(dstX), Math.floor(dstY), Math.floor(dstWidth), Math.floor(dstHeight));

      if (advanced) {
        context.restore();
      }

      return canvas;
    }

    function getStringFromCharCode(dataView, start, length) {
      var str = '';
      var i = start;

      for (length += start; i < length; i += 1) {
        str += fromCharCode(dataView.getUint8(i));
      }

      return str;
    }

    function getOrientation(arrayBuffer) {
      var dataView = new DataView(arrayBuffer);
      var length = dataView.byteLength;
      var orientation = void 0;
      var exifIDCode = void 0;
      var tiffOffset = void 0;
      var firstIFDOffset = void 0;
      var littleEndian = void 0;
      var endianness = void 0;
      var app1Start = void 0;
      var ifdStart = void 0;
      var offset = void 0;
      var i = void 0;

      // Only handle JPEG image (start by 0xFFD8)
      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
        offset = 2;

        while (offset < length) {
          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
            app1Start = offset;
            break;
          }

          offset += 1;
        }
      }

      if (app1Start) {
        exifIDCode = app1Start + 4;
        tiffOffset = app1Start + 10;

        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
          endianness = dataView.getUint16(tiffOffset);
          littleEndian = endianness === 0x4949;

          if (littleEndian || endianness === 0x4D4D /* bigEndian */) {
              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
                firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

                if (firstIFDOffset >= 0x00000008) {
                  ifdStart = tiffOffset + firstIFDOffset;
                }
              }
            }
        }
      }

      if (ifdStart) {
        length = dataView.getUint16(ifdStart, littleEndian);

        for (i = 0; i < length; i += 1) {
          offset = ifdStart + i * 12 + 2;

          if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {
              // 8 is the offset of the current tag's value
              offset += 8;

              // Get the original orientation value
              orientation = dataView.getUint16(offset, littleEndian);

              // Override the orientation with its default value for Safari
              if (IS_SAFARI_OR_UIWEBVIEW) {
                dataView.setUint16(offset, 1, littleEndian);
              }

              break;
            }
        }
      }

      return orientation;
    }

    function dataURLToArrayBuffer(dataURL) {
      var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
      var binary = atob(base64);
      var length = binary.length;
      var arrayBuffer = new ArrayBuffer(length);
      var dataView = new Uint8Array(arrayBuffer);
      var i = void 0;

      for (i = 0; i < length; i += 1) {
        dataView[i] = binary.charCodeAt(i);
      }

      return arrayBuffer;
    }

    // Only available for JPEG image
    function arrayBufferToDataURL(arrayBuffer) {
      var dataView = new Uint8Array(arrayBuffer);
      var length = dataView.length;
      var base64 = '';
      var i = void 0;

      for (i = 0; i < length; i += 1) {
        base64 += fromCharCode(dataView[i]);
      }

      return 'data:image/jpeg;base64,' + btoa(base64);
    }

    var render = {
      render: function render() {
        var self = this;

        self.initContainer();
        self.initCanvas();
        self.initCropBox();

        self.renderCanvas();

        if (self.cropped) {
          self.renderCropBox();
        }
      },
      initContainer: function initContainer() {
        var self = this;
        var options = self.options;
        var element = self.element;
        var container = self.container;
        var cropper = self.cropper;
        var hidden = 'cropper-hidden';

        addClass(cropper, hidden);
        removeClass(element, hidden);

        var containerData = {
          width: Math.max(container.offsetWidth, Number(options.minContainerWidth) || 200),
          height: Math.max(container.offsetHeight, Number(options.minContainerHeight) || 100)
        };

        self.containerData = containerData;

        setStyle(cropper, {
          width: containerData.width,
          height: containerData.height
        });

        addClass(element, hidden);
        removeClass(cropper, hidden);
      },

      // Canvas (image wrapper)
      initCanvas: function initCanvas() {
        var self = this;
        var viewMode = self.options.viewMode;
        var containerData = self.containerData;
        var imageData = self.imageData;
        var rotated = Math.abs(imageData.rotate) % 180 === 90;
        var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
        var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
        var aspectRatio = naturalWidth / naturalHeight;
        var canvasWidth = containerData.width;
        var canvasHeight = containerData.height;

        if (containerData.height * aspectRatio > containerData.width) {
          if (viewMode === 3) {
            canvasWidth = containerData.height * aspectRatio;
          } else {
            canvasHeight = containerData.width / aspectRatio;
          }
        } else if (viewMode === 3) {
          canvasHeight = containerData.width / aspectRatio;
        } else {
          canvasWidth = containerData.height * aspectRatio;
        }

        var canvasData = {
          naturalWidth: naturalWidth,
          naturalHeight: naturalHeight,
          aspectRatio: aspectRatio,
          width: canvasWidth,
          height: canvasHeight
        };

        canvasData.left = (containerData.width - canvasWidth) / 2;
        canvasData.top = (containerData.height - canvasHeight) / 2;
        canvasData.oldLeft = canvasData.left;
        canvasData.oldTop = canvasData.top;

        self.canvasData = canvasData;
        self.limited = viewMode === 1 || viewMode === 2;
        self.limitCanvas(true, true);
        self.initialImageData = extend({}, imageData);
        self.initialCanvasData = extend({}, canvasData);
      },
      limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
        var self = this;
        var options = self.options;
        var viewMode = options.viewMode;
        var containerData = self.containerData;
        var canvasData = self.canvasData;
        var aspectRatio = canvasData.aspectRatio;
        var cropBoxData = self.cropBoxData;
        var cropped = self.cropped && cropBoxData;

        if (sizeLimited) {
          var minCanvasWidth = Number(options.minCanvasWidth) || 0;
          var minCanvasHeight = Number(options.minCanvasHeight) || 0;

          if (viewMode > 1) {
            minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
            minCanvasHeight = Math.max(minCanvasHeight, containerData.height);

            if (viewMode === 3) {
              if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                minCanvasWidth = minCanvasHeight * aspectRatio;
              } else {
                minCanvasHeight = minCanvasWidth / aspectRatio;
              }
            }
          } else if (viewMode > 0) {
            if (minCanvasWidth) {
              minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
            } else if (minCanvasHeight) {
              minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
            } else if (cropped) {
              minCanvasWidth = cropBoxData.width;
              minCanvasHeight = cropBoxData.height;

              if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                minCanvasWidth = minCanvasHeight * aspectRatio;
              } else {
                minCanvasHeight = minCanvasWidth / aspectRatio;
              }
            }
          }

          if (minCanvasWidth && minCanvasHeight) {
            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            } else {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            }
          } else if (minCanvasWidth) {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          } else if (minCanvasHeight) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          }

          canvasData.minWidth = minCanvasWidth;
          canvasData.minHeight = minCanvasHeight;
          canvasData.maxWidth = Infinity;
          canvasData.maxHeight = Infinity;
        }

        if (positionLimited) {
          if (viewMode) {
            var newCanvasLeft = containerData.width - canvasData.width;
            var newCanvasTop = containerData.height - canvasData.height;

            canvasData.minLeft = Math.min(0, newCanvasLeft);
            canvasData.minTop = Math.min(0, newCanvasTop);
            canvasData.maxLeft = Math.max(0, newCanvasLeft);
            canvasData.maxTop = Math.max(0, newCanvasTop);

            if (cropped && self.limited) {
              canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
              canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
              canvasData.maxLeft = cropBoxData.left;
              canvasData.maxTop = cropBoxData.top;

              if (viewMode === 2) {
                if (canvasData.width >= containerData.width) {
                  canvasData.minLeft = Math.min(0, newCanvasLeft);
                  canvasData.maxLeft = Math.max(0, newCanvasLeft);
                }

                if (canvasData.height >= containerData.height) {
                  canvasData.minTop = Math.min(0, newCanvasTop);
                  canvasData.maxTop = Math.max(0, newCanvasTop);
                }
              }
            }
          } else {
            canvasData.minLeft = -canvasData.width;
            canvasData.minTop = -canvasData.height;
            canvasData.maxLeft = containerData.width;
            canvasData.maxTop = containerData.height;
          }
        }
      },
      renderCanvas: function renderCanvas(changed) {
        var self = this;
        var canvasData = self.canvasData;
        var imageData = self.imageData;
        var rotate = imageData.rotate;

        if (self.rotated) {
          self.rotated = false;

          // Computes rotated sizes with image sizes
          var rotatedData = getRotatedSizes({
            width: imageData.width,
            height: imageData.height,
            degree: rotate
          });
          var aspectRatio = rotatedData.width / rotatedData.height;
          var isSquareImage = imageData.aspectRatio === 1;

          if (isSquareImage || aspectRatio !== canvasData.aspectRatio) {
            canvasData.left -= (rotatedData.width - canvasData.width) / 2;
            canvasData.top -= (rotatedData.height - canvasData.height) / 2;
            canvasData.width = rotatedData.width;
            canvasData.height = rotatedData.height;
            canvasData.aspectRatio = aspectRatio;
            canvasData.naturalWidth = imageData.naturalWidth;
            canvasData.naturalHeight = imageData.naturalHeight;

            // Computes rotated sizes with natural image sizes
            if (isSquareImage && rotate % 90 || rotate % 180) {
              var rotatedData2 = getRotatedSizes({
                width: imageData.naturalWidth,
                height: imageData.naturalHeight,
                degree: rotate
              });

              canvasData.naturalWidth = rotatedData2.width;
              canvasData.naturalHeight = rotatedData2.height;
            }

            self.limitCanvas(true, false);
          }
        }

        if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
          canvasData.left = canvasData.oldLeft;
        }

        if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
          canvasData.top = canvasData.oldTop;
        }

        canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
        canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);

        self.limitCanvas(false, true);

        canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
        canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
        canvasData.oldLeft = canvasData.left;
        canvasData.oldTop = canvasData.top;

        setStyle(self.canvas, extend({
          width: canvasData.width,
          height: canvasData.height
        }, getTransforms({
          translateX: canvasData.left,
          translateY: canvasData.top
        })));

        self.renderImage();

        if (self.cropped && self.limited) {
          self.limitCropBox(true, true);
        }

        if (changed) {
          self.output();
        }
      },
      renderImage: function renderImage(changed) {
        var self = this;
        var canvasData = self.canvasData;
        var imageData = self.imageData;
        var newImageData = void 0;
        var reversedData = void 0;
        var reversedWidth = void 0;
        var reversedHeight = void 0;

        if (imageData.rotate) {
          reversedData = getRotatedSizes({
            width: canvasData.width,
            height: canvasData.height,
            degree: imageData.rotate,
            aspectRatio: imageData.aspectRatio
          }, true);

          reversedWidth = reversedData.width;
          reversedHeight = reversedData.height;

          newImageData = {
            width: reversedWidth,
            height: reversedHeight,
            left: (canvasData.width - reversedWidth) / 2,
            top: (canvasData.height - reversedHeight) / 2
          };
        }

        extend(imageData, newImageData || {
          width: canvasData.width,
          height: canvasData.height,
          left: 0,
          top: 0
        });

        setStyle(self.image, extend({
          width: imageData.width,
          height: imageData.height
        }, getTransforms(extend({
          translateX: imageData.left,
          translateY: imageData.top
        }, imageData))));

        if (changed) {
          self.output();
        }
      },
      initCropBox: function initCropBox() {
        var self = this;
        var options = self.options;
        var aspectRatio = options.aspectRatio;
        var autoCropArea = Number(options.autoCropArea) || 0.8;
        var canvasData = self.canvasData;
        var cropBoxData = {
          width: canvasData.width,
          height: canvasData.height
        };

        if (aspectRatio) {
          if (canvasData.height * aspectRatio > canvasData.width) {
            cropBoxData.height = cropBoxData.width / aspectRatio;
          } else {
            cropBoxData.width = cropBoxData.height * aspectRatio;
          }
        }

        self.cropBoxData = cropBoxData;
        self.limitCropBox(true, true);

        // Initialize auto crop area
        cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
        cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);

        // The width/height of auto crop area must large than "minWidth/Height"
        cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
        cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
        cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
        cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
        cropBoxData.oldLeft = cropBoxData.left;
        cropBoxData.oldTop = cropBoxData.top;

        self.initialCropBoxData = extend({}, cropBoxData);
      },
      limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
        var self = this;
        var options = self.options;
        var aspectRatio = options.aspectRatio;
        var containerData = self.containerData;
        var canvasData = self.canvasData;
        var cropBoxData = self.cropBoxData;
        var limited = self.limited;

        if (sizeLimited) {
          var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
          var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
          var maxCropBoxWidth = Math.min(containerData.width, limited ? canvasData.width : containerData.width);
          var maxCropBoxHeight = Math.min(containerData.height, limited ? canvasData.height : containerData.height);

          // The min/maxCropBoxWidth/Height must be less than containerWidth/Height
          minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
          minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);

          if (aspectRatio) {
            if (minCropBoxWidth && minCropBoxHeight) {
              if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
                minCropBoxHeight = minCropBoxWidth / aspectRatio;
              } else {
                minCropBoxWidth = minCropBoxHeight * aspectRatio;
              }
            } else if (minCropBoxWidth) {
              minCropBoxHeight = minCropBoxWidth / aspectRatio;
            } else if (minCropBoxHeight) {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }

            if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
              maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
            } else {
              maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
            }
          }

          // The minWidth/Height must be less than maxWidth/Height
          cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
          cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
          cropBoxData.maxWidth = maxCropBoxWidth;
          cropBoxData.maxHeight = maxCropBoxHeight;
        }

        if (positionLimited) {
          if (limited) {
            cropBoxData.minLeft = Math.max(0, canvasData.left);
            cropBoxData.minTop = Math.max(0, canvasData.top);
            cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
            cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
          } else {
            cropBoxData.minLeft = 0;
            cropBoxData.minTop = 0;
            cropBoxData.maxLeft = containerData.width - cropBoxData.width;
            cropBoxData.maxTop = containerData.height - cropBoxData.height;
          }
        }
      },
      renderCropBox: function renderCropBox() {
        var self = this;
        var options = self.options;
        var containerData = self.containerData;
        var cropBoxData = self.cropBoxData;

        if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
          cropBoxData.left = cropBoxData.oldLeft;
        }

        if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
          cropBoxData.top = cropBoxData.oldTop;
        }

        cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
        cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);

        self.limitCropBox(false, true);

        cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
        cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
        cropBoxData.oldLeft = cropBoxData.left;
        cropBoxData.oldTop = cropBoxData.top;

        if (options.movable && options.cropBoxMovable) {
          // Turn to move the canvas when the crop box is equal to the container
          setData(self.face, 'action', cropBoxData.width === containerData.width && cropBoxData.height === containerData.height ? 'move' : 'all');
        }

        setStyle(self.cropBox, extend({
          width: cropBoxData.width,
          height: cropBoxData.height
        }, getTransforms({
          translateX: cropBoxData.left,
          translateY: cropBoxData.top
        })));

        if (self.cropped && self.limited) {
          self.limitCanvas(true, true);
        }

        if (!self.disabled) {
          self.output();
        }
      },
      output: function output() {
        var self = this;

        self.preview();

        if (self.complete) {
          dispatchEvent(self.element, 'crop', self.getData());
        }
      }
    };

    var DATA_PREVIEW = 'preview';

    var preview = {
      initPreview: function initPreview() {
        var self = this;
        var preview = self.options.preview;
        var image = createElement('img');
        var crossOrigin = self.crossOrigin;
        var url = crossOrigin ? self.crossOriginUrl : self.url;

        if (crossOrigin) {
          image.crossOrigin = crossOrigin;
        }

        image.src = url;
        appendChild(self.viewBox, image);
        self.image2 = image;

        if (!preview) {
          return;
        }

        var previews = preview.querySelector ? [preview] : document.querySelectorAll(preview);

        self.previews = previews;

        each(previews, function (element) {
          var img = createElement('img');

          // Save the original size for recover
          setData(element, DATA_PREVIEW, {
            width: element.offsetWidth,
            height: element.offsetHeight,
            html: element.innerHTML
          });

          if (crossOrigin) {
            img.crossOrigin = crossOrigin;
          }

          img.src = url;

          /**
           * Override img element styles
           * Add `display:block` to avoid margin top issue
           * Add `height:auto` to override `height` attribute on IE8
           * (Occur only when margin-top <= -height)
           */

          img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';

          empty(element);
          appendChild(element, img);
        });
      },
      resetPreview: function resetPreview() {
        each(this.previews, function (element) {
          var data = getData(element, DATA_PREVIEW);

          setStyle(element, {
            width: data.width,
            height: data.height
          });

          element.innerHTML = data.html;
          removeData(element, DATA_PREVIEW);
        });
      },
      preview: function preview() {
        var self = this;
        var imageData = self.imageData;
        var canvasData = self.canvasData;
        var cropBoxData = self.cropBoxData;
        var cropBoxWidth = cropBoxData.width;
        var cropBoxHeight = cropBoxData.height;
        var width = imageData.width;
        var height = imageData.height;
        var left = cropBoxData.left - canvasData.left - imageData.left;
        var top = cropBoxData.top - canvasData.top - imageData.top;

        if (!self.cropped || self.disabled) {
          return;
        }

        setStyle(self.image2, extend({
          width: width,
          height: height
        }, getTransforms(extend({
          translateX: -left,
          translateY: -top
        }, imageData))));

        each(self.previews, function (element) {
          var data = getData(element, DATA_PREVIEW);
          var originalWidth = data.width;
          var originalHeight = data.height;
          var newWidth = originalWidth;
          var newHeight = originalHeight;
          var ratio = 1;

          if (cropBoxWidth) {
            ratio = originalWidth / cropBoxWidth;
            newHeight = cropBoxHeight * ratio;
          }

          if (cropBoxHeight && newHeight > originalHeight) {
            ratio = originalHeight / cropBoxHeight;
            newWidth = cropBoxWidth * ratio;
            newHeight = originalHeight;
          }

          setStyle(element, {
            width: newWidth,
            height: newHeight
          });

          setStyle(getByTag(element, 'img')[0], extend({
            width: width * ratio,
            height: height * ratio
          }, getTransforms(extend({
            translateX: -left * ratio,
            translateY: -top * ratio
          }, imageData))));
        });
      }
    };

    // Globals
    var PointerEvent = typeof window !== 'undefined' ? window.PointerEvent : null;

    // Events
    var EVENT_POINTER_DOWN = PointerEvent ? 'pointerdown' : 'touchstart mousedown';
    var EVENT_POINTER_MOVE = PointerEvent ? 'pointermove' : 'touchmove mousemove';
    var EVENT_POINTER_UP = PointerEvent ? ' pointerup pointercancel' : 'touchend touchcancel mouseup';
    var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';
    var EVENT_DBLCLICK = 'dblclick';
    var EVENT_RESIZE = 'resize';
    var EVENT_CROP_START = 'cropstart';
    var EVENT_CROP_MOVE = 'cropmove';
    var EVENT_CROP_END = 'cropend';
    var EVENT_CROP$1 = 'crop';
    var EVENT_ZOOM = 'zoom';

    var events = {
      bind: function bind() {
        var self = this;
        var options = self.options;
        var element = self.element;
        var cropper = self.cropper;

        if (isFunction(options.cropstart)) {
          addListener(element, EVENT_CROP_START, options.cropstart);
        }

        if (isFunction(options.cropmove)) {
          addListener(element, EVENT_CROP_MOVE, options.cropmove);
        }

        if (isFunction(options.cropend)) {
          addListener(element, EVENT_CROP_END, options.cropend);
        }

        if (isFunction(options.crop)) {
          addListener(element, EVENT_CROP$1, options.crop);
        }

        if (isFunction(options.zoom)) {
          addListener(element, EVENT_ZOOM, options.zoom);
        }

        addListener(cropper, EVENT_POINTER_DOWN, self.onCropStart = proxy(self.cropStart, self));

        if (options.zoomable && options.zoomOnWheel) {
          addListener(cropper, EVENT_WHEEL, self.onWheel = proxy(self.wheel, self));
        }

        if (options.toggleDragModeOnDblclick) {
          addListener(cropper, EVENT_DBLCLICK, self.onDblclick = proxy(self.dblclick, self));
        }

        addListener(document, EVENT_POINTER_MOVE, self.onCropMove = proxy(self.cropMove, self));
        addListener(document, EVENT_POINTER_UP, self.onCropEnd = proxy(self.cropEnd, self));

        if (options.responsive) {
          addListener(window, EVENT_RESIZE, self.onResize = proxy(self.resize, self));
        }
      },
      unbind: function unbind() {
        var self = this;
        var options = self.options;
        var element = self.element;
        var cropper = self.cropper;

        if (isFunction(options.cropstart)) {
          removeListener(element, EVENT_CROP_START, options.cropstart);
        }

        if (isFunction(options.cropmove)) {
          removeListener(element, EVENT_CROP_MOVE, options.cropmove);
        }

        if (isFunction(options.cropend)) {
          removeListener(element, EVENT_CROP_END, options.cropend);
        }

        if (isFunction(options.crop)) {
          removeListener(element, EVENT_CROP$1, options.crop);
        }

        if (isFunction(options.zoom)) {
          removeListener(element, EVENT_ZOOM, options.zoom);
        }

        removeListener(cropper, EVENT_POINTER_DOWN, self.onCropStart);

        if (options.zoomable && options.zoomOnWheel) {
          removeListener(cropper, EVENT_WHEEL, self.onWheel);
        }

        if (options.toggleDragModeOnDblclick) {
          removeListener(cropper, EVENT_DBLCLICK, self.onDblclick);
        }

        removeListener(document, EVENT_POINTER_MOVE, self.onCropMove);
        removeListener(document, EVENT_POINTER_UP, self.onCropEnd);

        if (options.responsive) {
          removeListener(window, EVENT_RESIZE, self.onResize);
        }
      }
    };

    var REGEXP_ACTIONS = /^(e|w|s|n|se|sw|ne|nw|all|crop|move|zoom)$/;

    function getPointer(_ref, endOnly) {
      var pageX = _ref.pageX,
          pageY = _ref.pageY;

      var end = {
        endX: pageX,
        endY: pageY
      };

      if (endOnly) {
        return end;
      }

      return extend({
        startX: pageX,
        startY: pageY
      }, end);
    }

    var handlers = {
      resize: function resize() {
        var self = this;
        var options = self.options;
        var container = self.container;
        var containerData = self.containerData;
        var minContainerWidth = Number(options.minContainerWidth) || 200;
        var minContainerHeight = Number(options.minContainerHeight) || 100;

        if (self.disabled || containerData.width === minContainerWidth || containerData.height === minContainerHeight) {
          return;
        }

        var ratio = container.offsetWidth / containerData.width;

        // Resize when width changed or height changed
        if (ratio !== 1 || container.offsetHeight !== containerData.height) {
          var canvasData = void 0;
          var cropBoxData = void 0;

          if (options.restore) {
            canvasData = self.getCanvasData();
            cropBoxData = self.getCropBoxData();
          }

          self.render();

          if (options.restore) {
            self.setCanvasData(each(canvasData, function (n, i) {
              canvasData[i] = n * ratio;
            }));
            self.setCropBoxData(each(cropBoxData, function (n, i) {
              cropBoxData[i] = n * ratio;
            }));
          }
        }
      },
      dblclick: function dblclick() {
        var self = this;

        if (self.disabled || self.options.dragMode === 'none') {
          return;
        }

        self.setDragMode(hasClass(self.dragBox, 'cropper-crop') ? 'move' : 'crop');
      },
      wheel: function wheel(event) {
        var self = this;
        var e = getEvent(event);
        var ratio = Number(self.options.wheelZoomRatio) || 0.1;
        var delta = 1;

        if (self.disabled) {
          return;
        }

        e.preventDefault();

        // Limit wheel speed to prevent zoom too fast (#21)
        if (self.wheeling) {
          return;
        }

        self.wheeling = true;

        setTimeout(function () {
          self.wheeling = false;
        }, 50);

        if (e.deltaY) {
          delta = e.deltaY > 0 ? 1 : -1;
        } else if (e.wheelDelta) {
          delta = -e.wheelDelta / 120;
        } else if (e.detail) {
          delta = e.detail > 0 ? 1 : -1;
        }

        self.zoom(-delta * ratio, e);
      },
      cropStart: function cropStart(event) {
        var self = this;

        if (self.disabled) {
          return;
        }

        var options = self.options;
        var pointers = self.pointers;
        var e = getEvent(event);
        var action = void 0;

        if (e.changedTouches) {
          // Handle touch event
          each(e.changedTouches, function (touch) {
            pointers[touch.identifier] = getPointer(touch);
          });
        } else {
          // Handle mouse event and pointer event
          pointers[e.pointerId || 0] = getPointer(e);
        }

        if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
          action = 'zoom';
        } else {
          action = getData(e.target, 'action');
        }

        if (!REGEXP_ACTIONS.test(action)) {
          return;
        }

        if (dispatchEvent(self.element, 'cropstart', {
          originalEvent: e,
          action: action
        }) === false) {
          return;
        }

        e.preventDefault();

        self.action = action;
        self.cropping = false;

        if (action === 'crop') {
          self.cropping = true;
          addClass(self.dragBox, 'cropper-modal');
        }
      },
      cropMove: function cropMove(event) {
        var self = this;
        var action = self.action;

        if (self.disabled || !action) {
          return;
        }

        var pointers = self.pointers;
        var e = getEvent(event);

        e.preventDefault();

        if (dispatchEvent(self.element, 'cropmove', {
          originalEvent: e,
          action: action
        }) === false) {
          return;
        }

        if (e.changedTouches) {
          each(e.changedTouches, function (touch) {
            extend(pointers[touch.identifier], getPointer(touch, true));
          });
        } else {
          extend(pointers[e.pointerId || 0], getPointer(e, true));
        }

        self.change(e);
      },
      cropEnd: function cropEnd(event) {
        var self = this;

        if (self.disabled) {
          return;
        }

        var action = self.action;
        var pointers = self.pointers;
        var e = getEvent(event);

        if (e.changedTouches) {
          each(e.changedTouches, function (touch) {
            delete pointers[touch.identifier];
          });
        } else {
          delete pointers[e.pointerId || 0];
        }

        if (!action) {
          return;
        }

        e.preventDefault();

        if (!Object.keys(pointers).length) {
          self.action = '';
        }

        if (self.cropping) {
          self.cropping = false;
          toggleClass(self.dragBox, 'cropper-modal', self.cropped && this.options.modal);
        }

        dispatchEvent(self.element, 'cropend', {
          originalEvent: e,
          action: action
        });
      }
    };

    // Actions
    var ACTION_EAST = 'e';
    var ACTION_WEST = 'w';
    var ACTION_SOUTH = 's';
    var ACTION_NORTH = 'n';
    var ACTION_SOUTH_EAST = 'se';
    var ACTION_SOUTH_WEST = 'sw';
    var ACTION_NORTH_EAST = 'ne';
    var ACTION_NORTH_WEST = 'nw';

    function getMaxZoomRatio(pointers) {
      var pointers2 = extend({}, pointers);
      var ratios = [];

      each(pointers, function (pointer, pointerId) {
        delete pointers2[pointerId];

        each(pointers2, function (pointer2) {
          var x1 = Math.abs(pointer.startX - pointer2.startX);
          var y1 = Math.abs(pointer.startY - pointer2.startY);
          var x2 = Math.abs(pointer.endX - pointer2.endX);
          var y2 = Math.abs(pointer.endY - pointer2.endY);
          var z1 = Math.sqrt(x1 * x1 + y1 * y1);
          var z2 = Math.sqrt(x2 * x2 + y2 * y2);
          var ratio = (z2 - z1) / z1;

          ratios.push(ratio);
        });
      });

      ratios.sort(function (a, b) {
        return Math.abs(a) < Math.abs(b);
      });

      return ratios[0];
    }

    var change = {
      change: function change(e) {
        var self = this;
        var options = self.options;
        var containerData = self.containerData;
        var canvasData = self.canvasData;
        var cropBoxData = self.cropBoxData;
        var aspectRatio = options.aspectRatio;
        var action = self.action;
        var width = cropBoxData.width;
        var height = cropBoxData.height;
        var left = cropBoxData.left;
        var top = cropBoxData.top;
        var right = left + width;
        var bottom = top + height;
        var minLeft = 0;
        var minTop = 0;
        var maxWidth = containerData.width;
        var maxHeight = containerData.height;
        var renderable = true;
        var offset = void 0;

        // Locking aspect ratio in "free mode" by holding shift key
        if (!aspectRatio && e.shiftKey) {
          aspectRatio = width && height ? width / height : 1;
        }

        if (self.limited) {
          minLeft = cropBoxData.minLeft;
          minTop = cropBoxData.minTop;
          maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
          maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
        }

        var pointers = self.pointers;
        var pointer = pointers[Object.keys(pointers)[0]];
        var range = {
          x: pointer.endX - pointer.startX,
          y: pointer.endY - pointer.startY
        };

        switch (action) {
          // Move crop box
          case 'all':
            left += range.x;
            top += range.y;
            break;

          // Resize crop box
          case ACTION_EAST:
            if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
              renderable = false;
              break;
            }

            if (right + range.x > maxWidth) {
              range.x = maxWidth - right;
            }

            width += range.x;

            if (aspectRatio) {
              height = width / aspectRatio;
              top -= range.x / aspectRatio / 2;
            }

            if (width < 0) {
              action = ACTION_WEST;
              width = 0;
            }

            break;

          case ACTION_NORTH:
            if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
              renderable = false;
              break;
            }

            if (top + range.y < minTop) {
              range.y = minTop - top;
            }

            height -= range.y;
            top += range.y;

            if (aspectRatio) {
              width = height * aspectRatio;
              left += range.y * aspectRatio / 2;
            }

            if (height < 0) {
              action = ACTION_SOUTH;
              height = 0;
            }

            break;

          case ACTION_WEST:
            if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
              renderable = false;
              break;
            }

            if (left + range.x < minLeft) {
              range.x = minLeft - left;
            }

            width -= range.x;
            left += range.x;

            if (aspectRatio) {
              height = width / aspectRatio;
              top += range.x / aspectRatio / 2;
            }

            if (width < 0) {
              action = ACTION_EAST;
              width = 0;
            }

            break;

          case ACTION_SOUTH:
            if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
              renderable = false;
              break;
            }

            if (bottom + range.y > maxHeight) {
              range.y = maxHeight - bottom;
            }

            height += range.y;

            if (aspectRatio) {
              width = height * aspectRatio;
              left -= range.y * aspectRatio / 2;
            }

            if (height < 0) {
              action = ACTION_NORTH;
              height = 0;
            }

            break;

          case ACTION_NORTH_EAST:
            if (aspectRatio) {
              if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
                renderable = false;
                break;
              }

              height -= range.y;
              top += range.y;
              width = height * aspectRatio;
            } else {
              if (range.x >= 0) {
                if (right < maxWidth) {
                  width += range.x;
                } else if (range.y <= 0 && top <= minTop) {
                  renderable = false;
                }
              } else {
                width += range.x;
              }

              if (range.y <= 0) {
                if (top > minTop) {
                  height -= range.y;
                  top += range.y;
                }
              } else {
                height -= range.y;
                top += range.y;
              }
            }

            if (width < 0 && height < 0) {
              action = ACTION_SOUTH_WEST;
              height = 0;
              width = 0;
            } else if (width < 0) {
              action = ACTION_NORTH_WEST;
              width = 0;
            } else if (height < 0) {
              action = ACTION_SOUTH_EAST;
              height = 0;
            }

            break;

          case ACTION_NORTH_WEST:
            if (aspectRatio) {
              if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
                renderable = false;
                break;
              }

              height -= range.y;
              top += range.y;
              width = height * aspectRatio;
              left += range.y * aspectRatio;
            } else {
              if (range.x <= 0) {
                if (left > minLeft) {
                  width -= range.x;
                  left += range.x;
                } else if (range.y <= 0 && top <= minTop) {
                  renderable = false;
                }
              } else {
                width -= range.x;
                left += range.x;
              }

              if (range.y <= 0) {
                if (top > minTop) {
                  height -= range.y;
                  top += range.y;
                }
              } else {
                height -= range.y;
                top += range.y;
              }
            }

            if (width < 0 && height < 0) {
              action = ACTION_SOUTH_EAST;
              height = 0;
              width = 0;
            } else if (width < 0) {
              action = ACTION_NORTH_EAST;
              width = 0;
            } else if (height < 0) {
              action = ACTION_SOUTH_WEST;
              height = 0;
            }

            break;

          case ACTION_SOUTH_WEST:
            if (aspectRatio) {
              if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
                renderable = false;
                break;
              }

              width -= range.x;
              left += range.x;
              height = width / aspectRatio;
            } else {
              if (range.x <= 0) {
                if (left > minLeft) {
                  width -= range.x;
                  left += range.x;
                } else if (range.y >= 0 && bottom >= maxHeight) {
                  renderable = false;
                }
              } else {
                width -= range.x;
                left += range.x;
              }

              if (range.y >= 0) {
                if (bottom < maxHeight) {
                  height += range.y;
                }
              } else {
                height += range.y;
              }
            }

            if (width < 0 && height < 0) {
              action = ACTION_NORTH_EAST;
              height = 0;
              width = 0;
            } else if (width < 0) {
              action = ACTION_SOUTH_EAST;
              width = 0;
            } else if (height < 0) {
              action = ACTION_NORTH_WEST;
              height = 0;
            }

            break;

          case ACTION_SOUTH_EAST:
            if (aspectRatio) {
              if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
                renderable = false;
                break;
              }

              width += range.x;
              height = width / aspectRatio;
            } else {
              if (range.x >= 0) {
                if (right < maxWidth) {
                  width += range.x;
                } else if (range.y >= 0 && bottom >= maxHeight) {
                  renderable = false;
                }
              } else {
                width += range.x;
              }

              if (range.y >= 0) {
                if (bottom < maxHeight) {
                  height += range.y;
                }
              } else {
                height += range.y;
              }
            }

            if (width < 0 && height < 0) {
              action = ACTION_NORTH_WEST;
              height = 0;
              width = 0;
            } else if (width < 0) {
              action = ACTION_SOUTH_WEST;
              width = 0;
            } else if (height < 0) {
              action = ACTION_NORTH_EAST;
              height = 0;
            }

            break;

          // Move canvas
          case 'move':
            self.move(range.x, range.y);
            renderable = false;
            break;

          // Zoom canvas
          case 'zoom':
            self.zoom(getMaxZoomRatio(pointers), e);
            renderable = false;
            break;

          // Create crop box
          case 'crop':
            if (!range.x || !range.y) {
              renderable = false;
              break;
            }

            offset = getOffset(self.cropper);
            left = pointer.startX - offset.left;
            top = pointer.startY - offset.top;
            width = cropBoxData.minWidth;
            height = cropBoxData.minHeight;

            if (range.x > 0) {
              action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
            } else if (range.x < 0) {
              left -= width;
              action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
            }

            if (range.y < 0) {
              top -= height;
            }

            // Show the crop box if is hidden
            if (!self.cropped) {
              removeClass(self.cropBox, 'cropper-hidden');
              self.cropped = true;

              if (self.limited) {
                self.limitCropBox(true, true);
              }
            }

            break;

          default:
        }

        if (renderable) {
          cropBoxData.width = width;
          cropBoxData.height = height;
          cropBoxData.left = left;
          cropBoxData.top = top;
          self.action = action;

          self.renderCropBox();
        }

        // Override
        each(pointers, function (p) {
          p.startX = p.endX;
          p.startY = p.endY;
        });
      }
    };

    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }return arr2;
      } else {
        return Array.from(arr);
      }
    }

    function getPointersCenter(pointers) {
      var pageX = 0;
      var pageY = 0;
      var count = 0;

      each(pointers, function (_ref) {
        var startX = _ref.startX,
            startY = _ref.startY;

        pageX += startX;
        pageY += startY;
        count += 1;
      });

      pageX /= count;
      pageY /= count;

      return {
        pageX: pageX,
        pageY: pageY
      };
    }

    var methods = {
      // Show the crop box manually
      crop: function crop() {
        var self = this;

        if (self.ready && !self.disabled) {
          if (!self.cropped) {
            self.cropped = true;
            self.limitCropBox(true, true);

            if (self.options.modal) {
              addClass(self.dragBox, 'cropper-modal');
            }

            removeClass(self.cropBox, 'cropper-hidden');
          }

          self.setCropBoxData(self.initialCropBoxData);
        }

        return self;
      },

      // Reset the image and crop box to their initial states
      reset: function reset() {
        var self = this;

        if (self.ready && !self.disabled) {
          self.imageData = extend({}, self.initialImageData);
          self.canvasData = extend({}, self.initialCanvasData);
          self.cropBoxData = extend({}, self.initialCropBoxData);

          self.renderCanvas();

          if (self.cropped) {
            self.renderCropBox();
          }
        }

        return self;
      },

      // Clear the crop box
      clear: function clear() {
        var self = this;

        if (self.cropped && !self.disabled) {
          extend(self.cropBoxData, {
            left: 0,
            top: 0,
            width: 0,
            height: 0
          });

          self.cropped = false;
          self.renderCropBox();

          self.limitCanvas(true, true);

          // Render canvas after crop box rendered
          self.renderCanvas();

          removeClass(self.dragBox, 'cropper-modal');
          addClass(self.cropBox, 'cropper-hidden');
        }

        return self;
      },

      /**
       * Replace the image's src and rebuild the cropper
       *
       * @param {String} url
       * @param {Boolean} onlyColorChanged (optional)
       */
      replace: function replace(url, onlyColorChanged) {
        var self = this;

        if (!self.disabled && url) {
          if (self.isImg) {
            self.element.src = url;
          }

          if (onlyColorChanged) {
            self.url = url;
            self.image.src = url;

            if (self.ready) {
              self.image2.src = url;

              each(self.previews, function (element) {
                getByTag(element, 'img')[0].src = url;
              });
            }
          } else {
            if (self.isImg) {
              self.replaced = true;
            }

            // Clear previous data
            self.options.data = null;
            self.load(url);
          }
        }

        return self;
      },

      // Enable (unfreeze) the cropper
      enable: function enable() {
        var self = this;

        if (self.ready) {
          self.disabled = false;
          removeClass(self.cropper, 'cropper-disabled');
        }

        return self;
      },

      // Disable (freeze) the cropper
      disable: function disable() {
        var self = this;

        if (self.ready) {
          self.disabled = true;
          addClass(self.cropper, 'cropper-disabled');
        }

        return self;
      },

      // Destroy the cropper and remove the instance from the image
      destroy: function destroy() {
        var self = this;
        var element = self.element;
        var image = self.image;

        if (self.loaded) {
          if (self.isImg && self.replaced) {
            element.src = self.originalUrl;
          }

          self.unbuild();
          removeClass(element, 'cropper-hidden');
        } else if (self.isImg) {
          removeListener(element, 'load', self.onStart);
        } else if (image) {
          removeChild(image);
        }

        removeData(element, 'cropper');

        return self;
      },

      /**
       * Move the canvas with relative offsets
       *
       * @param {Number} offsetX
       * @param {Number} offsetY (optional)
       */
      move: function move(offsetX, offsetY) {
        var self = this;
        var canvasData = self.canvasData;

        return self.moveTo(isUndefined(offsetX) ? offsetX : canvasData.left + Number(offsetX), isUndefined(offsetY) ? offsetY : canvasData.top + Number(offsetY));
      },

      /**
       * Move the canvas to an absolute point
       *
       * @param {Number} x
       * @param {Number} y (optional)
       */
      moveTo: function moveTo(x, y) {
        var self = this;
        var canvasData = self.canvasData;
        var changed = false;

        // If "y" is not present, its default value is "x"
        if (isUndefined(y)) {
          y = x;
        }

        x = Number(x);
        y = Number(y);

        if (self.ready && !self.disabled && self.options.movable) {
          if (isNumber(x)) {
            canvasData.left = x;
            changed = true;
          }

          if (isNumber(y)) {
            canvasData.top = y;
            changed = true;
          }

          if (changed) {
            self.renderCanvas(true);
          }
        }

        return self;
      },

      /**
       * Zoom the canvas with a relative ratio
       *
       * @param {Number} ratio
       * @param {Event} _originalEvent (private)
       */
      zoom: function zoom(ratio, _originalEvent) {
        var self = this;
        var canvasData = self.canvasData;

        ratio = Number(ratio);

        if (ratio < 0) {
          ratio = 1 / (1 - ratio);
        } else {
          ratio = 1 + ratio;
        }

        return self.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, _originalEvent);
      },

      /**
       * Zoom the canvas to an absolute ratio
       *
       * @param {Number} ratio
       * @param {Event} _originalEvent (private)
       */
      zoomTo: function zoomTo(ratio, _originalEvent) {
        var self = this;
        var options = self.options;
        var canvasData = self.canvasData;
        var width = canvasData.width;
        var height = canvasData.height;
        var naturalWidth = canvasData.naturalWidth;
        var naturalHeight = canvasData.naturalHeight;

        ratio = Number(ratio);

        if (ratio >= 0 && self.ready && !self.disabled && options.zoomable) {
          var newWidth = naturalWidth * ratio;
          var newHeight = naturalHeight * ratio;

          if (dispatchEvent(self.element, 'zoom', {
            originalEvent: _originalEvent,
            oldRatio: width / naturalWidth,
            ratio: newWidth / naturalWidth
          }) === false) {
            return self;
          }

          if (_originalEvent) {
            var pointers = self.pointers;
            var offset = getOffset(self.cropper);
            var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
              pageX: _originalEvent.pageX,
              pageY: _originalEvent.pageY
            };

            // Zoom from the triggering point of the event
            canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
            canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
          } else {
            // Zoom from the center of the canvas
            canvasData.left -= (newWidth - width) / 2;
            canvasData.top -= (newHeight - height) / 2;
          }

          canvasData.width = newWidth;
          canvasData.height = newHeight;
          self.renderCanvas(true);
        }

        return self;
      },

      /**
       * Rotate the canvas with a relative degree
       *
       * @param {Number} degree
       */
      rotate: function rotate(degree) {
        var self = this;

        return self.rotateTo((self.imageData.rotate || 0) + Number(degree));
      },

      /**
       * Rotate the canvas to an absolute degree
       * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()
       *
       * @param {Number} degree
       */
      rotateTo: function rotateTo(degree) {
        var self = this;

        degree = Number(degree);

        if (isNumber(degree) && self.ready && !self.disabled && self.options.rotatable) {
          self.imageData.rotate = degree % 360;
          self.rotated = true;
          self.renderCanvas(true);
        }

        return self;
      },

      /**
       * Scale the image
       * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()
       *
       * @param {Number} scaleX
       * @param {Number} scaleY (optional)
       */
      scale: function scale(scaleX, scaleY) {
        var self = this;
        var imageData = self.imageData;
        var changed = false;

        // If "scaleY" is not present, its default value is "scaleX"
        if (isUndefined(scaleY)) {
          scaleY = scaleX;
        }

        scaleX = Number(scaleX);
        scaleY = Number(scaleY);

        if (self.ready && !self.disabled && self.options.scalable) {
          if (isNumber(scaleX)) {
            imageData.scaleX = scaleX;
            changed = true;
          }

          if (isNumber(scaleY)) {
            imageData.scaleY = scaleY;
            changed = true;
          }

          if (changed) {
            self.renderImage(true);
          }
        }

        return self;
      },

      /**
       * Scale the abscissa of the image
       *
       * @param {Number} scaleX
       */
      scaleX: function scaleX(_scaleX) {
        var self = this;
        var scaleY = self.imageData.scaleY;

        return self.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
      },

      /**
       * Scale the ordinate of the image
       *
       * @param {Number} scaleY
       */
      scaleY: function scaleY(_scaleY) {
        var self = this;
        var scaleX = self.imageData.scaleX;

        return self.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
      },

      /**
       * Get the cropped area position and size data (base on the original image)
       *
       * @param {Boolean} rounded (optional)
       * @return {Object} data
       */
      getData: function getData$$1(rounded) {
        var self = this;
        var options = self.options;
        var imageData = self.imageData;
        var canvasData = self.canvasData;
        var cropBoxData = self.cropBoxData;
        var ratio = void 0;
        var data = void 0;

        if (self.ready && self.cropped) {
          data = {
            x: cropBoxData.left - canvasData.left,
            y: cropBoxData.top - canvasData.top,
            width: cropBoxData.width,
            height: cropBoxData.height
          };

          ratio = imageData.width / imageData.naturalWidth;

          each(data, function (n, i) {
            n /= ratio;
            data[i] = rounded ? Math.round(n) : n;
          });
        } else {
          data = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }

        if (options.rotatable) {
          data.rotate = imageData.rotate || 0;
        }

        if (options.scalable) {
          data.scaleX = imageData.scaleX || 1;
          data.scaleY = imageData.scaleY || 1;
        }

        return data;
      },

      /**
       * Set the cropped area position and size with new data
       *
       * @param {Object} data
       */
      setData: function setData$$1(data) {
        var self = this;
        var options = self.options;
        var imageData = self.imageData;
        var canvasData = self.canvasData;
        var cropBoxData = {};
        var rotated = void 0;
        var scaled = void 0;
        var ratio = void 0;

        if (isFunction(data)) {
          data = data.call(self.element);
        }

        if (self.ready && !self.disabled && isPlainObject(data)) {
          if (options.rotatable) {
            if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
              imageData.rotate = data.rotate;
              rotated = true;
              self.rotated = rotated;
            }
          }

          if (options.scalable) {
            if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
              imageData.scaleX = data.scaleX;
              scaled = true;
            }

            if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
              imageData.scaleY = data.scaleY;
              scaled = true;
            }
          }

          if (rotated) {
            self.renderCanvas();
          } else if (scaled) {
            self.renderImage();
          }

          ratio = imageData.width / imageData.naturalWidth;

          if (isNumber(data.x)) {
            cropBoxData.left = data.x * ratio + canvasData.left;
          }

          if (isNumber(data.y)) {
            cropBoxData.top = data.y * ratio + canvasData.top;
          }

          if (isNumber(data.width)) {
            cropBoxData.width = data.width * ratio;
          }

          if (isNumber(data.height)) {
            cropBoxData.height = data.height * ratio;
          }

          self.setCropBoxData(cropBoxData);
        }

        return self;
      },

      /**
       * Get the container size data
       *
       * @return {Object} data
       */
      getContainerData: function getContainerData() {
        var self = this;

        return self.ready ? self.containerData : {};
      },

      /**
       * Get the image position and size data
       *
       * @return {Object} data
       */
      getImageData: function getImageData() {
        var self = this;

        return self.loaded ? self.imageData : {};
      },

      /**
       * Get the canvas position and size data
       *
       * @return {Object} data
       */
      getCanvasData: function getCanvasData() {
        var self = this;
        var canvasData = self.canvasData;
        var data = {};

        if (self.ready) {
          each(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {
            data[n] = canvasData[n];
          });
        }

        return data;
      },

      /**
       * Set the canvas position and size with new data
       *
       * @param {Object} data
       */
      setCanvasData: function setCanvasData(data) {
        var self = this;
        var canvasData = self.canvasData;
        var aspectRatio = canvasData.aspectRatio;

        if (isFunction(data)) {
          data = data.call(self.element);
        }

        if (self.ready && !self.disabled && isPlainObject(data)) {
          if (isNumber(data.left)) {
            canvasData.left = data.left;
          }

          if (isNumber(data.top)) {
            canvasData.top = data.top;
          }

          if (isNumber(data.width)) {
            canvasData.width = data.width;
            canvasData.height = data.width / aspectRatio;
          } else if (isNumber(data.height)) {
            canvasData.height = data.height;
            canvasData.width = data.height * aspectRatio;
          }

          self.renderCanvas(true);
        }

        return self;
      },

      /**
       * Get the crop box position and size data
       *
       * @return {Object} data
       */
      getCropBoxData: function getCropBoxData() {
        var self = this;
        var cropBoxData = self.cropBoxData;
        var data = void 0;

        if (self.ready && self.cropped) {
          data = {
            left: cropBoxData.left,
            top: cropBoxData.top,
            width: cropBoxData.width,
            height: cropBoxData.height
          };
        }

        return data || {};
      },

      /**
       * Set the crop box position and size with new data
       *
       * @param {Object} data
       */
      setCropBoxData: function setCropBoxData(data) {
        var self = this;
        var cropBoxData = self.cropBoxData;
        var aspectRatio = self.options.aspectRatio;
        var widthChanged = void 0;
        var heightChanged = void 0;

        if (isFunction(data)) {
          data = data.call(self.element);
        }

        if (self.ready && self.cropped && !self.disabled && isPlainObject(data)) {
          if (isNumber(data.left)) {
            cropBoxData.left = data.left;
          }

          if (isNumber(data.top)) {
            cropBoxData.top = data.top;
          }

          if (isNumber(data.width) && data.width !== cropBoxData.width) {
            widthChanged = true;
            cropBoxData.width = data.width;
          }

          if (isNumber(data.height) && data.height !== cropBoxData.height) {
            heightChanged = true;
            cropBoxData.height = data.height;
          }

          if (aspectRatio) {
            if (widthChanged) {
              cropBoxData.height = cropBoxData.width / aspectRatio;
            } else if (heightChanged) {
              cropBoxData.width = cropBoxData.height * aspectRatio;
            }
          }

          self.renderCropBox();
        }

        return self;
      },

      /**
       * Get a canvas drawn the cropped image
       *
       * @param {Object} options (optional)
       * @return {HTMLCanvasElement} canvas
       */
      getCroppedCanvas: function getCroppedCanvas(options) {
        var self = this;

        if (!self.ready || !window.HTMLCanvasElement) {
          return null;
        }

        if (!isPlainObject(options)) {
          options = {};
        }

        // Return the whole canvas if not cropped
        if (!self.cropped) {
          return getSourceCanvas(self.image, self.imageData, options);
        }

        var data = self.getData();
        var originalWidth = data.width;
        var originalHeight = data.height;
        var aspectRatio = originalWidth / originalHeight;
        var scaledWidth = void 0;
        var scaledHeight = void 0;
        var scaledRatio = void 0;

        if (isPlainObject(options)) {
          scaledWidth = options.width;
          scaledHeight = options.height;

          if (scaledWidth) {
            scaledHeight = scaledWidth / aspectRatio;
            scaledRatio = scaledWidth / originalWidth;
          } else if (scaledHeight) {
            scaledWidth = scaledHeight * aspectRatio;
            scaledRatio = scaledHeight / originalHeight;
          }
        }

        // The canvas element will use `Math.floor` on a float number, so floor first
        var canvasWidth = Math.floor(scaledWidth || originalWidth);
        var canvasHeight = Math.floor(scaledHeight || originalHeight);

        var canvas = createElement('canvas');
        var context = canvas.getContext('2d');

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        if (options.fillColor) {
          context.fillStyle = options.fillColor;
          context.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage
        var parameters = function () {
          var source = getSourceCanvas(self.image, self.imageData, options);
          var sourceWidth = source.width;
          var sourceHeight = source.height;
          var canvasData = self.canvasData;
          var params = [source];

          // Source canvas
          var srcX = data.x + canvasData.naturalWidth * (Math.abs(data.scaleX || 1) - 1) / 2;
          var srcY = data.y + canvasData.naturalHeight * (Math.abs(data.scaleY || 1) - 1) / 2;
          var srcWidth = void 0;
          var srcHeight = void 0;

          // Destination canvas
          var dstX = void 0;
          var dstY = void 0;
          var dstWidth = void 0;
          var dstHeight = void 0;

          if (srcX <= -originalWidth || srcX > sourceWidth) {
            srcX = 0;
            srcWidth = 0;
            dstX = 0;
            dstWidth = 0;
          } else if (srcX <= 0) {
            dstX = -srcX;
            srcX = 0;
            srcWidth = Math.min(sourceWidth, originalWidth + srcX);
            dstWidth = srcWidth;
          } else if (srcX <= sourceWidth) {
            dstX = 0;
            srcWidth = Math.min(originalWidth, sourceWidth - srcX);
            dstWidth = srcWidth;
          }

          if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {
            srcY = 0;
            srcHeight = 0;
            dstY = 0;
            dstHeight = 0;
          } else if (srcY <= 0) {
            dstY = -srcY;
            srcY = 0;
            srcHeight = Math.min(sourceHeight, originalHeight + srcY);
            dstHeight = srcHeight;
          } else if (srcY <= sourceHeight) {
            dstY = 0;
            srcHeight = Math.min(originalHeight, sourceHeight - srcY);
            dstHeight = srcHeight;
          }

          params.push(Math.floor(srcX), Math.floor(srcY), Math.floor(srcWidth), Math.floor(srcHeight));

          // Scale destination sizes
          if (scaledRatio) {
            dstX *= scaledRatio;
            dstY *= scaledRatio;
            dstWidth *= scaledRatio;
            dstHeight *= scaledRatio;
          }

          // Avoid "IndexSizeError" in IE and Firefox
          if (dstWidth > 0 && dstHeight > 0) {
            params.push(Math.floor(dstX), Math.floor(dstY), Math.floor(dstWidth), Math.floor(dstHeight));
          }

          return params;
        }();

        context.imageSmoothingEnabled = !!options.imageSmoothingEnabled;

        if (options.imageSmoothingQuality) {
          context.imageSmoothingQuality = options.imageSmoothingQuality;
        }

        context.drawImage.apply(context, _toConsumableArray(parameters));

        return canvas;
      },

      /**
       * Change the aspect ratio of the crop box
       *
       * @param {Number} aspectRatio
       */
      setAspectRatio: function setAspectRatio(aspectRatio) {
        var self = this;
        var options = self.options;

        if (!self.disabled && !isUndefined(aspectRatio)) {
          // 0 -> NaN
          options.aspectRatio = Math.max(0, aspectRatio) || NaN;

          if (self.ready) {
            self.initCropBox();

            if (self.cropped) {
              self.renderCropBox();
            }
          }
        }

        return self;
      },

      /**
       * Change the drag mode
       *
       * @param {String} mode (optional)
       */
      setDragMode: function setDragMode(mode) {
        var self = this;
        var options = self.options;
        var dragBox = self.dragBox;
        var face = self.face;
        var croppable = void 0;
        var movable = void 0;

        if (self.loaded && !self.disabled) {
          croppable = mode === 'crop';
          movable = options.movable && mode === 'move';
          mode = croppable || movable ? mode : 'none';

          setData(dragBox, 'action', mode);
          toggleClass(dragBox, 'cropper-crop', croppable);
          toggleClass(dragBox, 'cropper-move', movable);

          if (!options.cropBoxMovable) {
            // Sync drag mode to crop box when it is not movable
            setData(face, 'action', mode);
            toggleClass(face, 'cropper-crop', croppable);
            toggleClass(face, 'cropper-move', movable);
          }
        }

        return self;
      }
    };

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
      }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
      };
    }();

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    // Constants
    var NAMESPACE = 'cropper';

    // Classes
    var CLASS_HIDDEN = NAMESPACE + '-hidden';

    // Events
    var EVENT_ERROR = 'error';
    var EVENT_LOAD = 'load';
    var EVENT_READY = 'ready';
    var EVENT_CROP = 'crop';

    // RegExps
    var REGEXP_DATA_URL = /^data:/;
    var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;

    var AnotherCropper = void 0;

    var Cropper = function () {
      function Cropper(element, options) {
        _classCallCheck(this, Cropper);

        var self = this;

        self.element = element;
        self.options = extend({}, DEFAULTS, isPlainObject(options) && options);
        self.loaded = false;
        self.ready = false;
        self.complete = false;
        self.rotated = false;
        self.cropped = false;
        self.disabled = false;
        self.replaced = false;
        self.limited = false;
        self.wheeling = false;
        self.isImg = false;
        self.originalUrl = '';
        self.canvasData = null;
        self.cropBoxData = null;
        self.previews = null;
        self.pointers = {};
        self.init();
      }

      _createClass(Cropper, [{
        key: 'init',
        value: function init() {
          var self = this;
          var element = self.element;
          var tagName = element.tagName.toLowerCase();
          var url = void 0;

          if (getData(element, NAMESPACE)) {
            return;
          }

          setData(element, NAMESPACE, self);

          if (tagName === 'img') {
            self.isImg = true;

            // e.g.: "img/picture.jpg"
            url = element.getAttribute('src');
            self.originalUrl = url;

            // Stop when it's a blank image
            if (!url) {
              return;
            }

            // e.g.: "http://example.com/img/picture.jpg"
            url = element.src;
          } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
            url = element.toDataURL();
          }

          self.load(url);
        }
      }, {
        key: 'load',
        value: function load(url) {
          var self = this;
          var options = self.options;
          var element = self.element;

          if (!url) {
            return;
          }

          self.url = url;
          self.imageData = {};

          if (!options.checkOrientation || !window.ArrayBuffer) {
            self.clone();
            return;
          }

          // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari
          if (REGEXP_DATA_URL.test(url)) {
            if (REGEXP_DATA_URL_JPEG.test(url)) {
              self.read(dataURLToArrayBuffer(url));
            } else {
              self.clone();
            }
            return;
          }

          var xhr = new XMLHttpRequest();

          xhr.onerror = function () {
            self.clone();
          };

          xhr.onload = function () {
            self.read(xhr.response);
          };

          if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
            url = addTimestamp(url);
          }

          xhr.open('get', url);
          xhr.responseType = 'arraybuffer';
          xhr.withCredentials = element.crossOrigin === 'use-credentials';
          xhr.send();
        }
      }, {
        key: 'read',
        value: function read(arrayBuffer) {
          var self = this;
          var options = self.options;
          var orientation = getOrientation(arrayBuffer);
          var imageData = self.imageData;
          var rotate = 0;
          var scaleX = 1;
          var scaleY = 1;

          if (orientation > 1) {
            self.url = arrayBufferToDataURL(arrayBuffer);

            switch (orientation) {
              // flip horizontal
              case 2:
                scaleX = -1;
                break;

              // rotate left 180
              case 3:
                rotate = -180;
                break;

              // flip vertical
              case 4:
                scaleY = -1;
                break;

              // flip vertical + rotate right 90
              case 5:
                rotate = 90;
                scaleY = -1;
                break;

              // rotate right 90
              case 6:
                rotate = 90;
                break;

              // flip horizontal + rotate right 90
              case 7:
                rotate = 90;
                scaleX = -1;
                break;

              // rotate left 90
              case 8:
                rotate = -90;
                break;

              default:
            }
          }

          if (options.rotatable) {
            imageData.rotate = rotate;
          }

          if (options.scalable) {
            imageData.scaleX = scaleX;
            imageData.scaleY = scaleY;
          }

          self.clone();
        }
      }, {
        key: 'clone',
        value: function clone() {
          var self = this;
          var element = self.element;
          var url = self.url;
          var crossOrigin = void 0;
          var crossOriginUrl = void 0;

          if (self.options.checkCrossOrigin && isCrossOriginURL(url)) {
            crossOrigin = element.crossOrigin;

            if (crossOrigin) {
              crossOriginUrl = url;
            } else {
              crossOrigin = 'anonymous';

              // Bust cache when there is not a "crossOrigin" property
              crossOriginUrl = addTimestamp(url);
            }
          }

          self.crossOrigin = crossOrigin;
          self.crossOriginUrl = crossOriginUrl;

          var image = createElement('img');

          if (crossOrigin) {
            image.crossOrigin = crossOrigin;
          }

          image.src = crossOriginUrl || url;

          var start = proxy(self.start, self);
          var stop = proxy(self.stop, self);

          self.image = image;
          self.onStart = start;
          self.onStop = stop;

          if (self.isImg) {
            if (element.complete) {
              self.start();
            } else {
              addListener(element, EVENT_LOAD, start);
            }
          } else {
            addListener(image, EVENT_LOAD, start);
            addListener(image, EVENT_ERROR, stop);
            addClass(image, 'cropper-hide');
            element.parentNode.insertBefore(image, element.nextSibling);
          }
        }
      }, {
        key: 'start',
        value: function start(event) {
          var self = this;
          var image = self.isImg ? self.element : self.image;

          if (event) {
            removeListener(image, EVENT_LOAD, self.onStart);
            removeListener(image, EVENT_ERROR, self.onStop);
          }

          getImageSize(image, function (naturalWidth, naturalHeight) {
            extend(self.imageData, {
              naturalWidth: naturalWidth,
              naturalHeight: naturalHeight,
              aspectRatio: naturalWidth / naturalHeight
            });

            self.loaded = true;
            self.build();
          });
        }
      }, {
        key: 'stop',
        value: function stop() {
          var self = this;
          var image = self.image;

          removeListener(image, EVENT_LOAD, self.onStart);
          removeListener(image, EVENT_ERROR, self.onStop);

          removeChild(image);
          self.image = null;
        }
      }, {
        key: 'build',
        value: function build() {
          var self = this;
          var options = self.options;
          var element = self.element;
          var image = self.image;

          if (!self.loaded) {
            return;
          }

          // Unbuild first when replace
          if (self.ready) {
            self.unbuild();
          }

          // Create cropper elements
          var container = element.parentNode;
          var template = createElement('div');

          template.innerHTML = TEMPLATE;

          var cropper = getByClass(template, 'cropper-container')[0];
          var canvas = getByClass(cropper, 'cropper-canvas')[0];
          var dragBox = getByClass(cropper, 'cropper-drag-box')[0];
          var cropBox = getByClass(cropper, 'cropper-crop-box')[0];
          var face = getByClass(cropBox, 'cropper-face')[0];

          self.container = container;
          self.cropper = cropper;
          self.canvas = canvas;
          self.dragBox = dragBox;
          self.cropBox = cropBox;
          self.viewBox = getByClass(cropper, 'cropper-view-box')[0];
          self.face = face;

          appendChild(canvas, image);

          // Hide the original image
          addClass(element, CLASS_HIDDEN);

          // Inserts the cropper after to the current image
          container.insertBefore(cropper, element.nextSibling);

          // Show the image if is hidden
          if (!self.isImg) {
            removeClass(image, 'cropper-hide');
          }

          self.initPreview();
          self.bind();

          options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
          options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;

          self.cropped = options.autoCrop;

          if (options.autoCrop) {
            if (options.modal) {
              addClass(dragBox, 'cropper-modal');
            }
          } else {
            addClass(cropBox, CLASS_HIDDEN);
          }

          if (!options.guides) {
            addClass(getByClass(cropBox, 'cropper-dashed'), CLASS_HIDDEN);
          }

          if (!options.center) {
            addClass(getByClass(cropBox, 'cropper-center'), CLASS_HIDDEN);
          }

          if (options.background) {
            addClass(cropper, 'cropper-bg');
          }

          if (!options.highlight) {
            addClass(face, 'cropper-invisible');
          }

          if (options.cropBoxMovable) {
            addClass(face, 'cropper-move');
            setData(face, 'action', 'all');
          }

          if (!options.cropBoxResizable) {
            addClass(getByClass(cropBox, 'cropper-line'), CLASS_HIDDEN);
            addClass(getByClass(cropBox, 'cropper-point'), CLASS_HIDDEN);
          }

          self.setDragMode(options.dragMode);
          self.render();
          self.ready = true;
          self.setData(options.data);

          // Call the "ready" option asynchronously to keep "image.cropper" is defined
          self.completing = setTimeout(function () {
            if (isFunction(options.ready)) {
              addListener(element, EVENT_READY, options.ready, true);
            }

            dispatchEvent(element, EVENT_READY);
            dispatchEvent(element, EVENT_CROP, self.getData());

            self.complete = true;
          }, 0);
        }
      }, {
        key: 'unbuild',
        value: function unbuild() {
          var self = this;

          if (!self.ready) {
            return;
          }

          if (!self.complete) {
            clearTimeout(self.completing);
          }

          self.ready = false;
          self.complete = false;
          self.initialImageData = null;

          // Clear `initialCanvasData` is necessary when replace
          self.initialCanvasData = null;
          self.initialCropBoxData = null;
          self.containerData = null;
          self.canvasData = null;

          // Clear `cropBoxData` is necessary when replace
          self.cropBoxData = null;
          self.unbind();

          self.resetPreview();
          self.previews = null;

          self.viewBox = null;
          self.cropBox = null;
          self.dragBox = null;
          self.canvas = null;
          self.container = null;

          removeChild(self.cropper);
          self.cropper = null;
        }
      }], [{
        key: 'noConflict',
        value: function noConflict() {
          window.Cropper = AnotherCropper;
          return Cropper;
        }
      }, {
        key: 'setDefaults',
        value: function setDefaults(options) {
          extend(DEFAULTS, isPlainObject(options) && options);
        }
      }]);

      return Cropper;
    }();

    extend(Cropper.prototype, render);
    extend(Cropper.prototype, preview);
    extend(Cropper.prototype, events);
    extend(Cropper.prototype, handlers);
    extend(Cropper.prototype, change);
    extend(Cropper.prototype, methods);

    if (typeof window !== 'undefined') {
      AnotherCropper = window.Cropper;
      window.Cropper = Cropper;
    }

    return Cropper;
  });
});
System.registerDynamic("reactiveadmintemplate/scripts/modules/product/photo-editor/controller.js", ["cropperjs", "dropzone", "perfect-scrollbar"], true, function ($__require, exports, module) {
    'use strict';

    var global = this || self,
        GLOBAL = global;
    Object.defineProperty(exports, "__esModule", { value: true });
    var Cropper = $__require("cropperjs");
    var Dropzone = $__require("dropzone");
    var Ps = $__require("perfect-scrollbar");
    var Controller = function () {
        function Controller(view, cropping, url, name, type, image, cropper, originalUrl, data, canvasData, cropBoxData, dropzone, scrollBox) {
            if (cropping === void 0) {
                cropping = false;
            }
            if (url === void 0) {
                url = '';
            }
            if (name === void 0) {
                name = '';
            }
            if (type === void 0) {
                type = '';
            }
            if (image === void 0) {
                image = '';
            }
            if (cropper === void 0) {
                cropper = '';
            }
            if (originalUrl === void 0) {
                originalUrl = '';
            }
            if (data === void 0) {
                data = '';
            }
            if (canvasData === void 0) {
                canvasData = '';
            }
            if (cropBoxData === void 0) {
                cropBoxData = '';
            }
            if (dropzone === void 0) {
                dropzone = '';
            }
            if (scrollBox === void 0) {
                scrollBox = '';
            }
            this.view = view;
            this.cropping = cropping;
            this.url = url;
            this.name = name;
            this.type = type;
            this.image = image;
            this.cropper = cropper;
            this.originalUrl = originalUrl;
            this.data = data;
            this.canvasData = canvasData;
            this.cropBoxData = cropBoxData;
            this.dropzone = dropzone;
            this.scrollBox = scrollBox;
            view.bindButtonClick(this.click.bind(this));
            view.bindCropButtonClick(this.cropClick.bind(this));
            view.bindInputChange(this.change.bind(this));
            view.bindImageChange(this.imageChange.bind(this));
            view.setDrop(this.setDragDrop.bind(this));
            view.bindSaveImage(this.remove.bind(this));
            view.setScroll(this.setScroll.bind(this));
            view.bindUpdateScroll(this.updateScroll.bind(this));
            this.view.upload(true);
            this.view.edit(false);
            this.view.clear(this.cropping);
            this.view.restore(false);
            this.view.remove(false);
            this.view.crop(false);
        }
        /**
         * Trigger appropriate actions
         *
         * @param {!HTMLElement} target Clicked button
         */
        Controller.prototype.click = function (target) {
            var action = $(target).data('action') || $(target).parent().data('action');
            switch (action) {
                case 'restore':
                    this.restore();
                    break;
                case 'remove':
                    this.remove();
                    break;
                case 'clear':
                    this.clear();
                    break;
                case 'crop':
                    this.crop();
                    break;
            }
        };
        /**
         * Create Drop zone and handle reading
         * @param {HTMLElement} el Drop zone Element
         */
        Controller.prototype.setDragDrop = function (el) {
            if (!el) return;
            var me = this;
            this.dropzone = new Dropzone(el, {
                url: '/', autoQueue: false,
                autoProcessQueue: false,
                init: function () {
                    this.on("addedfile", function (file) {
                        if (me.cropper) {
                            return;
                        }
                        me.read(file);
                        me.view.removePreview();
                    });
                }
            });
        };
        /**
         * Trigger cropper actions
         *
         * @param {!HTMLElement} target Cropper buttons
         */
        Controller.prototype.cropClick = function (target) {
            var cropper = this.cropper;
            if (!cropper) {
                return;
            }
            var action = $(target).data('action') || $(target).parent().data('action');
            switch (action) {
                case 'move':
                case 'crop':
                    cropper.setDragMode(action);
                    break;
                case 'zoom-in':
                    cropper.zoom(0.1);
                    break;
                case 'zoom-out':
                    cropper.zoom(-0.1);
                    break;
                case 'rotate-left':
                    cropper.rotate(-90);
                    break;
                case 'rotate-right':
                    cropper.rotate(90);
                    break;
                case 'flip-horizontal':
                    cropper.scaleX(-this.cropper.getData().scaleX || -1);
                    break;
                case 'flip-vertical':
                    cropper.scaleY(-this.cropper.getData().scaleY || -1);
                    break;
            }
        };
        /**
         * Trigger read actions
         *
         * @param {!HTMLInputElement} target Clicked button
         */
        Controller.prototype.change = function (target) {
            var files = target.files;
            this.read(files && files[0], function () {
                target.value = '';
            });
        };
        /**
         * Read the file from the input
         * @param file Loading file
         * @param callback
         */
        Controller.prototype.read = function (file, callback) {
            var _this = this;
            if (callback === void 0) {
                callback = function () {};
            }
            if (file) {
                if (/^image\/\w+$/.test(file.type)) {
                    var reader_1 = new FileReader();
                    reader_1.onload = function () {
                        _this.view.upload(false);
                        _this.view.remove(true);
                        _this.type = file.type;
                        _this.name = file.name;
                        _this.url = reader_1.result;
                        _this.view.edit(true, _this.url, _this.name, _this.load.bind(_this));
                        callback();
                    };
                    reader_1.readAsDataURL(file);
                } else {
                    window.alert('Please choose an image file.');
                    callback();
                }
            } else {
                callback();
            }
        };
        Controller.prototype.imageChange = function (e) {
            if (this.cropper) {
                this.clear();
                this.remove();
            }
            this.view.upload(false);
            this.view.remove(true);
            this.url = $(e.target).attr('src');
            this.name = this.url.replace(/^.*[\\\/]/, '');
            this.view.edit(true, this.url, this.name, this.load.bind(this));
        };
        /**
         *
         * @param e Event object of the loaded image
         */
        Controller.prototype.load = function (e) {
            if (!this.image) {
                this.image = e.target;
                this.start();
            }
        };
        /**
         * Start the cropper
         */
        Controller.prototype.start = function () {
            var _this = this;
            this.view.restore(false);
            if (this.cropper) {
                return;
            }
            this.cropper = new Cropper(this.image, {
                autoCrop: false,
                dragMode: 'move',
                background: false,
                ready: function () {
                    if (_this.data) {
                        this.cropper.crop().setData(_this.data).setCanvasData(_this.canvasData).setCropBoxData(_this.cropBoxData);
                        _this.data = null;
                        _this.canvasData = null;
                        _this.cropBoxData = null;
                    }
                },
                crop: function (data) {
                    if (data.detail.width > 0 && data.detail.height > 0) {
                        _this.cropping = true;
                        _this.view.crop(true);
                        _this.view.clear(true);
                        _this.view.remove(false);
                        _this.view.setCropSizes(this.cropper.getCropBoxData());
                    }
                }
            });
        };
        /**
         * Stop the cropper
         */
        Controller.prototype.stop = function () {
            if (this.cropper) {
                this.view.restore(true);
                this.view.crop(false, { url: this.url, name: this.name });
                this.cropper.destroy();
                this.cropper = '';
                this.view.setCropSizes('');
            }
        };
        /**
         * Clear the cropper
         */
        Controller.prototype.clear = function () {
            this.cropping = false;
            this.crop();
            this.cropper.clear();
            this.view.setCropSizes('');
        };
        /**
         * Calcuates the cropped image details and call stop()
         */
        Controller.prototype.crop = function () {
            this.view.crop(false);
            this.view.clear(false);
            this.view.upload(false);
            this.view.remove(true);
            this.view.setCropSizes('');
            if (this.cropping) {
                var cropper = this.cropper;
                var type = this.type;
                this.originalUrl = this.url;
                this.data = cropper.getData();
                this.canvasData = cropper.getCanvasData();
                this.cropBoxData = cropper.getCropBoxData();
                this.url = cropper.getCroppedCanvas(type === 'image/png' ? null : {
                    fillColor: '#fff'
                }).toDataURL(type);
                this.view.edit(true, this.url, this.name);
                this.cropping = false;
                this.stop();
            }
        };
        /**
         * Restore the cropped image
         */
        Controller.prototype.restore = function () {
            if (!this.cropper) {
                this.image = null;
                this.url = this.originalUrl;
                this.originalUrl = '';
                this.view.edit(true, this.url, this.name);
                this.view.setCropSizes('');
            }
        };
        /**
         * Restore the image
         */
        Controller.prototype.remove = function () {
            // Disallow to delete image when cropping
            if (this.cropping) {
                return;
            }
            this.view.edit(false);
            this.view.upload(true);
            this.view.remove(false);
            this.view.restore(false);
            this.view.crop(false);
            this.data = null;
            this.image = null;
            this.type = '';
            this.name = '';
            this.url = '';
            this.originalUrl = '';
            if (this.cropper) {
                this.cropper.destroy();
                this.cropper = '';
            }
            this.view.setCropSizes('');
            this.updateScroll(this.scrollBox);
        };
        Controller.prototype.setScroll = function (el) {
            if (!el) return;
            this.scrollBox = el;
            Ps.initialize(el, {
                theme: 'visible-theme',
                suppressScrollY: true,
                useBothWheelAxes: true,
                wheelPropagation: true
            });
        };
        Controller.prototype.updateScroll = function (el, scroll) {
            if (scroll === void 0) {
                scroll = 0;
            }
            if (!el) return;
            el.scrollLeft = scroll;
            Ps.update(el);
        };
        return Controller;
    }();
    exports.default = Controller;
});
System.registerDynamic('reactiveadmintemplate/scripts/modules/product/photo-editor/view.js', [], true, function ($__require, exports, module) {
    'use strict';

    var global = this || self,
        GLOBAL = global;
    Object.defineProperty(exports, "__esModule", { value: true });
    /*!
     * @version: 1.1.2
     * @name: view
     *
     * @author: https://themeforest.net/user/flexlayers
     */
    var View = function () {
        function View() {}
        /**
         * @param {Function} handler Function called on synthetic event.
         */
        View.prototype.bindButtonClick = function (handler) {
            View.$buttons.on('click', 'button', function (e) {
                handler(e.target);
            });
            return this;
        };
        /**
         * @param {Function} handler Function called on synthetic event.
         */
        View.prototype.bindCropButtonClick = function (handler) {
            View.$toolbar.on('click', 'button', function (e) {
                handler(e.target);
            });
            return this;
        };
        /**
         * @param {Function} handler Function called on synthetic event.
         */
        View.prototype.bindInputChange = function (handler) {
            View.$imageInput.on('change', function (e) {
                handler(e.target);
            });
            return this;
        };
        /**
         * @param {Function} handler Function called on synthetic event.
         */
        View.prototype.bindImageChange = function (handler) {
            View.$productImages.on('click', 'img', function (e) {
                handler(e);
            });
            return this;
        };
        /**
         * @param {Function} handler Function called on synthetic event.
         */
        View.prototype.bindSaveImage = function (handler) {
            View.$save.on('click', function (e) {
                View.$img.clone().attr('height', 200).prependTo(View.$productImages.find('#this-prod-images'));
                handler(e);
            });
            return this;
        };
        View.prototype.removePreview = function () {
            View.$upload.find('.dz-preview').remove();
            return this;
        };
        /**
         * @param {Function} handler Init Drag & Drop.
         */
        View.prototype.setDrop = function (handler) {
            handler(View.$upload.get(0));
            return this;
        };
        /**
         * @param {boolean} mode Show or hide the element.
         */
        View.prototype.upload = function (mode) {
            View.$uploadTrigger.toggle(mode);
            return this;
        };
        /**
         *
         * @param mode Show or hide the element.
         * @param src uploaded image src
         * @param name uploaded image name
         * @param handler Colled when image is loaded
         * @returns {View}
         */
        View.prototype.edit = function (mode, src, name, handler) {
            if (src === void 0) {
                src = '';
            }
            if (name === void 0) {
                name = '';
            }
            if (handler === void 0) {
                handler = function (e) {};
            }
            View.$editable.toggle(mode);
            View.$img.attr({
                src: src,
                alt: name
            }).on('load', function (e) {
                handler(e);
            });
            return this;
        };
        /**
         * @param mode Show or hide the element.
         * @returns {View}
         */
        View.prototype.clear = function (mode) {
            View.$clear.toggle(mode);
            return this;
        };
        /**
         * @param mode Show or hide the element.
         * @returns {View}
         */
        View.prototype.restore = function (mode) {
            View.$restore.toggle(mode);
            return this;
        };
        /**
         * @param mode Show or hide the element.
         * @returns {View}
         */
        View.prototype.remove = function (mode) {
            View.$remove.toggle(mode);
            return this;
        };
        /**
         *
         * @param mode Show or hide the element.
         * @param data New image details
         * @returns {View}
         */
        View.prototype.crop = function (mode, data) {
            if (data === void 0) {
                data = null;
            }
            View.$crop.toggle(mode);
            if (data) {
                var url = data.url.replace(/^data:image\/[^;]/, 'data:application/octet-stream');
                View.$download.attr({
                    href: url,
                    download: data.name
                }).show();
            } else {
                View.$download.hide();
            }
            return this;
        };
        View.prototype.setCropSizes = function (data) {
            if (data) {
                $('.croping-size').html(data.width + ' x ' + data.height);
            } else {
                $('.croping-size').html('');
            }
            return this;
        };
        View.prototype.setScroll = function (handler) {
            handler(View.$productImages.get(0));
        };
        View.prototype.bindUpdateScroll = function (handler) {
            $('.product-images a[data-toggle="tab"]').on('shown.bs.tab', function () {
                handler(View.$productImages.get(0));
            });
        };
        View.$uploadTrigger = $('.photo-editor-upload-trigger');
        View.$upload = $('.photo-editor-upload');
        View.$imageInput = $('.photo-editor-upload-trigger input');
        View.$editable = $('.photo-editor-editable');
        View.$buttons = $('.photo-editor-buttons');
        View.$img = $('.photo-editor-editable img');
        View.$toolbar = $('.photo-editor-toolbar');
        View.$productImages = $('.product-images .tab-content');
        View.$restore = View.$buttons.find('[data-action="restore"]');
        View.$remove = View.$buttons.find('[data-action="remove"]');
        View.$clear = View.$buttons.find('[data-action="clear"]');
        View.$crop = View.$buttons.find('[data-action="crop"]');
        View.$download = View.$buttons.find('[data-action="download"]');
        View.$save = View.$buttons.find('.product-save-image');
        return View;
    }();
    exports.default = View;
});
System.registerDynamic("reactiveadmintemplate/scripts/modules/product/photo-editor/init.js", ["./controller", "./view"], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: true });
  /*!
   * @version: 1.1.2
   * @name: photo-editor
   *
   * @author: https://themeforest.net/user/flexlayers
   */
  var controller_1 = $__require("./controller");
  var view_1 = $__require("./view");
  $(function () {
    new controller_1.default(new view_1.default());
    $('#this-prod-images img').first().trigger('click');
  });
});
/*!
 * jQuery UI Sortable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Sortable
//>>group: Interactions
//>>description: Enables items in a list to be sorted using the mouse.
//>>docs: http://api.jqueryui.com/sortable/
//>>demos: http://jqueryui.com/sortable/
//>>css.structure: ../../themes/base/sortable.css

(function (factory) {
	if ("function" === "function" && true) {

		// AMD. Register as an anonymous module.
		System.registerDynamic("github:components/jqueryui@1.12.1/ui/widgets/sortable.js", ["jquery", "./mouse", "../data", "../ie", "../scroll-parent", "../version", "../widget"], false, function ($__require, $__exports, $__module) {
			if (typeof factory === "function") {
				return factory.call(this, $__require("jquery"), $__require("./mouse"), $__require("../data"), $__require("../ie"), $__require("../scroll-parent"), $__require("../version"), $__require("../widget"));
			} else {
				return factory;
			}
		});
	} else {

		// Browser globals
		factory(jQuery);
	}
})(function ($) {

	return $.widget("ui.sortable", $.ui.mouse, {
		version: "1.12.1",
		widgetEventPrefix: "sort",
		ready: false,
		options: {
			appendTo: "parent",
			axis: false,
			connectWith: false,
			containment: false,
			cursor: "auto",
			cursorAt: false,
			dropOnEmpty: true,
			forcePlaceholderSize: false,
			forceHelperSize: false,
			grid: false,
			handle: false,
			helper: "original",
			items: "> *",
			opacity: false,
			placeholder: false,
			revert: false,
			scroll: true,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			scope: "default",
			tolerance: "intersect",
			zIndex: 1000,

			// Callbacks
			activate: null,
			beforeStop: null,
			change: null,
			deactivate: null,
			out: null,
			over: null,
			receive: null,
			remove: null,
			sort: null,
			start: null,
			stop: null,
			update: null
		},

		_isOverAxis: function (x, reference, size) {
			return x >= reference && x < reference + size;
		},

		_isFloating: function (item) {
			return (/left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"))
			);
		},

		_create: function () {
			this.containerCache = {};
			this._addClass("ui-sortable");

			//Get the items
			this.refresh();

			//Let's determine the parent's offset
			this.offset = this.element.offset();

			//Initialize mouse events for interaction
			this._mouseInit();

			this._setHandleClassName();

			//We're ready to go
			this.ready = true;
		},

		_setOption: function (key, value) {
			this._super(key, value);

			if (key === "handle") {
				this._setHandleClassName();
			}
		},

		_setHandleClassName: function () {
			var that = this;
			this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle");
			$.each(this.items, function () {
				that._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle");
			});
		},

		_destroy: function () {
			this._mouseDestroy();

			for (var i = this.items.length - 1; i >= 0; i--) {
				this.items[i].item.removeData(this.widgetName + "-item");
			}

			return this;
		},

		_mouseCapture: function (event, overrideHandle) {
			var currentItem = null,
			    validHandle = false,
			    that = this;

			if (this.reverting) {
				return false;
			}

			if (this.options.disabled || this.options.type === "static") {
				return false;
			}

			//We have to refresh the items data once first
			this._refreshItems(event);

			//Find out if the clicked node (or one of its parents) is a actual item in this.items
			$(event.target).parents().each(function () {
				if ($.data(this, that.widgetName + "-item") === that) {
					currentItem = $(this);
					return false;
				}
			});
			if ($.data(event.target, that.widgetName + "-item") === that) {
				currentItem = $(event.target);
			}

			if (!currentItem) {
				return false;
			}
			if (this.options.handle && !overrideHandle) {
				$(this.options.handle, currentItem).find("*").addBack().each(function () {
					if (this === event.target) {
						validHandle = true;
					}
				});
				if (!validHandle) {
					return false;
				}
			}

			this.currentItem = currentItem;
			this._removeCurrentsFromItems();
			return true;
		},

		_mouseStart: function (event, overrideHandle, noActivation) {

			var i,
			    body,
			    o = this.options;

			this.currentContainer = this;

			//We only need to call refreshPositions, because the refreshItems call has been moved to
			// mouseCapture
			this.refreshPositions();

			//Create and append the visible helper
			this.helper = this._createHelper(event);

			//Cache the helper size
			this._cacheHelperProportions();

			/*
    * - Position generation -
    * This block generates everything position related - it's the core of draggables.
    */

			//Cache the margins of the original element
			this._cacheMargins();

			//Get the next scrolling parent
			this.scrollParent = this.helper.scrollParent();

			//The element's absolute position on the page minus margins
			this.offset = this.currentItem.offset();
			this.offset = {
				top: this.offset.top - this.margins.top,
				left: this.offset.left - this.margins.left
			};

			$.extend(this.offset, {
				click: { //Where the click happened, relative to the element
					left: event.pageX - this.offset.left,
					top: event.pageY - this.offset.top
				},
				parent: this._getParentOffset(),

				// This is a relative to absolute position minus the actual position calculation -
				// only used for relative positioned helper
				relative: this._getRelativeOffset()
			});

			// Only after we got the offset, we can change the helper's position to absolute
			// TODO: Still need to figure out a way to make relative sorting possible
			this.helper.css("position", "absolute");
			this.cssPosition = this.helper.css("position");

			//Generate the original position
			this.originalPosition = this._generatePosition(event);
			this.originalPageX = event.pageX;
			this.originalPageY = event.pageY;

			//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
			o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);

			//Cache the former DOM position
			this.domPosition = {
				prev: this.currentItem.prev()[0],
				parent: this.currentItem.parent()[0]
			};

			// If the helper is not the original, hide the original so it's not playing any role during
			// the drag, won't cause anything bad this way
			if (this.helper[0] !== this.currentItem[0]) {
				this.currentItem.hide();
			}

			//Create the placeholder
			this._createPlaceholder();

			//Set a containment if given in the options
			if (o.containment) {
				this._setContainment();
			}

			if (o.cursor && o.cursor !== "auto") {
				// cursor option
				body = this.document.find("body");

				// Support: IE
				this.storedCursor = body.css("cursor");
				body.css("cursor", o.cursor);

				this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
			}

			if (o.opacity) {
				// opacity option
				if (this.helper.css("opacity")) {
					this._storedOpacity = this.helper.css("opacity");
				}
				this.helper.css("opacity", o.opacity);
			}

			if (o.zIndex) {
				// zIndex option
				if (this.helper.css("zIndex")) {
					this._storedZIndex = this.helper.css("zIndex");
				}
				this.helper.css("zIndex", o.zIndex);
			}

			//Prepare scrolling
			if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
				this.overflowOffset = this.scrollParent.offset();
			}

			//Call callbacks
			this._trigger("start", event, this._uiHash());

			//Recache the helper size
			if (!this._preserveHelperProportions) {
				this._cacheHelperProportions();
			}

			//Post "activate" events to possible containers
			if (!noActivation) {
				for (i = this.containers.length - 1; i >= 0; i--) {
					this.containers[i]._trigger("activate", event, this._uiHash(this));
				}
			}

			//Prepare possible droppables
			if ($.ui.ddmanager) {
				$.ui.ddmanager.current = this;
			}

			if ($.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}

			this.dragging = true;

			this._addClass(this.helper, "ui-sortable-helper");

			// Execute the drag once - this causes the helper not to be visiblebefore getting its
			// correct position
			this._mouseDrag(event);
			return true;
		},

		_mouseDrag: function (event) {
			var i,
			    item,
			    itemElement,
			    intersection,
			    o = this.options,
			    scrolled = false;

			//Compute the helpers position
			this.position = this._generatePosition(event);
			this.positionAbs = this._convertPositionTo("absolute");

			if (!this.lastPositionAbs) {
				this.lastPositionAbs = this.positionAbs;
			}

			//Do scrolling
			if (this.options.scroll) {
				if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {

					if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
					} else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
					}

					if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
					} else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
					}
				} else {

					if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
						scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
					} else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
						scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
					}

					if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
						scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
					} else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
						scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
					}
				}

				if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
					$.ui.ddmanager.prepareOffsets(this, event);
				}
			}

			//Regenerate the absolute position used for position checks
			this.positionAbs = this._convertPositionTo("absolute");

			//Set the helper position
			if (!this.options.axis || this.options.axis !== "y") {
				this.helper[0].style.left = this.position.left + "px";
			}
			if (!this.options.axis || this.options.axis !== "x") {
				this.helper[0].style.top = this.position.top + "px";
			}

			//Rearrange
			for (i = this.items.length - 1; i >= 0; i--) {

				//Cache variables and intersection, continue if no intersection
				item = this.items[i];
				itemElement = item.item[0];
				intersection = this._intersectsWithPointer(item);
				if (!intersection) {
					continue;
				}

				// Only put the placeholder inside the current Container, skip all
				// items from other containers. This works because when moving
				// an item from one container to another the
				// currentContainer is switched before the placeholder is moved.
				//
				// Without this, moving items in "sub-sortables" can cause
				// the placeholder to jitter between the outer and inner container.
				if (item.instance !== this.currentContainer) {
					continue;
				}

				// Cannot intersect with itself
				// no useless actions that have been done before
				// no action if the item moved is the parent of the item checked
				if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {

					this.direction = intersection === 1 ? "down" : "up";

					if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
						this._rearrange(event, item);
					} else {
						break;
					}

					this._trigger("change", event, this._uiHash());
					break;
				}
			}

			//Post events to containers
			this._contactContainers(event);

			//Interconnect with droppables
			if ($.ui.ddmanager) {
				$.ui.ddmanager.drag(this, event);
			}

			//Call callbacks
			this._trigger("sort", event, this._uiHash());

			this.lastPositionAbs = this.positionAbs;
			return false;
		},

		_mouseStop: function (event, noPropagation) {

			if (!event) {
				return;
			}

			//If we are using droppables, inform the manager about the drop
			if ($.ui.ddmanager && !this.options.dropBehaviour) {
				$.ui.ddmanager.drop(this, event);
			}

			if (this.options.revert) {
				var that = this,
				    cur = this.placeholder.offset(),
				    axis = this.options.axis,
				    animation = {};

				if (!axis || axis === "x") {
					animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
				}
				if (!axis || axis === "y") {
					animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
				}
				this.reverting = true;
				$(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
					that._clear(event);
				});
			} else {
				this._clear(event, noPropagation);
			}

			return false;
		},

		cancel: function () {

			if (this.dragging) {

				this._mouseUp(new $.Event("mouseup", { target: null }));

				if (this.options.helper === "original") {
					this.currentItem.css(this._storedCSS);
					this._removeClass(this.currentItem, "ui-sortable-helper");
				} else {
					this.currentItem.show();
				}

				//Post deactivating events to containers
				for (var i = this.containers.length - 1; i >= 0; i--) {
					this.containers[i]._trigger("deactivate", null, this._uiHash(this));
					if (this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", null, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}
			}

			if (this.placeholder) {

				//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
				// it unbinds ALL events from the original node!
				if (this.placeholder[0].parentNode) {
					this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
				}
				if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
					this.helper.remove();
				}

				$.extend(this, {
					helper: null,
					dragging: false,
					reverting: false,
					_noFinalSort: null
				});

				if (this.domPosition.prev) {
					$(this.domPosition.prev).after(this.currentItem);
				} else {
					$(this.domPosition.parent).prepend(this.currentItem);
				}
			}

			return this;
		},

		serialize: function (o) {

			var items = this._getItemsAsjQuery(o && o.connected),
			    str = [];
			o = o || {};

			$(items).each(function () {
				var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
				if (res) {
					str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
				}
			});

			if (!str.length && o.key) {
				str.push(o.key + "=");
			}

			return str.join("&");
		},

		toArray: function (o) {

			var items = this._getItemsAsjQuery(o && o.connected),
			    ret = [];

			o = o || {};

			items.each(function () {
				ret.push($(o.item || this).attr(o.attribute || "id") || "");
			});
			return ret;
		},

		/* Be careful with the following core functions */
		_intersectsWith: function (item) {

			var x1 = this.positionAbs.left,
			    x2 = x1 + this.helperProportions.width,
			    y1 = this.positionAbs.top,
			    y2 = y1 + this.helperProportions.height,
			    l = item.left,
			    r = l + item.width,
			    t = item.top,
			    b = t + item.height,
			    dyClick = this.offset.click.top,
			    dxClick = this.offset.click.left,
			    isOverElementHeight = this.options.axis === "x" || y1 + dyClick > t && y1 + dyClick < b,
			    isOverElementWidth = this.options.axis === "y" || x1 + dxClick > l && x1 + dxClick < r,
			    isOverElement = isOverElementHeight && isOverElementWidth;

			if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"]) {
				return isOverElement;
			} else {

				return l < x1 + this.helperProportions.width / 2 && // Right Half
				x2 - this.helperProportions.width / 2 < r && // Left Half
				t < y1 + this.helperProportions.height / 2 && // Bottom Half
				y2 - this.helperProportions.height / 2 < b; // Top Half
			}
		},

		_intersectsWithPointer: function (item) {
			var verticalDirection,
			    horizontalDirection,
			    isOverElementHeight = this.options.axis === "x" || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			    isOverElementWidth = this.options.axis === "y" || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			    isOverElement = isOverElementHeight && isOverElementWidth;

			if (!isOverElement) {
				return false;
			}

			verticalDirection = this._getDragVerticalDirection();
			horizontalDirection = this._getDragHorizontalDirection();

			return this.floating ? horizontalDirection === "right" || verticalDirection === "down" ? 2 : 1 : verticalDirection && (verticalDirection === "down" ? 2 : 1);
		},

		_intersectsWithSides: function (item) {

			var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height),
			    isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width),
			    verticalDirection = this._getDragVerticalDirection(),
			    horizontalDirection = this._getDragHorizontalDirection();

			if (this.floating && horizontalDirection) {
				return horizontalDirection === "right" && isOverRightHalf || horizontalDirection === "left" && !isOverRightHalf;
			} else {
				return verticalDirection && (verticalDirection === "down" && isOverBottomHalf || verticalDirection === "up" && !isOverBottomHalf);
			}
		},

		_getDragVerticalDirection: function () {
			var delta = this.positionAbs.top - this.lastPositionAbs.top;
			return delta !== 0 && (delta > 0 ? "down" : "up");
		},

		_getDragHorizontalDirection: function () {
			var delta = this.positionAbs.left - this.lastPositionAbs.left;
			return delta !== 0 && (delta > 0 ? "right" : "left");
		},

		refresh: function (event) {
			this._refreshItems(event);
			this._setHandleClassName();
			this.refreshPositions();
			return this;
		},

		_connectWith: function () {
			var options = this.options;
			return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
		},

		_getItemsAsjQuery: function (connected) {

			var i,
			    j,
			    cur,
			    inst,
			    items = [],
			    queries = [],
			    connectWith = this._connectWith();

			if (connectWith && connected) {
				for (i = connectWith.length - 1; i >= 0; i--) {
					cur = $(connectWith[i], this.document[0]);
					for (j = cur.length - 1; j >= 0; j--) {
						inst = $.data(cur[j], this.widgetFullName);
						if (inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
						}
					}
				}
			}

			queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

			function addItems() {
				items.push(this);
			}
			for (i = queries.length - 1; i >= 0; i--) {
				queries[i][0].each(addItems);
			}

			return $(items);
		},

		_removeCurrentsFromItems: function () {

			var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

			this.items = $.grep(this.items, function (item) {
				for (var j = 0; j < list.length; j++) {
					if (list[j] === item.item[0]) {
						return false;
					}
				}
				return true;
			});
		},

		_refreshItems: function (event) {

			this.items = [];
			this.containers = [this];

			var i,
			    j,
			    cur,
			    inst,
			    targetData,
			    _queries,
			    item,
			    queriesLength,
			    items = this.items,
			    queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
			    connectWith = this._connectWith();

			//Shouldn't be run the first time through due to massive slow-down
			if (connectWith && this.ready) {
				for (i = connectWith.length - 1; i >= 0; i--) {
					cur = $(connectWith[i], this.document[0]);
					for (j = cur.length - 1; j >= 0; j--) {
						inst = $.data(cur[j], this.widgetFullName);
						if (inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
							this.containers.push(inst);
						}
					}
				}
			}

			for (i = queries.length - 1; i >= 0; i--) {
				targetData = queries[i][1];
				_queries = queries[i][0];

				for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
					item = $(_queries[j]);

					// Data for target checking (mouse manager)
					item.data(this.widgetName + "-item", targetData);

					items.push({
						item: item,
						instance: targetData,
						width: 0, height: 0,
						left: 0, top: 0
					});
				}
			}
		},

		refreshPositions: function (fast) {

			// Determine whether items are being displayed horizontally
			this.floating = this.items.length ? this.options.axis === "x" || this._isFloating(this.items[0].item) : false;

			//This has to be redone because due to the item being moved out/into the offsetParent,
			// the offsetParent's position will change
			if (this.offsetParent && this.helper) {
				this.offset.parent = this._getParentOffset();
			}

			var i, item, t, p;

			for (i = this.items.length - 1; i >= 0; i--) {
				item = this.items[i];

				//We ignore calculating positions of all connected containers when we're not over them
				if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
					continue;
				}

				t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

				if (!fast) {
					item.width = t.outerWidth();
					item.height = t.outerHeight();
				}

				p = t.offset();
				item.left = p.left;
				item.top = p.top;
			}

			if (this.options.custom && this.options.custom.refreshContainers) {
				this.options.custom.refreshContainers.call(this);
			} else {
				for (i = this.containers.length - 1; i >= 0; i--) {
					p = this.containers[i].element.offset();
					this.containers[i].containerCache.left = p.left;
					this.containers[i].containerCache.top = p.top;
					this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
					this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
				}
			}

			return this;
		},

		_createPlaceholder: function (that) {
			that = that || this;
			var className,
			    o = that.options;

			if (!o.placeholder || o.placeholder.constructor === String) {
				className = o.placeholder;
				o.placeholder = {
					element: function () {

						var nodeName = that.currentItem[0].nodeName.toLowerCase(),
						    element = $("<" + nodeName + ">", that.document[0]);

						that._addClass(element, "ui-sortable-placeholder", className || that.currentItem[0].className)._removeClass(element, "ui-sortable-helper");

						if (nodeName === "tbody") {
							that._createTrPlaceholder(that.currentItem.find("tr").eq(0), $("<tr>", that.document[0]).appendTo(element));
						} else if (nodeName === "tr") {
							that._createTrPlaceholder(that.currentItem, element);
						} else if (nodeName === "img") {
							element.attr("src", that.currentItem.attr("src"));
						}

						if (!className) {
							element.css("visibility", "hidden");
						}

						return element;
					},
					update: function (container, p) {

						// 1. If a className is set as 'placeholder option, we don't force sizes -
						// the class is responsible for that
						// 2. The option 'forcePlaceholderSize can be enabled to force it even if a
						// class name is specified
						if (className && !o.forcePlaceholderSize) {
							return;
						}

						//If the element doesn't have a actual height by itself (without styles coming
						// from a stylesheet), it receives the inline height from the dragged item
						if (!p.height()) {
							p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
						}
						if (!p.width()) {
							p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
						}
					}
				};
			}

			//Create the placeholder
			that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

			//Append it after the actual current item
			that.currentItem.after(that.placeholder);

			//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
			o.placeholder.update(that, that.placeholder);
		},

		_createTrPlaceholder: function (sourceTr, targetTr) {
			var that = this;

			sourceTr.children().each(function () {
				$("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(targetTr);
			});
		},

		_contactContainers: function (event) {
			var i,
			    j,
			    dist,
			    itemWithLeastDistance,
			    posProperty,
			    sizeProperty,
			    cur,
			    nearBottom,
			    floating,
			    axis,
			    innermostContainer = null,
			    innermostIndex = null;

			// Get innermost container that intersects with item
			for (i = this.containers.length - 1; i >= 0; i--) {

				// Never consider a container that's located within the item itself
				if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
					continue;
				}

				if (this._intersectsWith(this.containers[i].containerCache)) {

					// If we've already found a container and it's more "inner" than this, then continue
					if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
						continue;
					}

					innermostContainer = this.containers[i];
					innermostIndex = i;
				} else {

					// container doesn't intersect. trigger "out" event if necessary
					if (this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", event, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}
			}

			// If no intersecting containers found, return
			if (!innermostContainer) {
				return;
			}

			// Move the item into the container if it's not there already
			if (this.containers.length === 1) {
				if (!this.containers[innermostIndex].containerCache.over) {
					this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
					this.containers[innermostIndex].containerCache.over = 1;
				}
			} else {

				// When entering a new container, we will find the item with the least distance and
				// append our item near it
				dist = 10000;
				itemWithLeastDistance = null;
				floating = innermostContainer.floating || this._isFloating(this.currentItem);
				posProperty = floating ? "left" : "top";
				sizeProperty = floating ? "width" : "height";
				axis = floating ? "pageX" : "pageY";

				for (j = this.items.length - 1; j >= 0; j--) {
					if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
						continue;
					}
					if (this.items[j].item[0] === this.currentItem[0]) {
						continue;
					}

					cur = this.items[j].item.offset()[posProperty];
					nearBottom = false;
					if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
						nearBottom = true;
					}

					if (Math.abs(event[axis] - cur) < dist) {
						dist = Math.abs(event[axis] - cur);
						itemWithLeastDistance = this.items[j];
						this.direction = nearBottom ? "up" : "down";
					}
				}

				//Check if dropOnEmpty is enabled
				if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
					return;
				}

				if (this.currentContainer === this.containers[innermostIndex]) {
					if (!this.currentContainer.containerCache.over) {
						this.containers[innermostIndex]._trigger("over", event, this._uiHash());
						this.currentContainer.containerCache.over = 1;
					}
					return;
				}

				itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
				this._trigger("change", event, this._uiHash());
				this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
				this.currentContainer = this.containers[innermostIndex];

				//Update the placeholder
				this.options.placeholder.update(this.currentContainer, this.placeholder);

				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}
		},

		_createHelper: function (event) {

			var o = this.options,
			    helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : o.helper === "clone" ? this.currentItem.clone() : this.currentItem;

			//Add the helper to the DOM if that didn't happen already
			if (!helper.parents("body").length) {
				$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
			}

			if (helper[0] === this.currentItem[0]) {
				this._storedCSS = {
					width: this.currentItem[0].style.width,
					height: this.currentItem[0].style.height,
					position: this.currentItem.css("position"),
					top: this.currentItem.css("top"),
					left: this.currentItem.css("left")
				};
			}

			if (!helper[0].style.width || o.forceHelperSize) {
				helper.width(this.currentItem.width());
			}
			if (!helper[0].style.height || o.forceHelperSize) {
				helper.height(this.currentItem.height());
			}

			return helper;
		},

		_adjustOffsetFromHelper: function (obj) {
			if (typeof obj === "string") {
				obj = obj.split(" ");
			}
			if ($.isArray(obj)) {
				obj = { left: +obj[0], top: +obj[1] || 0 };
			}
			if ("left" in obj) {
				this.offset.click.left = obj.left + this.margins.left;
			}
			if ("right" in obj) {
				this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
			}
			if ("top" in obj) {
				this.offset.click.top = obj.top + this.margins.top;
			}
			if ("bottom" in obj) {
				this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
			}
		},

		_getParentOffset: function () {

			//Get the offsetParent and cache its position
			this.offsetParent = this.helper.offsetParent();
			var po = this.offsetParent.offset();

			// This is a special case where we need to modify a offset calculated on start, since the
			// following happened:
			// 1. The position of the helper is absolute, so it's position is calculated based on the
			// next positioned parent
			// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
			// the document, which means that the scroll is included in the initial calculation of the
			// offset of the parent, and never recalculated upon drag
			if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
				po.left += this.scrollParent.scrollLeft();
				po.top += this.scrollParent.scrollTop();
			}

			// This needs to be actually done for all browsers, since pageX/pageY includes this
			// information with an ugly IE fix
			if (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
				po = { top: 0, left: 0 };
			}

			return {
				top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
				left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
			};
		},

		_getRelativeOffset: function () {

			if (this.cssPosition === "relative") {
				var p = this.currentItem.position();
				return {
					top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
					left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
				};
			} else {
				return { top: 0, left: 0 };
			}
		},

		_cacheMargins: function () {
			this.margins = {
				left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
				top: parseInt(this.currentItem.css("marginTop"), 10) || 0
			};
		},

		_cacheHelperProportions: function () {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			};
		},

		_setContainment: function () {

			var ce,
			    co,
			    over,
			    o = this.options;
			if (o.containment === "parent") {
				o.containment = this.helper[0].parentNode;
			}
			if (o.containment === "document" || o.containment === "window") {
				this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, (o.containment === "document" ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
			}

			if (!/^(document|window|parent)$/.test(o.containment)) {
				ce = $(o.containment)[0];
				co = $(o.containment).offset();
				over = $(ce).css("overflow") !== "hidden";

				this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top];
			}
		},

		_convertPositionTo: function (d, pos) {

			if (!pos) {
				pos = this.position;
			}
			var mod = d === "absolute" ? 1 : -1,
			    scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
			    scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);

			return {
				top:

				// The absolute mouse position
				pos.top +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
				left:

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
			};
		},

		_generatePosition: function (event) {

			var top,
			    left,
			    o = this.options,
			    pageX = event.pageX,
			    pageY = event.pageY,
			    scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
			    scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);

			// This is another very weird special case that only happens for relative elements:
			// 1. If the css position is relative
			// 2. and the scroll parent is the document or similar to the offset parent
			// we have to refresh the relative offset during the scroll so there are no jumps
			if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
				this.offset.relative = this._getRelativeOffset();
			}

			/*
    * - Position constraining -
    * Constrain the position to a mix of grid, containment.
    */

			if (this.originalPosition) {
				//If we are not dragging yet, we won't check for options

				if (this.containment) {
					if (event.pageX - this.offset.click.left < this.containment[0]) {
						pageX = this.containment[0] + this.offset.click.left;
					}
					if (event.pageY - this.offset.click.top < this.containment[1]) {
						pageY = this.containment[1] + this.offset.click.top;
					}
					if (event.pageX - this.offset.click.left > this.containment[2]) {
						pageX = this.containment[2] + this.offset.click.left;
					}
					if (event.pageY - this.offset.click.top > this.containment[3]) {
						pageY = this.containment[3] + this.offset.click.top;
					}
				}

				if (o.grid) {
					top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
					pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;

					left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
					pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
				}
			}

			return {
				top:

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top + (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
				left:

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left + (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
			};
		},

		_rearrange: function (event, i, a, hardRefresh) {

			a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === "down" ? i.item[0] : i.item[0].nextSibling);

			//Various things done here to improve the performance:
			// 1. we create a setTimeout, that calls refreshPositions
			// 2. on the instance, we have a counter variable, that get's higher after every append
			// 3. on the local scope, we copy the counter variable, and check in the timeout,
			// if it's still the same
			// 4. this lets only the last addition to the timeout stack through
			this.counter = this.counter ? ++this.counter : 1;
			var counter = this.counter;

			this._delay(function () {
				if (counter === this.counter) {

					//Precompute after each DOM insertion, NOT on mousemove
					this.refreshPositions(!hardRefresh);
				}
			});
		},

		_clear: function (event, noPropagation) {

			this.reverting = false;

			// We delay all events that have to be triggered to after the point where the placeholder
			// has been removed and everything else normalized again
			var i,
			    delayedTriggers = [];

			// We first have to update the dom position of the actual currentItem
			// Note: don't do it if the current item is already removed (by a user), or it gets
			// reappended (see #4088)
			if (!this._noFinalSort && this.currentItem.parent().length) {
				this.placeholder.before(this.currentItem);
			}
			this._noFinalSort = null;

			if (this.helper[0] === this.currentItem[0]) {
				for (i in this._storedCSS) {
					if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
						this._storedCSS[i] = "";
					}
				}
				this.currentItem.css(this._storedCSS);
				this._removeClass(this.currentItem, "ui-sortable-helper");
			} else {
				this.currentItem.show();
			}

			if (this.fromOutside && !noPropagation) {
				delayedTriggers.push(function (event) {
					this._trigger("receive", event, this._uiHash(this.fromOutside));
				});
			}
			if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {

				// Trigger update callback if the DOM position has changed
				delayedTriggers.push(function (event) {
					this._trigger("update", event, this._uiHash());
				});
			}

			// Check if the items Container has Changed and trigger appropriate
			// events.
			if (this !== this.currentContainer) {
				if (!noPropagation) {
					delayedTriggers.push(function (event) {
						this._trigger("remove", event, this._uiHash());
					});
					delayedTriggers.push(function (c) {
						return function (event) {
							c._trigger("receive", event, this._uiHash(this));
						};
					}.call(this, this.currentContainer));
					delayedTriggers.push(function (c) {
						return function (event) {
							c._trigger("update", event, this._uiHash(this));
						};
					}.call(this, this.currentContainer));
				}
			}

			//Post events to containers
			function delayEvent(type, instance, container) {
				return function (event) {
					container._trigger(type, event, instance._uiHash(instance));
				};
			}
			for (i = this.containers.length - 1; i >= 0; i--) {
				if (!noPropagation) {
					delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
				}
				if (this.containers[i].containerCache.over) {
					delayedTriggers.push(delayEvent("out", this, this.containers[i]));
					this.containers[i].containerCache.over = 0;
				}
			}

			//Do what was originally in plugins
			if (this.storedCursor) {
				this.document.find("body").css("cursor", this.storedCursor);
				this.storedStylesheet.remove();
			}
			if (this._storedOpacity) {
				this.helper.css("opacity", this._storedOpacity);
			}
			if (this._storedZIndex) {
				this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
			}

			this.dragging = false;

			if (!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
			}

			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
			// it unbinds ALL events from the original node!
			this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

			if (!this.cancelHelperRemoval) {
				if (this.helper[0] !== this.currentItem[0]) {
					this.helper.remove();
				}
				this.helper = null;
			}

			if (!noPropagation) {
				for (i = 0; i < delayedTriggers.length; i++) {

					// Trigger all delayed events
					delayedTriggers[i].call(this, event);
				}
				this._trigger("stop", event, this._uiHash());
			}

			this.fromOutside = false;
			return !this.cancelHelperRemoval;
		},

		_trigger: function () {
			if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
				this.cancel();
			}
		},

		_uiHash: function (_inst) {
			var inst = _inst || this;
			return {
				helper: inst.helper,
				placeholder: inst.placeholder || $([]),
				position: inst.position,
				originalPosition: inst.originalPosition,
				offset: inst.positionAbs,
				item: inst.currentItem,
				sender: _inst ? _inst.element : null
			};
		}

	});
});
System.registerDynamic('npm:bootstrap-table@1.11.2/dist/bootstrap-table.js', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = System.registry.get("@@global-helpers").prepareGlobal($__module.id, null, {});

    (function ($__global) {
        /**
         * @author zhixin wen <wenzhixin2010@gmail.com>
         * version: 1.11.1
         * https://github.com/wenzhixin/bootstrap-table/
         */

        (function ($) {
            'use strict';

            // TOOLS DEFINITION
            // ======================

            var cachedWidth = null;

            // it only does '%s', and return '' when arguments are undefined
            var sprintf = function (str) {
                var args = arguments,
                    flag = true,
                    i = 1;

                str = str.replace(/%s/g, function () {
                    var arg = args[i++];

                    if (typeof arg === 'undefined') {
                        flag = false;
                        return '';
                    }
                    return arg;
                });
                return flag ? str : '';
            };

            var getPropertyFromOther = function (list, from, to, value) {
                var result = '';
                $.each(list, function (i, item) {
                    if (item[from] === value) {
                        result = item[to];
                        return false;
                    }
                    return true;
                });
                return result;
            };

            var getFieldIndex = function (columns, field) {
                var index = -1;

                $.each(columns, function (i, column) {
                    if (column.field === field) {
                        index = i;
                        return false;
                    }
                    return true;
                });
                return index;
            };

            // http://jsfiddle.net/wenyi/47nz7ez9/3/
            var setFieldIndex = function (columns) {
                var i,
                    j,
                    k,
                    totalCol = 0,
                    flag = [];

                for (i = 0; i < columns[0].length; i++) {
                    totalCol += columns[0][i].colspan || 1;
                }

                for (i = 0; i < columns.length; i++) {
                    flag[i] = [];
                    for (j = 0; j < totalCol; j++) {
                        flag[i][j] = false;
                    }
                }

                for (i = 0; i < columns.length; i++) {
                    for (j = 0; j < columns[i].length; j++) {
                        var r = columns[i][j],
                            rowspan = r.rowspan || 1,
                            colspan = r.colspan || 1,
                            index = $.inArray(false, flag[i]);

                        if (colspan === 1) {
                            r.fieldIndex = index;
                            // when field is undefined, use index instead
                            if (typeof r.field === 'undefined') {
                                r.field = index;
                            }
                        }

                        for (k = 0; k < rowspan; k++) {
                            flag[i + k][index] = true;
                        }
                        for (k = 0; k < colspan; k++) {
                            flag[i][index + k] = true;
                        }
                    }
                }
            };

            var getScrollBarWidth = function () {
                if (cachedWidth === null) {
                    var inner = $('<p/>').addClass('fixed-table-scroll-inner'),
                        outer = $('<div/>').addClass('fixed-table-scroll-outer'),
                        w1,
                        w2;

                    outer.append(inner);
                    $('body').append(outer);

                    w1 = inner[0].offsetWidth;
                    outer.css('overflow', 'scroll');
                    w2 = inner[0].offsetWidth;

                    if (w1 === w2) {
                        w2 = outer[0].clientWidth;
                    }

                    outer.remove();
                    cachedWidth = w1 - w2;
                }
                return cachedWidth;
            };

            var calculateObjectValue = function (self, name, args, defaultValue) {
                var func = name;

                if (typeof name === 'string') {
                    // support obj.func1.func2
                    var names = name.split('.');

                    if (names.length > 1) {
                        func = window;
                        $.each(names, function (i, f) {
                            func = func[f];
                        });
                    } else {
                        func = window[name];
                    }
                }
                if (typeof func === 'object') {
                    return func;
                }
                if (typeof func === 'function') {
                    return func.apply(self, args || []);
                }
                if (!func && typeof name === 'string' && sprintf.apply(this, [name].concat(args))) {
                    return sprintf.apply(this, [name].concat(args));
                }
                return defaultValue;
            };

            var compareObjects = function (objectA, objectB, compareLength) {
                // Create arrays of property names
                var objectAProperties = Object.getOwnPropertyNames(objectA),
                    objectBProperties = Object.getOwnPropertyNames(objectB),
                    propName = '';

                if (compareLength) {
                    // If number of properties is different, objects are not equivalent
                    if (objectAProperties.length !== objectBProperties.length) {
                        return false;
                    }
                }

                for (var i = 0; i < objectAProperties.length; i++) {
                    propName = objectAProperties[i];

                    // If the property is not in the object B properties, continue with the next property
                    if ($.inArray(propName, objectBProperties) > -1) {
                        // If values of same property are not equal, objects are not equivalent
                        if (objectA[propName] !== objectB[propName]) {
                            return false;
                        }
                    }
                }

                // If we made it this far, objects are considered equivalent
                return true;
            };

            var escapeHTML = function (text) {
                if (typeof text === 'string') {
                    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;').replace(/`/g, '&#x60;');
                }
                return text;
            };

            var getRealDataAttr = function (dataAttr) {
                for (var attr in dataAttr) {
                    var auxAttr = attr.split(/(?=[A-Z])/).join('-').toLowerCase();
                    if (auxAttr !== attr) {
                        dataAttr[auxAttr] = dataAttr[attr];
                        delete dataAttr[attr];
                    }
                }

                return dataAttr;
            };

            var getItemField = function (item, field, escape) {
                var value = item;

                if (typeof field !== 'string' || item.hasOwnProperty(field)) {
                    return escape ? escapeHTML(item[field]) : item[field];
                }
                var props = field.split('.');
                for (var p in props) {
                    if (props.hasOwnProperty(p)) {
                        value = value && value[props[p]];
                    }
                }
                return escape ? escapeHTML(value) : value;
            };

            var isIEBrowser = function () {
                return !!(navigator.userAgent.indexOf("MSIE ") > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./));
            };

            var objectKeys = function () {
                // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
                if (!Object.keys) {
                    Object.keys = function () {
                        var hasOwnProperty = Object.prototype.hasOwnProperty,
                            hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
                            dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
                            dontEnumsLength = dontEnums.length;

                        return function (obj) {
                            if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
                                throw new TypeError('Object.keys called on non-object');
                            }

                            var result = [],
                                prop,
                                i;

                            for (prop in obj) {
                                if (hasOwnProperty.call(obj, prop)) {
                                    result.push(prop);
                                }
                            }

                            if (hasDontEnumBug) {
                                for (i = 0; i < dontEnumsLength; i++) {
                                    if (hasOwnProperty.call(obj, dontEnums[i])) {
                                        result.push(dontEnums[i]);
                                    }
                                }
                            }
                            return result;
                        };
                    }();
                }
            };

            // BOOTSTRAP TABLE CLASS DEFINITION
            // ======================

            var BootstrapTable = function (el, options) {
                this.options = options;
                this.$el = $(el);
                this.$el_ = this.$el.clone();
                this.timeoutId_ = 0;
                this.timeoutFooter_ = 0;

                this.init();
            };

            BootstrapTable.DEFAULTS = {
                classes: 'table table-hover',
                sortClass: undefined,
                locale: undefined,
                height: undefined,
                undefinedText: '-',
                sortName: undefined,
                sortOrder: 'asc',
                sortStable: false,
                striped: false,
                columns: [[]],
                data: [],
                totalField: 'total',
                dataField: 'rows',
                method: 'get',
                url: undefined,
                ajax: undefined,
                cache: true,
                contentType: 'application/json',
                dataType: 'json',
                ajaxOptions: {},
                queryParams: function (params) {
                    return params;
                },
                queryParamsType: 'limit', // undefined
                responseHandler: function (res) {
                    return res;
                },
                pagination: false,
                onlyInfoPagination: false,
                paginationLoop: true,
                sidePagination: 'client', // client or server
                totalRows: 0, // server side need to set
                pageNumber: 1,
                pageSize: 10,
                pageList: [10, 25, 50, 100],
                paginationHAlign: 'right', //right, left
                paginationVAlign: 'bottom', //bottom, top, both
                paginationDetailHAlign: 'left', //right, left
                paginationPreText: '&lsaquo;',
                paginationNextText: '&rsaquo;',
                search: false,
                searchOnEnterKey: false,
                strictSearch: false,
                searchAlign: 'right',
                selectItemName: 'btSelectItem',
                showHeader: true,
                showFooter: false,
                showColumns: false,
                showPaginationSwitch: false,
                showRefresh: false,
                showToggle: false,
                buttonsAlign: 'right',
                smartDisplay: true,
                escape: false,
                minimumCountColumns: 1,
                idField: undefined,
                uniqueId: undefined,
                cardView: false,
                detailView: false,
                detailFormatter: function (index, row) {
                    return '';
                },
                trimOnSearch: true,
                clickToSelect: false,
                singleSelect: false,
                toolbar: undefined,
                toolbarAlign: 'left',
                checkboxHeader: true,
                sortable: true,
                silentSort: true,
                maintainSelected: false,
                searchTimeOut: 500,
                searchText: '',
                iconSize: undefined,
                buttonsClass: 'default',
                iconsPrefix: 'glyphicon', // glyphicon of fa (font awesome)
                icons: {
                    paginationSwitchDown: 'glyphicon-collapse-down icon-chevron-down',
                    paginationSwitchUp: 'glyphicon-collapse-up icon-chevron-up',
                    refresh: 'glyphicon-refresh icon-refresh',
                    toggle: 'glyphicon-list-alt icon-list-alt',
                    columns: 'glyphicon-th icon-th',
                    detailOpen: 'glyphicon-plus icon-plus',
                    detailClose: 'glyphicon-minus icon-minus'
                },

                customSearch: $.noop,

                customSort: $.noop,

                rowStyle: function (row, index) {
                    return {};
                },

                rowAttributes: function (row, index) {
                    return {};
                },

                footerStyle: function (row, index) {
                    return {};
                },

                onAll: function (name, args) {
                    return false;
                },
                onClickCell: function (field, value, row, $element) {
                    return false;
                },
                onDblClickCell: function (field, value, row, $element) {
                    return false;
                },
                onClickRow: function (item, $element) {
                    return false;
                },
                onDblClickRow: function (item, $element) {
                    return false;
                },
                onSort: function (name, order) {
                    return false;
                },
                onCheck: function (row) {
                    return false;
                },
                onUncheck: function (row) {
                    return false;
                },
                onCheckAll: function (rows) {
                    return false;
                },
                onUncheckAll: function (rows) {
                    return false;
                },
                onCheckSome: function (rows) {
                    return false;
                },
                onUncheckSome: function (rows) {
                    return false;
                },
                onLoadSuccess: function (data) {
                    return false;
                },
                onLoadError: function (status) {
                    return false;
                },
                onColumnSwitch: function (field, checked) {
                    return false;
                },
                onPageChange: function (number, size) {
                    return false;
                },
                onSearch: function (text) {
                    return false;
                },
                onToggle: function (cardView) {
                    return false;
                },
                onPreBody: function (data) {
                    return false;
                },
                onPostBody: function () {
                    return false;
                },
                onPostHeader: function () {
                    return false;
                },
                onExpandRow: function (index, row, $detail) {
                    return false;
                },
                onCollapseRow: function (index, row) {
                    return false;
                },
                onRefreshOptions: function (options) {
                    return false;
                },
                onRefresh: function (params) {
                    return false;
                },
                onResetView: function () {
                    return false;
                }
            };

            BootstrapTable.LOCALES = {};

            BootstrapTable.LOCALES['en-US'] = BootstrapTable.LOCALES.en = {
                formatLoadingMessage: function () {
                    return 'Loading, please wait...';
                },
                formatRecordsPerPage: function (pageNumber) {
                    return sprintf('%s rows per page', pageNumber);
                },
                formatShowingRows: function (pageFrom, pageTo, totalRows) {
                    return sprintf('Showing %s to %s of %s rows', pageFrom, pageTo, totalRows);
                },
                formatDetailPagination: function (totalRows) {
                    return sprintf('Showing %s rows', totalRows);
                },
                formatSearch: function () {
                    return 'Search';
                },
                formatNoMatches: function () {
                    return 'No matching records found';
                },
                formatPaginationSwitch: function () {
                    return 'Hide/Show pagination';
                },
                formatRefresh: function () {
                    return 'Refresh';
                },
                formatToggle: function () {
                    return 'Toggle';
                },
                formatColumns: function () {
                    return 'Columns';
                },
                formatAllRows: function () {
                    return 'All';
                }
            };

            $.extend(BootstrapTable.DEFAULTS, BootstrapTable.LOCALES['en-US']);

            BootstrapTable.COLUMN_DEFAULTS = {
                radio: false,
                checkbox: false,
                checkboxEnabled: true,
                field: undefined,
                title: undefined,
                titleTooltip: undefined,
                'class': undefined,
                align: undefined, // left, right, center
                halign: undefined, // left, right, center
                falign: undefined, // left, right, center
                valign: undefined, // top, middle, bottom
                width: undefined,
                sortable: false,
                order: 'asc', // asc, desc
                visible: true,
                switchable: true,
                clickToSelect: true,
                formatter: undefined,
                footerFormatter: undefined,
                events: undefined,
                sorter: undefined,
                sortName: undefined,
                cellStyle: undefined,
                searchable: true,
                searchFormatter: true,
                cardVisible: true,
                escape: false
            };

            BootstrapTable.EVENTS = {
                'all.bs.table': 'onAll',
                'click-cell.bs.table': 'onClickCell',
                'dbl-click-cell.bs.table': 'onDblClickCell',
                'click-row.bs.table': 'onClickRow',
                'dbl-click-row.bs.table': 'onDblClickRow',
                'sort.bs.table': 'onSort',
                'check.bs.table': 'onCheck',
                'uncheck.bs.table': 'onUncheck',
                'check-all.bs.table': 'onCheckAll',
                'uncheck-all.bs.table': 'onUncheckAll',
                'check-some.bs.table': 'onCheckSome',
                'uncheck-some.bs.table': 'onUncheckSome',
                'load-success.bs.table': 'onLoadSuccess',
                'load-error.bs.table': 'onLoadError',
                'column-switch.bs.table': 'onColumnSwitch',
                'page-change.bs.table': 'onPageChange',
                'search.bs.table': 'onSearch',
                'toggle.bs.table': 'onToggle',
                'pre-body.bs.table': 'onPreBody',
                'post-body.bs.table': 'onPostBody',
                'post-header.bs.table': 'onPostHeader',
                'expand-row.bs.table': 'onExpandRow',
                'collapse-row.bs.table': 'onCollapseRow',
                'refresh-options.bs.table': 'onRefreshOptions',
                'reset-view.bs.table': 'onResetView',
                'refresh.bs.table': 'onRefresh'
            };

            BootstrapTable.prototype.init = function () {
                this.initLocale();
                this.initContainer();
                this.initTable();
                this.initHeader();
                this.initData();
                this.initHiddenRows();
                this.initFooter();
                this.initToolbar();
                this.initPagination();
                this.initBody();
                this.initSearchText();
                this.initServer();
            };

            BootstrapTable.prototype.initLocale = function () {
                if (this.options.locale) {
                    var parts = this.options.locale.split(/-|_/);
                    parts[0].toLowerCase();
                    if (parts[1]) parts[1].toUpperCase();
                    if ($.fn.bootstrapTable.locales[this.options.locale]) {
                        // locale as requested
                        $.extend(this.options, $.fn.bootstrapTable.locales[this.options.locale]);
                    } else if ($.fn.bootstrapTable.locales[parts.join('-')]) {
                        // locale with sep set to - (in case original was specified with _)
                        $.extend(this.options, $.fn.bootstrapTable.locales[parts.join('-')]);
                    } else if ($.fn.bootstrapTable.locales[parts[0]]) {
                        // short locale language code (i.e. 'en')
                        $.extend(this.options, $.fn.bootstrapTable.locales[parts[0]]);
                    }
                }
            };

            BootstrapTable.prototype.initContainer = function () {
                this.$container = $(['<div class="bootstrap-table">', '<div class="fixed-table-toolbar"></div>', this.options.paginationVAlign === 'top' || this.options.paginationVAlign === 'both' ? '<div class="fixed-table-pagination" style="clear: both;"></div>' : '', '<div class="fixed-table-container">', '<div class="fixed-table-header"><table></table></div>', '<div class="fixed-table-body">', '<div class="fixed-table-loading">', this.options.formatLoadingMessage(), '</div>', '</div>', '<div class="fixed-table-footer"><table><tr></tr></table></div>', this.options.paginationVAlign === 'bottom' || this.options.paginationVAlign === 'both' ? '<div class="fixed-table-pagination"></div>' : '', '</div>', '</div>'].join(''));

                this.$container.insertAfter(this.$el);
                this.$tableContainer = this.$container.find('.fixed-table-container');
                this.$tableHeader = this.$container.find('.fixed-table-header');
                this.$tableBody = this.$container.find('.fixed-table-body');
                this.$tableLoading = this.$container.find('.fixed-table-loading');
                this.$tableFooter = this.$container.find('.fixed-table-footer');
                this.$toolbar = this.$container.find('.fixed-table-toolbar');
                this.$pagination = this.$container.find('.fixed-table-pagination');

                this.$tableBody.append(this.$el);
                this.$container.after('<div class="clearfix"></div>');

                this.$el.addClass(this.options.classes);
                if (this.options.striped) {
                    this.$el.addClass('table-striped');
                }
                if ($.inArray('table-no-bordered', this.options.classes.split(' ')) !== -1) {
                    this.$tableContainer.addClass('table-no-bordered');
                }
            };

            BootstrapTable.prototype.initTable = function () {
                var that = this,
                    columns = [],
                    data = [];

                this.$header = this.$el.find('>thead');
                if (!this.$header.length) {
                    this.$header = $('<thead></thead>').appendTo(this.$el);
                }
                this.$header.find('tr').each(function () {
                    var column = [];

                    $(this).find('th').each(function () {
                        // Fix #2014 - getFieldIndex and elsewhere assume this is string, causes issues if not
                        if (typeof $(this).data('field') !== 'undefined') {
                            $(this).data('field', $(this).data('field') + '');
                        }
                        column.push($.extend({}, {
                            title: $(this).html(),
                            'class': $(this).attr('class'),
                            titleTooltip: $(this).attr('title'),
                            rowspan: $(this).attr('rowspan') ? +$(this).attr('rowspan') : undefined,
                            colspan: $(this).attr('colspan') ? +$(this).attr('colspan') : undefined
                        }, $(this).data()));
                    });
                    columns.push(column);
                });
                if (!$.isArray(this.options.columns[0])) {
                    this.options.columns = [this.options.columns];
                }
                this.options.columns = $.extend(true, [], columns, this.options.columns);
                this.columns = [];

                setFieldIndex(this.options.columns);
                $.each(this.options.columns, function (i, columns) {
                    $.each(columns, function (j, column) {
                        column = $.extend({}, BootstrapTable.COLUMN_DEFAULTS, column);

                        if (typeof column.fieldIndex !== 'undefined') {
                            that.columns[column.fieldIndex] = column;
                        }

                        that.options.columns[i][j] = column;
                    });
                });

                // if options.data is setting, do not process tbody data
                if (this.options.data.length) {
                    return;
                }

                var m = [];
                this.$el.find('>tbody>tr').each(function (y) {
                    var row = {};

                    // save tr's id, class and data-* attributes
                    row._id = $(this).attr('id');
                    row._class = $(this).attr('class');
                    row._data = getRealDataAttr($(this).data());

                    $(this).find('>td').each(function (x) {
                        var $this = $(this),
                            cspan = +$this.attr('colspan') || 1,
                            rspan = +$this.attr('rowspan') || 1,
                            tx,
                            ty;

                        for (; m[y] && m[y][x]; x++); //skip already occupied cells in current row

                        for (tx = x; tx < x + cspan; tx++) {
                            //mark matrix elements occupied by current cell with true
                            for (ty = y; ty < y + rspan; ty++) {
                                if (!m[ty]) {
                                    //fill missing rows
                                    m[ty] = [];
                                }
                                m[ty][tx] = true;
                            }
                        }

                        var field = that.columns[x].field;

                        row[field] = $(this).html();
                        // save td's id, class and data-* attributes
                        row['_' + field + '_id'] = $(this).attr('id');
                        row['_' + field + '_class'] = $(this).attr('class');
                        row['_' + field + '_rowspan'] = $(this).attr('rowspan');
                        row['_' + field + '_colspan'] = $(this).attr('colspan');
                        row['_' + field + '_title'] = $(this).attr('title');
                        row['_' + field + '_data'] = getRealDataAttr($(this).data());
                    });
                    data.push(row);
                });
                this.options.data = data;
                if (data.length) this.fromHtml = true;
            };

            BootstrapTable.prototype.initHeader = function () {
                var that = this,
                    visibleColumns = {},
                    html = [];

                this.header = {
                    fields: [],
                    styles: [],
                    classes: [],
                    formatters: [],
                    events: [],
                    sorters: [],
                    sortNames: [],
                    cellStyles: [],
                    searchables: []
                };

                $.each(this.options.columns, function (i, columns) {
                    html.push('<tr>');

                    if (i === 0 && !that.options.cardView && that.options.detailView) {
                        html.push(sprintf('<th class="detail" rowspan="%s"><div class="fht-cell"></div></th>', that.options.columns.length));
                    }

                    $.each(columns, function (j, column) {
                        var text = '',
                            halign = '',
                            // header align style
                        align = '',
                            // body align style
                        style = '',
                            class_ = sprintf(' class="%s"', column['class']),
                            order = that.options.sortOrder || column.order,
                            unitWidth = 'px',
                            width = column.width;

                        if (column.width !== undefined && !that.options.cardView) {
                            if (typeof column.width === 'string') {
                                if (column.width.indexOf('%') !== -1) {
                                    unitWidth = '%';
                                }
                            }
                        }
                        if (column.width && typeof column.width === 'string') {
                            width = column.width.replace('%', '').replace('px', '');
                        }

                        halign = sprintf('text-align: %s; ', column.halign ? column.halign : column.align);
                        align = sprintf('text-align: %s; ', column.align);
                        style = sprintf('vertical-align: %s; ', column.valign);
                        style += sprintf('width: %s; ', (column.checkbox || column.radio) && !width ? '36px' : width ? width + unitWidth : undefined);

                        if (typeof column.fieldIndex !== 'undefined') {
                            that.header.fields[column.fieldIndex] = column.field;
                            that.header.styles[column.fieldIndex] = align + style;
                            that.header.classes[column.fieldIndex] = class_;
                            that.header.formatters[column.fieldIndex] = column.formatter;
                            that.header.events[column.fieldIndex] = column.events;
                            that.header.sorters[column.fieldIndex] = column.sorter;
                            that.header.sortNames[column.fieldIndex] = column.sortName;
                            that.header.cellStyles[column.fieldIndex] = column.cellStyle;
                            that.header.searchables[column.fieldIndex] = column.searchable;

                            if (!column.visible) {
                                return;
                            }

                            if (that.options.cardView && !column.cardVisible) {
                                return;
                            }

                            visibleColumns[column.field] = column;
                        }

                        html.push('<th' + sprintf(' title="%s"', column.titleTooltip), column.checkbox || column.radio ? sprintf(' class="bs-checkbox %s"', column['class'] || '') : class_, sprintf(' style="%s"', halign + style), sprintf(' rowspan="%s"', column.rowspan), sprintf(' colspan="%s"', column.colspan), sprintf(' data-field="%s"', column.field), '>');

                        html.push(sprintf('<div class="th-inner %s">', that.options.sortable && column.sortable ? 'sortable both' : ''));

                        text = that.options.escape ? escapeHTML(column.title) : column.title;

                        if (column.checkbox) {
                            if (!that.options.singleSelect && that.options.checkboxHeader) {
                                text = '<input name="btSelectAll" type="checkbox" />';
                            }
                            that.header.stateField = column.field;
                        }
                        if (column.radio) {
                            text = '';
                            that.header.stateField = column.field;
                            that.options.singleSelect = true;
                        }

                        html.push(text);
                        html.push('</div>');
                        html.push('<div class="fht-cell"></div>');
                        html.push('</div>');
                        html.push('</th>');
                    });
                    html.push('</tr>');
                });

                this.$header.html(html.join(''));
                this.$header.find('th[data-field]').each(function (i) {
                    $(this).data(visibleColumns[$(this).data('field')]);
                });
                this.$container.off('click', '.th-inner').on('click', '.th-inner', function (event) {
                    var target = $(this);

                    if (that.options.detailView) {
                        if (target.closest('.bootstrap-table')[0] !== that.$container[0]) return false;
                    }

                    if (that.options.sortable && target.parent().data().sortable) {
                        that.onSort(event);
                    }
                });

                this.$header.children().children().off('keypress').on('keypress', function (event) {
                    if (that.options.sortable && $(this).data().sortable) {
                        var code = event.keyCode || event.which;
                        if (code == 13) {
                            //Enter keycode
                            that.onSort(event);
                        }
                    }
                });

                $(window).off('resize.bootstrap-table');
                if (!this.options.showHeader || this.options.cardView) {
                    this.$header.hide();
                    this.$tableHeader.hide();
                    this.$tableLoading.css('top', 0);
                } else {
                    this.$header.show();
                    this.$tableHeader.show();
                    this.$tableLoading.css('top', this.$header.outerHeight() + 1);
                    // Assign the correct sortable arrow
                    this.getCaret();
                    $(window).on('resize.bootstrap-table', $.proxy(this.resetWidth, this));
                }

                this.$selectAll = this.$header.find('[name="btSelectAll"]');
                this.$selectAll.off('click').on('click', function () {
                    var checked = $(this).prop('checked');
                    that[checked ? 'checkAll' : 'uncheckAll']();
                    that.updateSelected();
                });
            };

            BootstrapTable.prototype.initFooter = function () {
                if (!this.options.showFooter || this.options.cardView) {
                    this.$tableFooter.hide();
                } else {
                    this.$tableFooter.show();
                }
            };

            /**
             * @param data
             * @param type: append / prepend
             */
            BootstrapTable.prototype.initData = function (data, type) {
                if (type === 'append') {
                    this.data = this.data.concat(data);
                } else if (type === 'prepend') {
                    this.data = [].concat(data).concat(this.data);
                } else {
                    this.data = data || this.options.data;
                }

                // Fix #839 Records deleted when adding new row on filtered table
                if (type === 'append') {
                    this.options.data = this.options.data.concat(data);
                } else if (type === 'prepend') {
                    this.options.data = [].concat(data).concat(this.options.data);
                } else {
                    this.options.data = this.data;
                }

                if (this.options.sidePagination === 'server') {
                    return;
                }
                this.initSort();
            };

            BootstrapTable.prototype.initSort = function () {
                var that = this,
                    name = this.options.sortName,
                    order = this.options.sortOrder === 'desc' ? -1 : 1,
                    index = $.inArray(this.options.sortName, this.header.fields),
                    timeoutId = 0;

                if (this.options.customSort !== $.noop) {
                    this.options.customSort.apply(this, [this.options.sortName, this.options.sortOrder]);
                    return;
                }

                if (index !== -1) {
                    if (this.options.sortStable) {
                        $.each(this.data, function (i, row) {
                            if (!row.hasOwnProperty('_position')) row._position = i;
                        });
                    }

                    this.data.sort(function (a, b) {
                        if (that.header.sortNames[index]) {
                            name = that.header.sortNames[index];
                        }
                        var aa = getItemField(a, name, that.options.escape),
                            bb = getItemField(b, name, that.options.escape),
                            value = calculateObjectValue(that.header, that.header.sorters[index], [aa, bb]);

                        if (value !== undefined) {
                            return order * value;
                        }

                        // Fix #161: undefined or null string sort bug.
                        if (aa === undefined || aa === null) {
                            aa = '';
                        }
                        if (bb === undefined || bb === null) {
                            bb = '';
                        }

                        if (that.options.sortStable && aa === bb) {
                            aa = a._position;
                            bb = b._position;
                        }

                        // IF both values are numeric, do a numeric comparison
                        if ($.isNumeric(aa) && $.isNumeric(bb)) {
                            // Convert numerical values form string to float.
                            aa = parseFloat(aa);
                            bb = parseFloat(bb);
                            if (aa < bb) {
                                return order * -1;
                            }
                            return order;
                        }

                        if (aa === bb) {
                            return 0;
                        }

                        // If value is not a string, convert to string
                        if (typeof aa !== 'string') {
                            aa = aa.toString();
                        }

                        if (aa.localeCompare(bb) === -1) {
                            return order * -1;
                        }

                        return order;
                    });

                    if (this.options.sortClass !== undefined) {
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(function () {
                            that.$el.removeClass(that.options.sortClass);
                            var index = that.$header.find(sprintf('[data-field="%s"]', that.options.sortName).index() + 1);
                            that.$el.find(sprintf('tr td:nth-child(%s)', index)).addClass(that.options.sortClass);
                        }, 250);
                    }
                }
            };

            BootstrapTable.prototype.onSort = function (event) {
                var $this = event.type === "keypress" ? $(event.currentTarget) : $(event.currentTarget).parent(),
                    $this_ = this.$header.find('th').eq($this.index());

                this.$header.add(this.$header_).find('span.order').remove();

                if (this.options.sortName === $this.data('field')) {
                    this.options.sortOrder = this.options.sortOrder === 'asc' ? 'desc' : 'asc';
                } else {
                    this.options.sortName = $this.data('field');
                    this.options.sortOrder = $this.data('order') === 'asc' ? 'desc' : 'asc';
                }
                this.trigger('sort', this.options.sortName, this.options.sortOrder);

                $this.add($this_).data('order', this.options.sortOrder);

                // Assign the correct sortable arrow
                this.getCaret();

                if (this.options.sidePagination === 'server') {
                    this.initServer(this.options.silentSort);
                    return;
                }

                this.initSort();
                this.initBody();
            };

            BootstrapTable.prototype.initToolbar = function () {
                var that = this,
                    html = [],
                    timeoutId = 0,
                    $keepOpen,
                    $search,
                    switchableCount = 0;

                if (this.$toolbar.find('.bs-bars').children().length) {
                    $('body').append($(this.options.toolbar));
                }
                this.$toolbar.html('');

                if (typeof this.options.toolbar === 'string' || typeof this.options.toolbar === 'object') {
                    $(sprintf('<div class="bs-bars pull-%s"></div>', this.options.toolbarAlign)).appendTo(this.$toolbar).append($(this.options.toolbar));
                }

                // showColumns, showToggle, showRefresh
                html = [sprintf('<div class="columns columns-%s btn-group pull-%s">', this.options.buttonsAlign, this.options.buttonsAlign)];

                if (typeof this.options.icons === 'string') {
                    this.options.icons = calculateObjectValue(null, this.options.icons);
                }

                if (this.options.showPaginationSwitch) {
                    html.push(sprintf('<button class="btn' + sprintf(' btn-%s', this.options.buttonsClass) + sprintf(' btn-%s', this.options.iconSize) + '" type="button" name="paginationSwitch" aria-label="pagination Switch" title="%s">', this.options.formatPaginationSwitch()), sprintf('<i class="%s %s"></i>', this.options.iconsPrefix, this.options.icons.paginationSwitchDown), '</button>');
                }

                if (this.options.showRefresh) {
                    html.push(sprintf('<button class="btn' + sprintf(' btn-%s', this.options.buttonsClass) + sprintf(' btn-%s', this.options.iconSize) + '" type="button" name="refresh" aria-label="refresh" title="%s">', this.options.formatRefresh()), sprintf('<i class="%s %s"></i>', this.options.iconsPrefix, this.options.icons.refresh), '</button>');
                }

                if (this.options.showToggle) {
                    html.push(sprintf('<button class="btn' + sprintf(' btn-%s', this.options.buttonsClass) + sprintf(' btn-%s', this.options.iconSize) + '" type="button" name="toggle" aria-label="toggle" title="%s">', this.options.formatToggle()), sprintf('<i class="%s %s"></i>', this.options.iconsPrefix, this.options.icons.toggle), '</button>');
                }

                if (this.options.showColumns) {
                    html.push(sprintf('<div class="keep-open btn-group" title="%s">', this.options.formatColumns()), '<button type="button" aria-label="columns" class="btn' + sprintf(' btn-%s', this.options.buttonsClass) + sprintf(' btn-%s', this.options.iconSize) + ' dropdown-toggle" data-toggle="dropdown">', sprintf('<i class="%s %s"></i>', this.options.iconsPrefix, this.options.icons.columns), ' <span class="caret"></span>', '</button>', '<ul class="dropdown-menu" role="menu">');

                    $.each(this.columns, function (i, column) {
                        if (column.radio || column.checkbox) {
                            return;
                        }

                        if (that.options.cardView && !column.cardVisible) {
                            return;
                        }

                        var checked = column.visible ? ' checked="checked"' : '';

                        if (column.switchable) {
                            html.push(sprintf('<li role="menuitem">' + '<label><input type="checkbox" data-field="%s" value="%s"%s> %s</label>' + '</li>', column.field, i, checked, column.title));
                            switchableCount++;
                        }
                    });
                    html.push('</ul>', '</div>');
                }

                html.push('</div>');

                // Fix #188: this.showToolbar is for extensions
                if (this.showToolbar || html.length > 2) {
                    this.$toolbar.append(html.join(''));
                }

                if (this.options.showPaginationSwitch) {
                    this.$toolbar.find('button[name="paginationSwitch"]').off('click').on('click', $.proxy(this.togglePagination, this));
                }

                if (this.options.showRefresh) {
                    this.$toolbar.find('button[name="refresh"]').off('click').on('click', $.proxy(this.refresh, this));
                }

                if (this.options.showToggle) {
                    this.$toolbar.find('button[name="toggle"]').off('click').on('click', function () {
                        that.toggleView();
                    });
                }

                if (this.options.showColumns) {
                    $keepOpen = this.$toolbar.find('.keep-open');

                    if (switchableCount <= this.options.minimumCountColumns) {
                        $keepOpen.find('input').prop('disabled', true);
                    }

                    $keepOpen.find('li').off('click').on('click', function (event) {
                        event.stopImmediatePropagation();
                    });
                    $keepOpen.find('input').off('click').on('click', function () {
                        var $this = $(this);

                        that.toggleColumn($(this).val(), $this.prop('checked'), false);
                        that.trigger('column-switch', $(this).data('field'), $this.prop('checked'));
                    });
                }

                if (this.options.search) {
                    html = [];
                    html.push('<div class="pull-' + this.options.searchAlign + ' search">', sprintf('<input class="form-control' + sprintf(' input-%s', this.options.iconSize) + '" type="text" placeholder="%s">', this.options.formatSearch()), '</div>');

                    this.$toolbar.append(html.join(''));
                    $search = this.$toolbar.find('.search input');
                    $search.off('keyup drop blur').on('keyup drop blur', function (event) {
                        if (that.options.searchOnEnterKey && event.keyCode !== 13) {
                            return;
                        }

                        if ($.inArray(event.keyCode, [37, 38, 39, 40]) > -1) {
                            return;
                        }

                        clearTimeout(timeoutId); // doesn't matter if it's 0
                        timeoutId = setTimeout(function () {
                            that.onSearch(event);
                        }, that.options.searchTimeOut);
                    });

                    if (isIEBrowser()) {
                        $search.off('mouseup').on('mouseup', function (event) {
                            clearTimeout(timeoutId); // doesn't matter if it's 0
                            timeoutId = setTimeout(function () {
                                that.onSearch(event);
                            }, that.options.searchTimeOut);
                        });
                    }
                }
            };

            BootstrapTable.prototype.onSearch = function (event) {
                var text = $.trim($(event.currentTarget).val());

                // trim search input
                if (this.options.trimOnSearch && $(event.currentTarget).val() !== text) {
                    $(event.currentTarget).val(text);
                }

                if (text === this.searchText) {
                    return;
                }
                this.searchText = text;
                this.options.searchText = text;

                this.options.pageNumber = 1;
                this.initSearch();
                this.updatePagination();
                this.trigger('search', text);
            };

            BootstrapTable.prototype.initSearch = function () {
                var that = this;

                if (this.options.sidePagination !== 'server') {
                    if (this.options.customSearch !== $.noop) {
                        this.options.customSearch.apply(this, [this.searchText]);
                        return;
                    }

                    var s = this.searchText && (this.options.escape ? escapeHTML(this.searchText) : this.searchText).toLowerCase();
                    var f = $.isEmptyObject(this.filterColumns) ? null : this.filterColumns;

                    // Check filter
                    this.data = f ? $.grep(this.options.data, function (item, i) {
                        for (var key in f) {
                            if ($.isArray(f[key]) && $.inArray(item[key], f[key]) === -1 || !$.isArray(f[key]) && item[key] !== f[key]) {
                                return false;
                            }
                        }
                        return true;
                    }) : this.options.data;

                    this.data = s ? $.grep(this.data, function (item, i) {
                        for (var j = 0; j < that.header.fields.length; j++) {

                            if (!that.header.searchables[j]) {
                                continue;
                            }

                            var key = $.isNumeric(that.header.fields[j]) ? parseInt(that.header.fields[j], 10) : that.header.fields[j];
                            var column = that.columns[getFieldIndex(that.columns, key)];
                            var value;

                            if (typeof key === 'string') {
                                value = item;
                                var props = key.split('.');
                                for (var prop_index = 0; prop_index < props.length; prop_index++) {
                                    value = value[props[prop_index]];
                                }

                                // Fix #142: respect searchForamtter boolean
                                if (column && column.searchFormatter) {
                                    value = calculateObjectValue(column, that.header.formatters[j], [value, item, i], value);
                                }
                            } else {
                                value = item[key];
                            }

                            if (typeof value === 'string' || typeof value === 'number') {
                                if (that.options.strictSearch) {
                                    if ((value + '').toLowerCase() === s) {
                                        return true;
                                    }
                                } else {
                                    if ((value + '').toLowerCase().indexOf(s) !== -1) {
                                        return true;
                                    }
                                }
                            }
                        }
                        return false;
                    }) : this.data;
                }
            };

            BootstrapTable.prototype.initPagination = function () {
                if (!this.options.pagination) {
                    this.$pagination.hide();
                    return;
                } else {
                    this.$pagination.show();
                }

                var that = this,
                    html = [],
                    $allSelected = false,
                    i,
                    from,
                    to,
                    $pageList,
                    $first,
                    $pre,
                    $next,
                    $last,
                    $number,
                    data = this.getData(),
                    pageList = this.options.pageList;

                if (this.options.sidePagination !== 'server') {
                    this.options.totalRows = data.length;
                }

                this.totalPages = 0;
                if (this.options.totalRows) {
                    if (this.options.pageSize === this.options.formatAllRows()) {
                        this.options.pageSize = this.options.totalRows;
                        $allSelected = true;
                    } else if (this.options.pageSize === this.options.totalRows) {
                        // Fix #667 Table with pagination,
                        // multiple pages and a search that matches to one page throws exception
                        var pageLst = typeof this.options.pageList === 'string' ? this.options.pageList.replace('[', '').replace(']', '').replace(/ /g, '').toLowerCase().split(',') : this.options.pageList;
                        if ($.inArray(this.options.formatAllRows().toLowerCase(), pageLst) > -1) {
                            $allSelected = true;
                        }
                    }

                    this.totalPages = ~~((this.options.totalRows - 1) / this.options.pageSize) + 1;

                    this.options.totalPages = this.totalPages;
                }
                if (this.totalPages > 0 && this.options.pageNumber > this.totalPages) {
                    this.options.pageNumber = this.totalPages;
                }

                this.pageFrom = (this.options.pageNumber - 1) * this.options.pageSize + 1;
                this.pageTo = this.options.pageNumber * this.options.pageSize;
                if (this.pageTo > this.options.totalRows) {
                    this.pageTo = this.options.totalRows;
                }

                html.push('<div class="pull-' + this.options.paginationDetailHAlign + ' pagination-detail">', '<span class="pagination-info">', this.options.onlyInfoPagination ? this.options.formatDetailPagination(this.options.totalRows) : this.options.formatShowingRows(this.pageFrom, this.pageTo, this.options.totalRows), '</span>');

                if (!this.options.onlyInfoPagination) {
                    html.push('<span class="page-list">');

                    var pageNumber = [sprintf('<span class="btn-group %s">', this.options.paginationVAlign === 'top' || this.options.paginationVAlign === 'both' ? 'dropdown' : 'dropup'), '<button type="button" class="btn' + sprintf(' btn-%s', this.options.buttonsClass) + sprintf(' btn-%s', this.options.iconSize) + ' dropdown-toggle" data-toggle="dropdown">', '<span class="page-size">', $allSelected ? this.options.formatAllRows() : this.options.pageSize, '</span>', ' <span class="caret"></span>', '</button>', '<ul class="dropdown-menu" role="menu">'];

                    if (typeof this.options.pageList === 'string') {
                        var list = this.options.pageList.replace('[', '').replace(']', '').replace(/ /g, '').split(',');

                        pageList = [];
                        $.each(list, function (i, value) {
                            pageList.push(value.toUpperCase() === that.options.formatAllRows().toUpperCase() ? that.options.formatAllRows() : +value);
                        });
                    }

                    $.each(pageList, function (i, page) {
                        if (!that.options.smartDisplay || i === 0 || pageList[i - 1] < that.options.totalRows) {
                            var active;
                            if ($allSelected) {
                                active = page === that.options.formatAllRows() ? ' class="active"' : '';
                            } else {
                                active = page === that.options.pageSize ? ' class="active"' : '';
                            }
                            pageNumber.push(sprintf('<li role="menuitem"%s><a href="#">%s</a></li>', active, page));
                        }
                    });
                    pageNumber.push('</ul></span>');

                    html.push(this.options.formatRecordsPerPage(pageNumber.join('')));
                    html.push('</span>');

                    html.push('</div>', '<div class="pull-' + this.options.paginationHAlign + ' pagination">', '<ul class="pagination' + sprintf(' pagination-%s', this.options.iconSize) + '">', '<li class="page-pre"><a href="#">' + this.options.paginationPreText + '</a></li>');

                    if (this.totalPages < 5) {
                        from = 1;
                        to = this.totalPages;
                    } else {
                        from = this.options.pageNumber - 2;
                        to = from + 4;
                        if (from < 1) {
                            from = 1;
                            to = 5;
                        }
                        if (to > this.totalPages) {
                            to = this.totalPages;
                            from = to - 4;
                        }
                    }

                    if (this.totalPages >= 6) {
                        if (this.options.pageNumber >= 3) {
                            html.push('<li class="page-first' + (1 === this.options.pageNumber ? ' active' : '') + '">', '<a href="#">', 1, '</a>', '</li>');

                            from++;
                        }

                        if (this.options.pageNumber >= 4) {
                            if (this.options.pageNumber == 4 || this.totalPages == 6 || this.totalPages == 7) {
                                from--;
                            } else {
                                html.push('<li class="page-first-separator disabled">', '<a href="#">...</a>', '</li>');
                            }

                            to--;
                        }
                    }

                    if (this.totalPages >= 7) {
                        if (this.options.pageNumber >= this.totalPages - 2) {
                            from--;
                        }
                    }

                    if (this.totalPages == 6) {
                        if (this.options.pageNumber >= this.totalPages - 2) {
                            to++;
                        }
                    } else if (this.totalPages >= 7) {
                        if (this.totalPages == 7 || this.options.pageNumber >= this.totalPages - 3) {
                            to++;
                        }
                    }

                    for (i = from; i <= to; i++) {
                        html.push('<li class="page-number' + (i === this.options.pageNumber ? ' active' : '') + '">', '<a href="#">', i, '</a>', '</li>');
                    }

                    if (this.totalPages >= 8) {
                        if (this.options.pageNumber <= this.totalPages - 4) {
                            html.push('<li class="page-last-separator disabled">', '<a href="#">...</a>', '</li>');
                        }
                    }

                    if (this.totalPages >= 6) {
                        if (this.options.pageNumber <= this.totalPages - 3) {
                            html.push('<li class="page-last' + (this.totalPages === this.options.pageNumber ? ' active' : '') + '">', '<a href="#">', this.totalPages, '</a>', '</li>');
                        }
                    }

                    html.push('<li class="page-next"><a href="#">' + this.options.paginationNextText + '</a></li>', '</ul>', '</div>');
                }
                this.$pagination.html(html.join(''));

                if (!this.options.onlyInfoPagination) {
                    $pageList = this.$pagination.find('.page-list a');
                    $first = this.$pagination.find('.page-first');
                    $pre = this.$pagination.find('.page-pre');
                    $next = this.$pagination.find('.page-next');
                    $last = this.$pagination.find('.page-last');
                    $number = this.$pagination.find('.page-number');

                    if (this.options.smartDisplay) {
                        if (this.totalPages <= 1) {
                            this.$pagination.find('div.pagination').hide();
                        }
                        if (pageList.length < 2 || this.options.totalRows <= pageList[0]) {
                            this.$pagination.find('span.page-list').hide();
                        }

                        // when data is empty, hide the pagination
                        this.$pagination[this.getData().length ? 'show' : 'hide']();
                    }

                    if (!this.options.paginationLoop) {
                        if (this.options.pageNumber === 1) {
                            $pre.addClass('disabled');
                        }
                        if (this.options.pageNumber === this.totalPages) {
                            $next.addClass('disabled');
                        }
                    }

                    if ($allSelected) {
                        this.options.pageSize = this.options.formatAllRows();
                    }
                    $pageList.off('click').on('click', $.proxy(this.onPageListChange, this));
                    $first.off('click').on('click', $.proxy(this.onPageFirst, this));
                    $pre.off('click').on('click', $.proxy(this.onPagePre, this));
                    $next.off('click').on('click', $.proxy(this.onPageNext, this));
                    $last.off('click').on('click', $.proxy(this.onPageLast, this));
                    $number.off('click').on('click', $.proxy(this.onPageNumber, this));
                }
            };

            BootstrapTable.prototype.updatePagination = function (event) {
                // Fix #171: IE disabled button can be clicked bug.
                if (event && $(event.currentTarget).hasClass('disabled')) {
                    return;
                }

                if (!this.options.maintainSelected) {
                    this.resetRows();
                }

                this.initPagination();
                if (this.options.sidePagination === 'server') {
                    this.initServer();
                } else {
                    this.initBody();
                }

                this.trigger('page-change', this.options.pageNumber, this.options.pageSize);
            };

            BootstrapTable.prototype.onPageListChange = function (event) {
                var $this = $(event.currentTarget);

                $this.parent().addClass('active').siblings().removeClass('active');
                this.options.pageSize = $this.text().toUpperCase() === this.options.formatAllRows().toUpperCase() ? this.options.formatAllRows() : +$this.text();
                this.$toolbar.find('.page-size').text(this.options.pageSize);

                this.updatePagination(event);
                return false;
            };

            BootstrapTable.prototype.onPageFirst = function (event) {
                this.options.pageNumber = 1;
                this.updatePagination(event);
                return false;
            };

            BootstrapTable.prototype.onPagePre = function (event) {
                if (this.options.pageNumber - 1 === 0) {
                    this.options.pageNumber = this.options.totalPages;
                } else {
                    this.options.pageNumber--;
                }
                this.updatePagination(event);
                return false;
            };

            BootstrapTable.prototype.onPageNext = function (event) {
                if (this.options.pageNumber + 1 > this.options.totalPages) {
                    this.options.pageNumber = 1;
                } else {
                    this.options.pageNumber++;
                }
                this.updatePagination(event);
                return false;
            };

            BootstrapTable.prototype.onPageLast = function (event) {
                this.options.pageNumber = this.totalPages;
                this.updatePagination(event);
                return false;
            };

            BootstrapTable.prototype.onPageNumber = function (event) {
                if (this.options.pageNumber === +$(event.currentTarget).text()) {
                    return;
                }
                this.options.pageNumber = +$(event.currentTarget).text();
                this.updatePagination(event);
                return false;
            };

            BootstrapTable.prototype.initRow = function (item, i, data, parentDom) {
                var that = this,
                    key,
                    html = [],
                    style = {},
                    csses = [],
                    data_ = '',
                    attributes = {},
                    htmlAttributes = [];

                if ($.inArray(item, this.hiddenRows) > -1) {
                    return;
                }

                style = calculateObjectValue(this.options, this.options.rowStyle, [item, i], style);

                if (style && style.css) {
                    for (key in style.css) {
                        csses.push(key + ': ' + style.css[key]);
                    }
                }

                attributes = calculateObjectValue(this.options, this.options.rowAttributes, [item, i], attributes);

                if (attributes) {
                    for (key in attributes) {
                        htmlAttributes.push(sprintf('%s="%s"', key, escapeHTML(attributes[key])));
                    }
                }

                if (item._data && !$.isEmptyObject(item._data)) {
                    $.each(item._data, function (k, v) {
                        // ignore data-index
                        if (k === 'index') {
                            return;
                        }
                        data_ += sprintf(' data-%s="%s"', k, v);
                    });
                }

                html.push('<tr', sprintf(' %s', htmlAttributes.join(' ')), sprintf(' id="%s"', $.isArray(item) ? undefined : item._id), sprintf(' class="%s"', style.classes || ($.isArray(item) ? undefined : item._class)), sprintf(' data-index="%s"', i), sprintf(' data-uniqueid="%s"', item[this.options.uniqueId]), sprintf('%s', data_), '>');

                if (this.options.cardView) {
                    html.push(sprintf('<td colspan="%s"><div class="card-views">', this.header.fields.length));
                }

                if (!this.options.cardView && this.options.detailView) {
                    html.push('<td>', '<a class="detail-icon" href="#">', sprintf('<i class="%s %s"></i>', this.options.iconsPrefix, this.options.icons.detailOpen), '</a>', '</td>');
                }

                $.each(this.header.fields, function (j, field) {
                    var text = '',
                        value_ = getItemField(item, field, that.options.escape),
                        value = '',
                        type = '',
                        cellStyle = {},
                        id_ = '',
                        class_ = that.header.classes[j],
                        data_ = '',
                        rowspan_ = '',
                        colspan_ = '',
                        title_ = '',
                        column = that.columns[j];

                    if (that.fromHtml && typeof value_ === 'undefined') {
                        return;
                    }

                    if (!column.visible) {
                        return;
                    }

                    if (that.options.cardView && !column.cardVisible) {
                        return;
                    }

                    if (column.escape) {
                        value_ = escapeHTML(value_);
                    }

                    style = sprintf('style="%s"', csses.concat(that.header.styles[j]).join('; '));

                    // handle td's id and class
                    if (item['_' + field + '_id']) {
                        id_ = sprintf(' id="%s"', item['_' + field + '_id']);
                    }
                    if (item['_' + field + '_class']) {
                        class_ = sprintf(' class="%s"', item['_' + field + '_class']);
                    }
                    if (item['_' + field + '_rowspan']) {
                        rowspan_ = sprintf(' rowspan="%s"', item['_' + field + '_rowspan']);
                    }
                    if (item['_' + field + '_colspan']) {
                        colspan_ = sprintf(' colspan="%s"', item['_' + field + '_colspan']);
                    }
                    if (item['_' + field + '_title']) {
                        title_ = sprintf(' title="%s"', item['_' + field + '_title']);
                    }
                    cellStyle = calculateObjectValue(that.header, that.header.cellStyles[j], [value_, item, i, field], cellStyle);
                    if (cellStyle.classes) {
                        class_ = sprintf(' class="%s"', cellStyle.classes);
                    }
                    if (cellStyle.css) {
                        var csses_ = [];
                        for (var key in cellStyle.css) {
                            csses_.push(key + ': ' + cellStyle.css[key]);
                        }
                        style = sprintf('style="%s"', csses_.concat(that.header.styles[j]).join('; '));
                    }

                    value = calculateObjectValue(column, that.header.formatters[j], [value_, item, i], value_);

                    if (item['_' + field + '_data'] && !$.isEmptyObject(item['_' + field + '_data'])) {
                        $.each(item['_' + field + '_data'], function (k, v) {
                            // ignore data-index
                            if (k === 'index') {
                                return;
                            }
                            data_ += sprintf(' data-%s="%s"', k, v);
                        });
                    }

                    if (column.checkbox || column.radio) {
                        type = column.checkbox ? 'checkbox' : type;
                        type = column.radio ? 'radio' : type;

                        text = [sprintf(that.options.cardView ? '<div class="card-view %s">' : '<td class="bs-checkbox %s">', column['class'] || ''), '<input' + sprintf(' data-index="%s"', i) + sprintf(' name="%s"', that.options.selectItemName) + sprintf(' type="%s"', type) + sprintf(' value="%s"', item[that.options.idField]) + sprintf(' checked="%s"', value === true || value_ || value && value.checked ? 'checked' : undefined) + sprintf(' disabled="%s"', !column.checkboxEnabled || value && value.disabled ? 'disabled' : undefined) + ' />', that.header.formatters[j] && typeof value === 'string' ? value : '', that.options.cardView ? '</div>' : '</td>'].join('');

                        item[that.header.stateField] = value === true || value && value.checked;
                    } else {
                        value = typeof value === 'undefined' || value === null ? that.options.undefinedText : value;

                        text = that.options.cardView ? ['<div class="card-view">', that.options.showHeader ? sprintf('<span class="title" %s>%s</span>', style, getPropertyFromOther(that.columns, 'field', 'title', field)) : '', sprintf('<span class="value">%s</span>', value), '</div>'].join('') : [sprintf('<td%s %s %s %s %s %s %s>', id_, class_, style, data_, rowspan_, colspan_, title_), value, '</td>'].join('');

                        // Hide empty data on Card view when smartDisplay is set to true.
                        if (that.options.cardView && that.options.smartDisplay && value === '') {
                            // Should set a placeholder for event binding correct fieldIndex
                            text = '<div class="card-view"></div>';
                        }
                    }

                    html.push(text);
                });

                if (this.options.cardView) {
                    html.push('</div></td>');
                }
                html.push('</tr>');

                return html.join(' ');
            };

            BootstrapTable.prototype.initBody = function (fixedScroll) {
                var that = this,
                    html = [],
                    data = this.getData();

                this.trigger('pre-body', data);

                this.$body = this.$el.find('>tbody');
                if (!this.$body.length) {
                    this.$body = $('<tbody></tbody>').appendTo(this.$el);
                }

                //Fix #389 Bootstrap-table-flatJSON is not working

                if (!this.options.pagination || this.options.sidePagination === 'server') {
                    this.pageFrom = 1;
                    this.pageTo = data.length;
                }

                var trFragments = $(document.createDocumentFragment());
                var hasTr;

                for (var i = this.pageFrom - 1; i < this.pageTo; i++) {
                    var item = data[i];
                    var tr = this.initRow(item, i, data, trFragments);
                    hasTr = hasTr || !!tr;
                    if (tr && tr !== true) {
                        trFragments.append(tr);
                    }
                }

                // show no records
                if (!hasTr) {
                    trFragments.append('<tr class="no-records-found">' + sprintf('<td colspan="%s">%s</td>', this.$header.find('th').length, this.options.formatNoMatches()) + '</tr>');
                }

                this.$body.html(trFragments);

                if (!fixedScroll) {
                    this.scrollTo(0);
                }

                // click to select by column
                this.$body.find('> tr[data-index] > td').off('click dblclick').on('click dblclick', function (e) {
                    var $td = $(this),
                        $tr = $td.parent(),
                        item = that.data[$tr.data('index')],
                        index = $td[0].cellIndex,
                        fields = that.getVisibleFields(),
                        field = fields[that.options.detailView && !that.options.cardView ? index - 1 : index],
                        column = that.columns[getFieldIndex(that.columns, field)],
                        value = getItemField(item, field, that.options.escape);

                    if ($td.find('.detail-icon').length) {
                        return;
                    }

                    that.trigger(e.type === 'click' ? 'click-cell' : 'dbl-click-cell', field, value, item, $td);
                    that.trigger(e.type === 'click' ? 'click-row' : 'dbl-click-row', item, $tr, field);

                    // if click to select - then trigger the checkbox/radio click
                    if (e.type === 'click' && that.options.clickToSelect && column.clickToSelect) {
                        var $selectItem = $tr.find(sprintf('[name="%s"]', that.options.selectItemName));
                        if ($selectItem.length) {
                            $selectItem[0].click(); // #144: .trigger('click') bug
                        }
                    }
                });

                this.$body.find('> tr[data-index] > td > .detail-icon').off('click').on('click', function () {
                    var $this = $(this),
                        $tr = $this.parent().parent(),
                        index = $tr.data('index'),
                        row = data[index]; // Fix #980 Detail view, when searching, returns wrong row

                    // remove and update
                    if ($tr.next().is('tr.detail-view')) {
                        $this.find('i').attr('class', sprintf('%s %s', that.options.iconsPrefix, that.options.icons.detailOpen));
                        that.trigger('collapse-row', index, row);
                        $tr.next().remove();
                    } else {
                        $this.find('i').attr('class', sprintf('%s %s', that.options.iconsPrefix, that.options.icons.detailClose));
                        $tr.after(sprintf('<tr class="detail-view"><td colspan="%s"></td></tr>', $tr.find('td').length));
                        var $element = $tr.next().find('td');
                        var content = calculateObjectValue(that.options, that.options.detailFormatter, [index, row, $element], '');
                        if ($element.length === 1) {
                            $element.append(content);
                        }
                        that.trigger('expand-row', index, row, $element);
                    }
                    that.resetView();
                    return false;
                });

                this.$selectItem = this.$body.find(sprintf('[name="%s"]', this.options.selectItemName));
                this.$selectItem.off('click').on('click', function (event) {
                    event.stopImmediatePropagation();

                    var $this = $(this),
                        checked = $this.prop('checked'),
                        row = that.data[$this.data('index')];

                    if (that.options.maintainSelected && $(this).is(':radio')) {
                        $.each(that.options.data, function (i, row) {
                            row[that.header.stateField] = false;
                        });
                    }

                    row[that.header.stateField] = checked;

                    if (that.options.singleSelect) {
                        that.$selectItem.not(this).each(function () {
                            that.data[$(this).data('index')][that.header.stateField] = false;
                        });
                        that.$selectItem.filter(':checked').not(this).prop('checked', false);
                    }

                    that.updateSelected();
                    that.trigger(checked ? 'check' : 'uncheck', row, $this);
                });

                $.each(this.header.events, function (i, events) {
                    if (!events) {
                        return;
                    }
                    // fix bug, if events is defined with namespace
                    if (typeof events === 'string') {
                        events = calculateObjectValue(null, events);
                    }

                    var field = that.header.fields[i],
                        fieldIndex = $.inArray(field, that.getVisibleFields());

                    if (that.options.detailView && !that.options.cardView) {
                        fieldIndex += 1;
                    }

                    for (var key in events) {
                        that.$body.find('>tr:not(.no-records-found)').each(function () {
                            var $tr = $(this),
                                $td = $tr.find(that.options.cardView ? '.card-view' : 'td').eq(fieldIndex),
                                index = key.indexOf(' '),
                                name = key.substring(0, index),
                                el = key.substring(index + 1),
                                func = events[key];

                            $td.find(el).off(name).on(name, function (e) {
                                var index = $tr.data('index'),
                                    row = that.data[index],
                                    value = row[field];

                                func.apply(this, [e, value, row, index]);
                            });
                        });
                    }
                });

                this.updateSelected();
                this.resetView();

                this.trigger('post-body', data);
            };

            BootstrapTable.prototype.initServer = function (silent, query, url) {
                var that = this,
                    data = {},
                    params = {
                    searchText: this.searchText,
                    sortName: this.options.sortName,
                    sortOrder: this.options.sortOrder
                },
                    request;

                if (this.options.pagination) {
                    params.pageSize = this.options.pageSize === this.options.formatAllRows() ? this.options.totalRows : this.options.pageSize;
                    params.pageNumber = this.options.pageNumber;
                }

                if (!(url || this.options.url) && !this.options.ajax) {
                    return;
                }

                if (this.options.queryParamsType === 'limit') {
                    params = {
                        search: params.searchText,
                        sort: params.sortName,
                        order: params.sortOrder
                    };

                    if (this.options.pagination) {
                        params.offset = this.options.pageSize === this.options.formatAllRows() ? 0 : this.options.pageSize * (this.options.pageNumber - 1);
                        params.limit = this.options.pageSize === this.options.formatAllRows() ? this.options.totalRows : this.options.pageSize;
                    }
                }

                if (!$.isEmptyObject(this.filterColumnsPartial)) {
                    params.filter = JSON.stringify(this.filterColumnsPartial, null);
                }

                data = calculateObjectValue(this.options, this.options.queryParams, [params], data);

                $.extend(data, query || {});

                // false to stop request
                if (data === false) {
                    return;
                }

                if (!silent) {
                    this.$tableLoading.show();
                }
                request = $.extend({}, calculateObjectValue(null, this.options.ajaxOptions), {
                    type: this.options.method,
                    url: url || this.options.url,
                    data: this.options.contentType === 'application/json' && this.options.method === 'post' ? JSON.stringify(data) : data,
                    cache: this.options.cache,
                    contentType: this.options.contentType,
                    dataType: this.options.dataType,
                    success: function (res) {
                        res = calculateObjectValue(that.options, that.options.responseHandler, [res], res);

                        that.load(res);
                        that.trigger('load-success', res);
                        if (!silent) that.$tableLoading.hide();
                    },
                    error: function (res) {
                        that.trigger('load-error', res.status, res);
                        if (!silent) that.$tableLoading.hide();
                    }
                });

                if (this.options.ajax) {
                    calculateObjectValue(this, this.options.ajax, [request], null);
                } else {
                    if (this._xhr && this._xhr.readyState !== 4) {
                        this._xhr.abort();
                    }
                    this._xhr = $.ajax(request);
                }
            };

            BootstrapTable.prototype.initSearchText = function () {
                if (this.options.search) {
                    if (this.options.searchText !== '') {
                        var $search = this.$toolbar.find('.search input');
                        $search.val(this.options.searchText);
                        this.onSearch({ currentTarget: $search });
                    }
                }
            };

            BootstrapTable.prototype.getCaret = function () {
                var that = this;

                $.each(this.$header.find('th'), function (i, th) {
                    $(th).find('.sortable').removeClass('desc asc').addClass($(th).data('field') === that.options.sortName ? that.options.sortOrder : 'both');
                });
            };

            BootstrapTable.prototype.updateSelected = function () {
                var checkAll = this.$selectItem.filter(':enabled').length && this.$selectItem.filter(':enabled').length === this.$selectItem.filter(':enabled').filter(':checked').length;

                this.$selectAll.add(this.$selectAll_).prop('checked', checkAll);

                this.$selectItem.each(function () {
                    $(this).closest('tr')[$(this).prop('checked') ? 'addClass' : 'removeClass']('selected');
                });
            };

            BootstrapTable.prototype.updateRows = function () {
                var that = this;

                this.$selectItem.each(function () {
                    that.data[$(this).data('index')][that.header.stateField] = $(this).prop('checked');
                });
            };

            BootstrapTable.prototype.resetRows = function () {
                var that = this;

                $.each(this.data, function (i, row) {
                    that.$selectAll.prop('checked', false);
                    that.$selectItem.prop('checked', false);
                    if (that.header.stateField) {
                        row[that.header.stateField] = false;
                    }
                });
                this.initHiddenRows();
            };

            BootstrapTable.prototype.trigger = function (name) {
                var args = Array.prototype.slice.call(arguments, 1);

                name += '.bs.table';
                this.options[BootstrapTable.EVENTS[name]].apply(this.options, args);
                this.$el.trigger($.Event(name), args);

                this.options.onAll(name, args);
                this.$el.trigger($.Event('all.bs.table'), [name, args]);
            };

            BootstrapTable.prototype.resetHeader = function () {
                // fix #61: the hidden table reset header bug.
                // fix bug: get $el.css('width') error sometime (height = 500)
                clearTimeout(this.timeoutId_);
                this.timeoutId_ = setTimeout($.proxy(this.fitHeader, this), this.$el.is(':hidden') ? 100 : 0);
            };

            BootstrapTable.prototype.fitHeader = function () {
                var that = this,
                    fixedBody,
                    scrollWidth,
                    focused,
                    focusedTemp;

                if (that.$el.is(':hidden')) {
                    that.timeoutId_ = setTimeout($.proxy(that.fitHeader, that), 100);
                    return;
                }
                fixedBody = this.$tableBody.get(0);

                scrollWidth = fixedBody.scrollWidth > fixedBody.clientWidth && fixedBody.scrollHeight > fixedBody.clientHeight + this.$header.outerHeight() ? getScrollBarWidth() : 0;

                this.$el.css('margin-top', -this.$header.outerHeight());

                focused = $(':focus');
                if (focused.length > 0) {
                    var $th = focused.parents('th');
                    if ($th.length > 0) {
                        var dataField = $th.attr('data-field');
                        if (dataField !== undefined) {
                            var $headerTh = this.$header.find("[data-field='" + dataField + "']");
                            if ($headerTh.length > 0) {
                                $headerTh.find(":input").addClass("focus-temp");
                            }
                        }
                    }
                }

                this.$header_ = this.$header.clone(true, true);
                this.$selectAll_ = this.$header_.find('[name="btSelectAll"]');
                this.$tableHeader.css({
                    'margin-right': scrollWidth
                }).find('table').css('width', this.$el.outerWidth()).html('').attr('class', this.$el.attr('class')).append(this.$header_);

                focusedTemp = $('.focus-temp:visible:eq(0)');
                if (focusedTemp.length > 0) {
                    focusedTemp.focus();
                    this.$header.find('.focus-temp').removeClass('focus-temp');
                }

                // fix bug: $.data() is not working as expected after $.append()
                this.$header.find('th[data-field]').each(function (i) {
                    that.$header_.find(sprintf('th[data-field="%s"]', $(this).data('field'))).data($(this).data());
                });

                var visibleFields = this.getVisibleFields(),
                    $ths = this.$header_.find('th');

                this.$body.find('>tr:first-child:not(.no-records-found) > *').each(function (i) {
                    var $this = $(this),
                        index = i;

                    if (that.options.detailView && !that.options.cardView) {
                        if (i === 0) {
                            that.$header_.find('th.detail').find('.fht-cell').width($this.innerWidth());
                        }
                        index = i - 1;
                    }

                    var $th = that.$header_.find(sprintf('th[data-field="%s"]', visibleFields[index]));
                    if ($th.length > 1) {
                        $th = $($ths[$this[0].cellIndex]);
                    }

                    $th.find('.fht-cell').width($this.innerWidth());
                });
                // horizontal scroll event
                // TODO: it's probably better improving the layout than binding to scroll event
                this.$tableBody.off('scroll').on('scroll', function () {
                    that.$tableHeader.scrollLeft($(this).scrollLeft());

                    if (that.options.showFooter && !that.options.cardView) {
                        that.$tableFooter.scrollLeft($(this).scrollLeft());
                    }
                });
                that.trigger('post-header');
            };

            BootstrapTable.prototype.resetFooter = function () {
                var that = this,
                    data = that.getData(),
                    html = [];

                if (!this.options.showFooter || this.options.cardView) {
                    //do nothing
                    return;
                }

                if (!this.options.cardView && this.options.detailView) {
                    html.push('<td><div class="th-inner">&nbsp;</div><div class="fht-cell"></div></td>');
                }

                $.each(this.columns, function (i, column) {
                    var key,
                        falign = '',
                        // footer align style
                    valign = '',
                        csses = [],
                        style = {},
                        class_ = sprintf(' class="%s"', column['class']);

                    if (!column.visible) {
                        return;
                    }

                    if (that.options.cardView && !column.cardVisible) {
                        return;
                    }

                    falign = sprintf('text-align: %s; ', column.falign ? column.falign : column.align);
                    valign = sprintf('vertical-align: %s; ', column.valign);

                    style = calculateObjectValue(null, that.options.footerStyle);

                    if (style && style.css) {
                        for (key in style.css) {
                            csses.push(key + ': ' + style.css[key]);
                        }
                    }

                    html.push('<td', class_, sprintf(' style="%s"', falign + valign + csses.concat().join('; ')), '>');
                    html.push('<div class="th-inner">');

                    html.push(calculateObjectValue(column, column.footerFormatter, [data], '&nbsp;') || '&nbsp;');

                    html.push('</div>');
                    html.push('<div class="fht-cell"></div>');
                    html.push('</div>');
                    html.push('</td>');
                });

                this.$tableFooter.find('tr').html(html.join(''));
                this.$tableFooter.show();
                clearTimeout(this.timeoutFooter_);
                this.timeoutFooter_ = setTimeout($.proxy(this.fitFooter, this), this.$el.is(':hidden') ? 100 : 0);
            };

            BootstrapTable.prototype.fitFooter = function () {
                var that = this,
                    $footerTd,
                    elWidth,
                    scrollWidth;

                clearTimeout(this.timeoutFooter_);
                if (this.$el.is(':hidden')) {
                    this.timeoutFooter_ = setTimeout($.proxy(this.fitFooter, this), 100);
                    return;
                }

                elWidth = this.$el.css('width');
                scrollWidth = elWidth > this.$tableBody.width() ? getScrollBarWidth() : 0;

                this.$tableFooter.css({
                    'margin-right': scrollWidth
                }).find('table').css('width', elWidth).attr('class', this.$el.attr('class'));

                $footerTd = this.$tableFooter.find('td');

                this.$body.find('>tr:first-child:not(.no-records-found) > *').each(function (i) {
                    var $this = $(this);

                    $footerTd.eq(i).find('.fht-cell').width($this.innerWidth());
                });
            };

            BootstrapTable.prototype.toggleColumn = function (index, checked, needUpdate) {
                if (index === -1) {
                    return;
                }
                this.columns[index].visible = checked;
                this.initHeader();
                this.initSearch();
                this.initPagination();
                this.initBody();

                if (this.options.showColumns) {
                    var $items = this.$toolbar.find('.keep-open input').prop('disabled', false);

                    if (needUpdate) {
                        $items.filter(sprintf('[value="%s"]', index)).prop('checked', checked);
                    }

                    if ($items.filter(':checked').length <= this.options.minimumCountColumns) {
                        $items.filter(':checked').prop('disabled', true);
                    }
                }
            };

            BootstrapTable.prototype.getVisibleFields = function () {
                var that = this,
                    visibleFields = [];

                $.each(this.header.fields, function (j, field) {
                    var column = that.columns[getFieldIndex(that.columns, field)];

                    if (!column.visible) {
                        return;
                    }
                    visibleFields.push(field);
                });
                return visibleFields;
            };

            // PUBLIC FUNCTION DEFINITION
            // =======================

            BootstrapTable.prototype.resetView = function (params) {
                var padding = 0;

                if (params && params.height) {
                    this.options.height = params.height;
                }

                this.$selectAll.prop('checked', this.$selectItem.length > 0 && this.$selectItem.length === this.$selectItem.filter(':checked').length);

                if (this.options.height) {
                    var toolbarHeight = this.$toolbar.outerHeight(true),
                        paginationHeight = this.$pagination.outerHeight(true),
                        height = this.options.height - toolbarHeight - paginationHeight;

                    this.$tableContainer.css('height', height + 'px');
                }

                if (this.options.cardView) {
                    // remove the element css
                    this.$el.css('margin-top', '0');
                    this.$tableContainer.css('padding-bottom', '0');
                    this.$tableFooter.hide();
                    return;
                }

                if (this.options.showHeader && this.options.height) {
                    this.$tableHeader.show();
                    this.resetHeader();
                    padding += this.$header.outerHeight();
                } else {
                    this.$tableHeader.hide();
                    this.trigger('post-header');
                }

                if (this.options.showFooter) {
                    this.resetFooter();
                    if (this.options.height) {
                        padding += this.$tableFooter.outerHeight() + 1;
                    }
                }

                // Assign the correct sortable arrow
                this.getCaret();
                this.$tableContainer.css('padding-bottom', padding + 'px');
                this.trigger('reset-view');
            };

            BootstrapTable.prototype.getData = function (useCurrentPage) {
                return this.searchText || !$.isEmptyObject(this.filterColumns) || !$.isEmptyObject(this.filterColumnsPartial) ? useCurrentPage ? this.data.slice(this.pageFrom - 1, this.pageTo) : this.data : useCurrentPage ? this.options.data.slice(this.pageFrom - 1, this.pageTo) : this.options.data;
            };

            BootstrapTable.prototype.load = function (data) {
                var fixedScroll = false;

                // #431: support pagination
                if (this.options.sidePagination === 'server') {
                    this.options.totalRows = data[this.options.totalField];
                    fixedScroll = data.fixedScroll;
                    data = data[this.options.dataField];
                } else if (!$.isArray(data)) {
                    // support fixedScroll
                    fixedScroll = data.fixedScroll;
                    data = data.data;
                }

                this.initData(data);
                this.initSearch();
                this.initPagination();
                this.initBody(fixedScroll);
            };

            BootstrapTable.prototype.append = function (data) {
                this.initData(data, 'append');
                this.initSearch();
                this.initPagination();
                this.initSort();
                this.initBody(true);
            };

            BootstrapTable.prototype.prepend = function (data) {
                this.initData(data, 'prepend');
                this.initSearch();
                this.initPagination();
                this.initSort();
                this.initBody(true);
            };

            BootstrapTable.prototype.remove = function (params) {
                var len = this.options.data.length,
                    i,
                    row;

                if (!params.hasOwnProperty('field') || !params.hasOwnProperty('values')) {
                    return;
                }

                for (i = len - 1; i >= 0; i--) {
                    row = this.options.data[i];

                    if (!row.hasOwnProperty(params.field)) {
                        continue;
                    }
                    if ($.inArray(row[params.field], params.values) !== -1) {
                        this.options.data.splice(i, 1);
                        if (this.options.sidePagination === 'server') {
                            this.options.totalRows -= 1;
                        }
                    }
                }

                if (len === this.options.data.length) {
                    return;
                }

                this.initSearch();
                this.initPagination();
                this.initSort();
                this.initBody(true);
            };

            BootstrapTable.prototype.removeAll = function () {
                if (this.options.data.length > 0) {
                    this.options.data.splice(0, this.options.data.length);
                    this.initSearch();
                    this.initPagination();
                    this.initBody(true);
                }
            };

            BootstrapTable.prototype.getRowByUniqueId = function (id) {
                var uniqueId = this.options.uniqueId,
                    len = this.options.data.length,
                    dataRow = null,
                    i,
                    row,
                    rowUniqueId;

                for (i = len - 1; i >= 0; i--) {
                    row = this.options.data[i];

                    if (row.hasOwnProperty(uniqueId)) {
                        // uniqueId is a column
                        rowUniqueId = row[uniqueId];
                    } else if (row._data.hasOwnProperty(uniqueId)) {
                        // uniqueId is a row data property
                        rowUniqueId = row._data[uniqueId];
                    } else {
                        continue;
                    }

                    if (typeof rowUniqueId === 'string') {
                        id = id.toString();
                    } else if (typeof rowUniqueId === 'number') {
                        if (Number(rowUniqueId) === rowUniqueId && rowUniqueId % 1 === 0) {
                            id = parseInt(id);
                        } else if (rowUniqueId === Number(rowUniqueId) && rowUniqueId !== 0) {
                            id = parseFloat(id);
                        }
                    }

                    if (rowUniqueId === id) {
                        dataRow = row;
                        break;
                    }
                }

                return dataRow;
            };

            BootstrapTable.prototype.removeByUniqueId = function (id) {
                var len = this.options.data.length,
                    row = this.getRowByUniqueId(id);

                if (row) {
                    this.options.data.splice(this.options.data.indexOf(row), 1);
                }

                if (len === this.options.data.length) {
                    return;
                }

                this.initSearch();
                this.initPagination();
                this.initBody(true);
            };

            BootstrapTable.prototype.updateByUniqueId = function (params) {
                var that = this;
                var allParams = $.isArray(params) ? params : [params];

                $.each(allParams, function (i, params) {
                    var rowId;

                    if (!params.hasOwnProperty('id') || !params.hasOwnProperty('row')) {
                        return;
                    }

                    rowId = $.inArray(that.getRowByUniqueId(params.id), that.options.data);

                    if (rowId === -1) {
                        return;
                    }
                    $.extend(that.options.data[rowId], params.row);
                });

                this.initSearch();
                this.initPagination();
                this.initSort();
                this.initBody(true);
            };

            BootstrapTable.prototype.insertRow = function (params) {
                if (!params.hasOwnProperty('index') || !params.hasOwnProperty('row')) {
                    return;
                }
                this.data.splice(params.index, 0, params.row);
                this.initSearch();
                this.initPagination();
                this.initSort();
                this.initBody(true);
            };

            BootstrapTable.prototype.updateRow = function (params) {
                var that = this;
                var allParams = $.isArray(params) ? params : [params];

                $.each(allParams, function (i, params) {
                    if (!params.hasOwnProperty('index') || !params.hasOwnProperty('row')) {
                        return;
                    }
                    $.extend(that.options.data[params.index], params.row);
                });

                this.initSearch();
                this.initPagination();
                this.initSort();
                this.initBody(true);
            };

            BootstrapTable.prototype.initHiddenRows = function () {
                this.hiddenRows = [];
            };

            BootstrapTable.prototype.showRow = function (params) {
                this.toggleRow(params, true);
            };

            BootstrapTable.prototype.hideRow = function (params) {
                this.toggleRow(params, false);
            };

            BootstrapTable.prototype.toggleRow = function (params, visible) {
                var row, index;

                if (params.hasOwnProperty('index')) {
                    row = this.getData()[params.index];
                } else if (params.hasOwnProperty('uniqueId')) {
                    row = this.getRowByUniqueId(params.uniqueId);
                }

                if (!row) {
                    return;
                }

                index = $.inArray(row, this.hiddenRows);

                if (!visible && index === -1) {
                    this.hiddenRows.push(row);
                } else if (visible && index > -1) {
                    this.hiddenRows.splice(index, 1);
                }
                this.initBody(true);
            };

            BootstrapTable.prototype.getHiddenRows = function (show) {
                var that = this,
                    data = this.getData(),
                    rows = [];

                $.each(data, function (i, row) {
                    if ($.inArray(row, that.hiddenRows) > -1) {
                        rows.push(row);
                    }
                });
                this.hiddenRows = rows;
                return rows;
            };

            BootstrapTable.prototype.mergeCells = function (options) {
                var row = options.index,
                    col = $.inArray(options.field, this.getVisibleFields()),
                    rowspan = options.rowspan || 1,
                    colspan = options.colspan || 1,
                    i,
                    j,
                    $tr = this.$body.find('>tr'),
                    $td;

                if (this.options.detailView && !this.options.cardView) {
                    col += 1;
                }

                $td = $tr.eq(row).find('>td').eq(col);

                if (row < 0 || col < 0 || row >= this.data.length) {
                    return;
                }

                for (i = row; i < row + rowspan; i++) {
                    for (j = col; j < col + colspan; j++) {
                        $tr.eq(i).find('>td').eq(j).hide();
                    }
                }

                $td.attr('rowspan', rowspan).attr('colspan', colspan).show();
            };

            BootstrapTable.prototype.updateCell = function (params) {
                if (!params.hasOwnProperty('index') || !params.hasOwnProperty('field') || !params.hasOwnProperty('value')) {
                    return;
                }
                this.data[params.index][params.field] = params.value;

                if (params.reinit === false) {
                    return;
                }
                this.initSort();
                this.initBody(true);
            };

            BootstrapTable.prototype.getOptions = function () {
                return this.options;
            };

            BootstrapTable.prototype.getSelections = function () {
                var that = this;

                return $.grep(this.options.data, function (row) {
                    // fix #2424: from html with checkbox
                    return row[that.header.stateField] === true;
                });
            };

            BootstrapTable.prototype.getAllSelections = function () {
                var that = this;

                return $.grep(this.options.data, function (row) {
                    return row[that.header.stateField];
                });
            };

            BootstrapTable.prototype.checkAll = function () {
                this.checkAll_(true);
            };

            BootstrapTable.prototype.uncheckAll = function () {
                this.checkAll_(false);
            };

            BootstrapTable.prototype.checkInvert = function () {
                var that = this;
                var rows = that.$selectItem.filter(':enabled');
                var checked = rows.filter(':checked');
                rows.each(function () {
                    $(this).prop('checked', !$(this).prop('checked'));
                });
                that.updateRows();
                that.updateSelected();
                that.trigger('uncheck-some', checked);
                checked = that.getSelections();
                that.trigger('check-some', checked);
            };

            BootstrapTable.prototype.checkAll_ = function (checked) {
                var rows;
                if (!checked) {
                    rows = this.getSelections();
                }
                this.$selectAll.add(this.$selectAll_).prop('checked', checked);
                this.$selectItem.filter(':enabled').prop('checked', checked);
                this.updateRows();
                if (checked) {
                    rows = this.getSelections();
                }
                this.trigger(checked ? 'check-all' : 'uncheck-all', rows);
            };

            BootstrapTable.prototype.check = function (index) {
                this.check_(true, index);
            };

            BootstrapTable.prototype.uncheck = function (index) {
                this.check_(false, index);
            };

            BootstrapTable.prototype.check_ = function (checked, index) {
                var $el = this.$selectItem.filter(sprintf('[data-index="%s"]', index)).prop('checked', checked);
                this.data[index][this.header.stateField] = checked;
                this.updateSelected();
                this.trigger(checked ? 'check' : 'uncheck', this.data[index], $el);
            };

            BootstrapTable.prototype.checkBy = function (obj) {
                this.checkBy_(true, obj);
            };

            BootstrapTable.prototype.uncheckBy = function (obj) {
                this.checkBy_(false, obj);
            };

            BootstrapTable.prototype.checkBy_ = function (checked, obj) {
                if (!obj.hasOwnProperty('field') || !obj.hasOwnProperty('values')) {
                    return;
                }

                var that = this,
                    rows = [];
                $.each(this.options.data, function (index, row) {
                    if (!row.hasOwnProperty(obj.field)) {
                        return false;
                    }
                    if ($.inArray(row[obj.field], obj.values) !== -1) {
                        var $el = that.$selectItem.filter(':enabled').filter(sprintf('[data-index="%s"]', index)).prop('checked', checked);
                        row[that.header.stateField] = checked;
                        rows.push(row);
                        that.trigger(checked ? 'check' : 'uncheck', row, $el);
                    }
                });
                this.updateSelected();
                this.trigger(checked ? 'check-some' : 'uncheck-some', rows);
            };

            BootstrapTable.prototype.destroy = function () {
                this.$el.insertBefore(this.$container);
                $(this.options.toolbar).insertBefore(this.$el);
                this.$container.next().remove();
                this.$container.remove();
                this.$el.html(this.$el_.html()).css('margin-top', '0').attr('class', this.$el_.attr('class') || ''); // reset the class
            };

            BootstrapTable.prototype.showLoading = function () {
                this.$tableLoading.show();
            };

            BootstrapTable.prototype.hideLoading = function () {
                this.$tableLoading.hide();
            };

            BootstrapTable.prototype.togglePagination = function () {
                this.options.pagination = !this.options.pagination;
                var button = this.$toolbar.find('button[name="paginationSwitch"] i');
                if (this.options.pagination) {
                    button.attr("class", this.options.iconsPrefix + " " + this.options.icons.paginationSwitchDown);
                } else {
                    button.attr("class", this.options.iconsPrefix + " " + this.options.icons.paginationSwitchUp);
                }
                this.updatePagination();
            };

            BootstrapTable.prototype.refresh = function (params) {
                if (params && params.url) {
                    this.options.url = params.url;
                }
                if (params && params.pageNumber) {
                    this.options.pageNumber = params.pageNumber;
                }
                if (params && params.pageSize) {
                    this.options.pageSize = params.pageSize;
                }
                this.initServer(params && params.silent, params && params.query, params && params.url);
                this.trigger('refresh', params);
            };

            BootstrapTable.prototype.resetWidth = function () {
                if (this.options.showHeader && this.options.height) {
                    this.fitHeader();
                }
                if (this.options.showFooter) {
                    this.fitFooter();
                }
            };

            BootstrapTable.prototype.showColumn = function (field) {
                this.toggleColumn(getFieldIndex(this.columns, field), true, true);
            };

            BootstrapTable.prototype.hideColumn = function (field) {
                this.toggleColumn(getFieldIndex(this.columns, field), false, true);
            };

            BootstrapTable.prototype.getHiddenColumns = function () {
                return $.grep(this.columns, function (column) {
                    return !column.visible;
                });
            };

            BootstrapTable.prototype.getVisibleColumns = function () {
                return $.grep(this.columns, function (column) {
                    return column.visible;
                });
            };

            BootstrapTable.prototype.toggleAllColumns = function (visible) {
                $.each(this.columns, function (i, column) {
                    this.columns[i].visible = visible;
                });

                this.initHeader();
                this.initSearch();
                this.initPagination();
                this.initBody();
                if (this.options.showColumns) {
                    var $items = this.$toolbar.find('.keep-open input').prop('disabled', false);

                    if ($items.filter(':checked').length <= this.options.minimumCountColumns) {
                        $items.filter(':checked').prop('disabled', true);
                    }
                }
            };

            BootstrapTable.prototype.showAllColumns = function () {
                this.toggleAllColumns(true);
            };

            BootstrapTable.prototype.hideAllColumns = function () {
                this.toggleAllColumns(false);
            };

            BootstrapTable.prototype.filterBy = function (columns) {
                this.filterColumns = $.isEmptyObject(columns) ? {} : columns;
                this.options.pageNumber = 1;
                this.initSearch();
                this.updatePagination();
            };

            BootstrapTable.prototype.scrollTo = function (value) {
                if (typeof value === 'string') {
                    value = value === 'bottom' ? this.$tableBody[0].scrollHeight : 0;
                }
                if (typeof value === 'number') {
                    this.$tableBody.scrollTop(value);
                }
                if (typeof value === 'undefined') {
                    return this.$tableBody.scrollTop();
                }
            };

            BootstrapTable.prototype.getScrollPosition = function () {
                return this.scrollTo();
            };

            BootstrapTable.prototype.selectPage = function (page) {
                if (page > 0 && page <= this.options.totalPages) {
                    this.options.pageNumber = page;
                    this.updatePagination();
                }
            };

            BootstrapTable.prototype.prevPage = function () {
                if (this.options.pageNumber > 1) {
                    this.options.pageNumber--;
                    this.updatePagination();
                }
            };

            BootstrapTable.prototype.nextPage = function () {
                if (this.options.pageNumber < this.options.totalPages) {
                    this.options.pageNumber++;
                    this.updatePagination();
                }
            };

            BootstrapTable.prototype.toggleView = function () {
                this.options.cardView = !this.options.cardView;
                this.initHeader();
                // Fixed remove toolbar when click cardView button.
                //that.initToolbar();
                this.initBody();
                this.trigger('toggle', this.options.cardView);
            };

            BootstrapTable.prototype.refreshOptions = function (options) {
                //If the objects are equivalent then avoid the call of destroy / init methods
                if (compareObjects(this.options, options, true)) {
                    return;
                }
                this.options = $.extend(this.options, options);
                this.trigger('refresh-options', this.options);
                this.destroy();
                this.init();
            };

            BootstrapTable.prototype.resetSearch = function (text) {
                var $search = this.$toolbar.find('.search input');
                $search.val(text || '');
                this.onSearch({ currentTarget: $search });
            };

            BootstrapTable.prototype.expandRow_ = function (expand, index) {
                var $tr = this.$body.find(sprintf('> tr[data-index="%s"]', index));
                if ($tr.next().is('tr.detail-view') === (expand ? false : true)) {
                    $tr.find('> td > .detail-icon').click();
                }
            };

            BootstrapTable.prototype.expandRow = function (index) {
                this.expandRow_(true, index);
            };

            BootstrapTable.prototype.collapseRow = function (index) {
                this.expandRow_(false, index);
            };

            BootstrapTable.prototype.expandAllRows = function (isSubTable) {
                if (isSubTable) {
                    var $tr = this.$body.find(sprintf('> tr[data-index="%s"]', 0)),
                        that = this,
                        detailIcon = null,
                        executeInterval = false,
                        idInterval = -1;

                    if (!$tr.next().is('tr.detail-view')) {
                        $tr.find('> td > .detail-icon').click();
                        executeInterval = true;
                    } else if (!$tr.next().next().is('tr.detail-view')) {
                        $tr.next().find(".detail-icon").click();
                        executeInterval = true;
                    }

                    if (executeInterval) {
                        try {
                            idInterval = setInterval(function () {
                                detailIcon = that.$body.find("tr.detail-view").last().find(".detail-icon");
                                if (detailIcon.length > 0) {
                                    detailIcon.click();
                                } else {
                                    clearInterval(idInterval);
                                }
                            }, 1);
                        } catch (ex) {
                            clearInterval(idInterval);
                        }
                    }
                } else {
                    var trs = this.$body.children();
                    for (var i = 0; i < trs.length; i++) {
                        this.expandRow_(true, $(trs[i]).data("index"));
                    }
                }
            };

            BootstrapTable.prototype.collapseAllRows = function (isSubTable) {
                if (isSubTable) {
                    this.expandRow_(false, 0);
                } else {
                    var trs = this.$body.children();
                    for (var i = 0; i < trs.length; i++) {
                        this.expandRow_(false, $(trs[i]).data("index"));
                    }
                }
            };

            BootstrapTable.prototype.updateFormatText = function (name, text) {
                if (this.options[sprintf('format%s', name)]) {
                    if (typeof text === 'string') {
                        this.options[sprintf('format%s', name)] = function () {
                            return text;
                        };
                    } else if (typeof text === 'function') {
                        this.options[sprintf('format%s', name)] = text;
                    }
                }
                this.initToolbar();
                this.initPagination();
                this.initBody();
            };

            // BOOTSTRAP TABLE PLUGIN DEFINITION
            // =======================

            var allowedMethods = ['getOptions', 'getSelections', 'getAllSelections', 'getData', 'load', 'append', 'prepend', 'remove', 'removeAll', 'insertRow', 'updateRow', 'updateCell', 'updateByUniqueId', 'removeByUniqueId', 'getRowByUniqueId', 'showRow', 'hideRow', 'getHiddenRows', 'mergeCells', 'checkAll', 'uncheckAll', 'checkInvert', 'check', 'uncheck', 'checkBy', 'uncheckBy', 'refresh', 'resetView', 'resetWidth', 'destroy', 'showLoading', 'hideLoading', 'showColumn', 'hideColumn', 'getHiddenColumns', 'getVisibleColumns', 'showAllColumns', 'hideAllColumns', 'filterBy', 'scrollTo', 'getScrollPosition', 'selectPage', 'prevPage', 'nextPage', 'togglePagination', 'toggleView', 'refreshOptions', 'resetSearch', 'expandRow', 'collapseRow', 'expandAllRows', 'collapseAllRows', 'updateFormatText'];

            $.fn.bootstrapTable = function (option) {
                var value,
                    args = Array.prototype.slice.call(arguments, 1);

                this.each(function () {
                    var $this = $(this),
                        data = $this.data('bootstrap.table'),
                        options = $.extend({}, BootstrapTable.DEFAULTS, $this.data(), typeof option === 'object' && option);

                    if (typeof option === 'string') {
                        if ($.inArray(option, allowedMethods) < 0) {
                            throw new Error("Unknown method: " + option);
                        }

                        if (!data) {
                            return;
                        }

                        value = data[option].apply(data, args);

                        if (option === 'destroy') {
                            $this.removeData('bootstrap.table');
                        }
                    }

                    if (!data) {
                        $this.data('bootstrap.table', data = new BootstrapTable(this, options));
                    }
                });

                return typeof value === 'undefined' ? this : value;
            };

            $.fn.bootstrapTable.Constructor = BootstrapTable;
            $.fn.bootstrapTable.defaults = BootstrapTable.DEFAULTS;
            $.fn.bootstrapTable.columnDefaults = BootstrapTable.COLUMN_DEFAULTS;
            $.fn.bootstrapTable.locales = BootstrapTable.LOCALES;
            $.fn.bootstrapTable.methods = allowedMethods;
            $.fn.bootstrapTable.utils = {
                sprintf: sprintf,
                getFieldIndex: getFieldIndex,
                compareObjects: compareObjects,
                calculateObjectValue: calculateObjectValue,
                getItemField: getItemField,
                objectKeys: objectKeys,
                isIEBrowser: isIEBrowser
            };

            // BOOTSTRAP TABLE INIT
            // =======================

            $(function () {
                $('[data-toggle="table"]').bootstrapTable();
            });
        })(jQuery);
    })(this);

    return _retrieveGlobal();
});
System.registerDynamic("npm:x-editable@1.5.1.json", [], true, function() {
  return {
    "format": "global",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "CHANGELOG.txt": {
        "globals": {
          "process": null
        }
      },
      "Gruntfile.js": {
        "globals": {
          "process": null
        }
      },
      "LICENSE-MIT": {
        "globals": {
          "process": null
        }
      },
      "Package.nuspec": {
        "globals": {
          "process": null
        }
      },
      "dist/*": {
        "globals": {
          "process": null
        }
      },
      "src/*": {
        "globals": {
          "process": null
        }
      },
      "test/*": {
        "globals": {
          "process": null
        }
      }
    }
  };
});

System.registerDynamic('npm:x-editable@1.5.1/dist/bootstrap3-editable/js/bootstrap-editable.js', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = System.registry.get("@@global-helpers").prepareGlobal($__module.id, null, {});

    (function ($__global) {
        /*! X-editable - v1.5.1 
        * In-place editing with Twitter Bootstrap, jQuery UI or pure jQuery
        * http://github.com/vitalets/x-editable
        * Copyright (c) 2013 Vitaliy Potapov; Licensed MIT */
        /**
        Form with single input element, two buttons and two states: normal/loading.
        Applied as jQuery method to DIV tag (not to form tag!). This is because form can be in loading state when spinner shown.
        Editableform is linked with one of input types, e.g. 'text', 'select' etc.
        
        @class editableform
        @uses text
        @uses textarea
        **/
        (function ($) {
            "use strict";

            var EditableForm = function (div, options) {
                this.options = $.extend({}, $.fn.editableform.defaults, options);
                this.$div = $(div); //div, containing form. Not form tag. Not editable-element.
                if (!this.options.scope) {
                    this.options.scope = this;
                }
                //nothing shown after init
            };

            EditableForm.prototype = {
                constructor: EditableForm,
                initInput: function () {
                    //called once
                    //take input from options (as it is created in editable-element)
                    this.input = this.options.input;

                    //set initial value
                    //todo: may be add check: typeof str === 'string' ? 
                    this.value = this.input.str2value(this.options.value);

                    //prerender: get input.$input
                    this.input.prerender();
                },
                initTemplate: function () {
                    this.$form = $($.fn.editableform.template);
                },
                initButtons: function () {
                    var $btn = this.$form.find('.editable-buttons');
                    $btn.append($.fn.editableform.buttons);
                    if (this.options.showbuttons === 'bottom') {
                        $btn.addClass('editable-buttons-bottom');
                    }
                },
                /**
                Renders editableform
                 @method render
                **/
                render: function () {
                    //init loader
                    this.$loading = $($.fn.editableform.loading);
                    this.$div.empty().append(this.$loading);

                    //init form template and buttons
                    this.initTemplate();
                    if (this.options.showbuttons) {
                        this.initButtons();
                    } else {
                        this.$form.find('.editable-buttons').remove();
                    }

                    //show loading state
                    this.showLoading();

                    //flag showing is form now saving value to server. 
                    //It is needed to wait when closing form.
                    this.isSaving = false;

                    /**        
                    Fired when rendering starts
                    @event rendering 
                    @param {Object} event event object
                    **/
                    this.$div.triggerHandler('rendering');

                    //init input
                    this.initInput();

                    //append input to form
                    this.$form.find('div.editable-input').append(this.input.$tpl);

                    //append form to container
                    this.$div.append(this.$form);

                    //render input
                    $.when(this.input.render()).then($.proxy(function () {
                        //setup input to submit automatically when no buttons shown
                        if (!this.options.showbuttons) {
                            this.input.autosubmit();
                        }

                        //attach 'cancel' handler
                        this.$form.find('.editable-cancel').click($.proxy(this.cancel, this));

                        if (this.input.error) {
                            this.error(this.input.error);
                            this.$form.find('.editable-submit').attr('disabled', true);
                            this.input.$input.attr('disabled', true);
                            //prevent form from submitting
                            this.$form.submit(function (e) {
                                e.preventDefault();
                            });
                        } else {
                            this.error(false);
                            this.input.$input.removeAttr('disabled');
                            this.$form.find('.editable-submit').removeAttr('disabled');
                            var value = this.value === null || this.value === undefined || this.value === '' ? this.options.defaultValue : this.value;
                            this.input.value2input(value);
                            //attach submit handler
                            this.$form.submit($.proxy(this.submit, this));
                        }

                        /**        
                        Fired when form is rendered
                        @event rendered
                        @param {Object} event event object
                        **/
                        this.$div.triggerHandler('rendered');

                        this.showForm();

                        //call postrender method to perform actions required visibility of form
                        if (this.input.postrender) {
                            this.input.postrender();
                        }
                    }, this));
                },
                cancel: function () {
                    /**        
                    Fired when form was cancelled by user
                    @event cancel 
                    @param {Object} event event object
                    **/
                    this.$div.triggerHandler('cancel');
                },
                showLoading: function () {
                    var w, h;
                    if (this.$form) {
                        //set loading size equal to form
                        w = this.$form.outerWidth();
                        h = this.$form.outerHeight();
                        if (w) {
                            this.$loading.width(w);
                        }
                        if (h) {
                            this.$loading.height(h);
                        }
                        this.$form.hide();
                    } else {
                        //stretch loading to fill container width
                        w = this.$loading.parent().width();
                        if (w) {
                            this.$loading.width(w);
                        }
                    }
                    this.$loading.show();
                },

                showForm: function (activate) {
                    this.$loading.hide();
                    this.$form.show();
                    if (activate !== false) {
                        this.input.activate();
                    }
                    /**        
                    Fired when form is shown
                    @event show 
                    @param {Object} event event object
                    **/
                    this.$div.triggerHandler('show');
                },

                error: function (msg) {
                    var $group = this.$form.find('.control-group'),
                        $block = this.$form.find('.editable-error-block'),
                        lines;

                    if (msg === false) {
                        $group.removeClass($.fn.editableform.errorGroupClass);
                        $block.removeClass($.fn.editableform.errorBlockClass).empty().hide();
                    } else {
                        //convert newline to <br> for more pretty error display
                        if (msg) {
                            lines = ('' + msg).split('\n');
                            for (var i = 0; i < lines.length; i++) {
                                lines[i] = $('<div>').text(lines[i]).html();
                            }
                            msg = lines.join('<br>');
                        }
                        $group.addClass($.fn.editableform.errorGroupClass);
                        $block.addClass($.fn.editableform.errorBlockClass).html(msg).show();
                    }
                },

                submit: function (e) {
                    e.stopPropagation();
                    e.preventDefault();

                    //get new value from input
                    var newValue = this.input.input2value();

                    //validation: if validate returns string or truthy value - means error
                    //if returns object like {newValue: '...'} => submitted value is reassigned to it
                    var error = this.validate(newValue);
                    if ($.type(error) === 'object' && error.newValue !== undefined) {
                        newValue = error.newValue;
                        this.input.value2input(newValue);
                        if (typeof error.msg === 'string') {
                            this.error(error.msg);
                            this.showForm();
                            return;
                        }
                    } else if (error) {
                        this.error(error);
                        this.showForm();
                        return;
                    }

                    //if value not changed --> trigger 'nochange' event and return
                    /*jslint eqeq: true*/
                    if (!this.options.savenochange && this.input.value2str(newValue) == this.input.value2str(this.value)) {
                        /*jslint eqeq: false*/
                        /**        
                        Fired when value not changed but form is submitted. Requires savenochange = false.
                        @event nochange 
                        @param {Object} event event object
                        **/
                        this.$div.triggerHandler('nochange');
                        return;
                    }

                    //convert value for submitting to server
                    var submitValue = this.input.value2submit(newValue);

                    this.isSaving = true;

                    //sending data to server
                    $.when(this.save(submitValue)).done($.proxy(function (response) {
                        this.isSaving = false;

                        //run success callback
                        var res = typeof this.options.success === 'function' ? this.options.success.call(this.options.scope, response, newValue) : null;

                        //if success callback returns false --> keep form open and do not activate input
                        if (res === false) {
                            this.error(false);
                            this.showForm(false);
                            return;
                        }

                        //if success callback returns string -->  keep form open, show error and activate input               
                        if (typeof res === 'string') {
                            this.error(res);
                            this.showForm();
                            return;
                        }

                        //if success callback returns object like {newValue: <something>} --> use that value instead of submitted
                        //it is usefull if you want to chnage value in url-function
                        if (res && typeof res === 'object' && res.hasOwnProperty('newValue')) {
                            newValue = res.newValue;
                        }

                        //clear error message
                        this.error(false);
                        this.value = newValue;
                        /**        
                        Fired when form is submitted
                        @event save 
                        @param {Object} event event object
                        @param {Object} params additional params
                        @param {mixed} params.newValue raw new value
                        @param {mixed} params.submitValue submitted value as string
                        @param {Object} params.response ajax response
                         @example
                        $('#form-div').on('save'), function(e, params){
                            if(params.newValue === 'username') {...}
                        });
                        **/
                        this.$div.triggerHandler('save', { newValue: newValue, submitValue: submitValue, response: response });
                    }, this)).fail($.proxy(function (xhr) {
                        this.isSaving = false;

                        var msg;
                        if (typeof this.options.error === 'function') {
                            msg = this.options.error.call(this.options.scope, xhr, newValue);
                        } else {
                            msg = typeof xhr === 'string' ? xhr : xhr.responseText || xhr.statusText || 'Unknown error!';
                        }

                        this.error(msg);
                        this.showForm();
                    }, this));
                },

                save: function (submitValue) {
                    //try parse composite pk defined as json string in data-pk 
                    this.options.pk = $.fn.editableutils.tryParseJson(this.options.pk, true);

                    var pk = typeof this.options.pk === 'function' ? this.options.pk.call(this.options.scope) : this.options.pk,

                    /*
                      send on server in following cases:
                      1. url is function
                      2. url is string AND (pk defined OR send option = always) 
                    */
                    send = !!(typeof this.options.url === 'function' || this.options.url && (this.options.send === 'always' || this.options.send === 'auto' && pk !== null && pk !== undefined)),
                        params;

                    if (send) {
                        //send to server
                        this.showLoading();

                        //standard params
                        params = {
                            name: this.options.name || '',
                            value: submitValue,
                            pk: pk
                        };

                        //additional params
                        if (typeof this.options.params === 'function') {
                            params = this.options.params.call(this.options.scope, params);
                        } else {
                            //try parse json in single quotes (from data-params attribute)
                            this.options.params = $.fn.editableutils.tryParseJson(this.options.params, true);
                            $.extend(params, this.options.params);
                        }

                        if (typeof this.options.url === 'function') {
                            //user's function
                            return this.options.url.call(this.options.scope, params);
                        } else {
                            //send ajax to server and return deferred object
                            return $.ajax($.extend({
                                url: this.options.url,
                                data: params,
                                type: 'POST'
                            }, this.options.ajaxOptions));
                        }
                    }
                },

                validate: function (value) {
                    if (value === undefined) {
                        value = this.value;
                    }
                    if (typeof this.options.validate === 'function') {
                        return this.options.validate.call(this.options.scope, value);
                    }
                },

                option: function (key, value) {
                    if (key in this.options) {
                        this.options[key] = value;
                    }

                    if (key === 'value') {
                        this.setValue(value);
                    }

                    //do not pass option to input as it is passed in editable-element
                },

                setValue: function (value, convertStr) {
                    if (convertStr) {
                        this.value = this.input.str2value(value);
                    } else {
                        this.value = value;
                    }

                    //if form is visible, update input
                    if (this.$form && this.$form.is(':visible')) {
                        this.input.value2input(this.value);
                    }
                }
            };

            /*
            Initialize editableform. Applied to jQuery object.
             @method $().editableform(options)
            @params {Object} options
            @example
            var $form = $('&lt;div&gt;').editableform({
                type: 'text',
                name: 'username',
                url: '/post',
                value: 'vitaliy'
            });
             //to display form you should call 'render' method
            $form.editableform('render');     
            */
            $.fn.editableform = function (option) {
                var args = arguments;
                return this.each(function () {
                    var $this = $(this),
                        data = $this.data('editableform'),
                        options = typeof option === 'object' && option;
                    if (!data) {
                        $this.data('editableform', data = new EditableForm(this, options));
                    }

                    if (typeof option === 'string') {
                        //call method 
                        data[option].apply(data, Array.prototype.slice.call(args, 1));
                    }
                });
            };

            //keep link to constructor to allow inheritance
            $.fn.editableform.Constructor = EditableForm;

            //defaults
            $.fn.editableform.defaults = {
                /* see also defaults for input */

                /**
                Type of input. Can be <code>text|textarea|select|date|checklist</code>
                 @property type 
                @type string
                @default 'text'
                **/
                type: 'text',
                /**
                Url for submit, e.g. <code>'/post'</code>  
                If function - it will be called instead of ajax. Function should return deferred object to run fail/done callbacks.
                 @property url 
                @type string|function
                @default null
                @example
                url: function(params) {
                    var d = new $.Deferred;
                    if(params.value === 'abc') {
                        return d.reject('error message'); //returning error via deferred object
                    } else {
                        //async saving data in js model
                        someModel.asyncSaveMethod({
                           ..., 
                           success: function(){
                              d.resolve();
                           }
                        }); 
                        return d.promise();
                    }
                } 
                **/
                url: null,
                /**
                Additional params for submit. If defined as <code>object</code> - it is **appended** to original ajax data (pk, name and value).  
                If defined as <code>function</code> - returned object **overwrites** original ajax data.
                @example
                params: function(params) {
                    //originally params contain pk, name and value
                    params.a = 1;
                    return params;
                }
                 @property params 
                @type object|function
                @default null
                **/
                params: null,
                /**
                Name of field. Will be submitted on server. Can be taken from <code>id</code> attribute
                 @property name 
                @type string
                @default null
                **/
                name: null,
                /**
                Primary key of editable object (e.g. record id in database). For composite keys use object, e.g. <code>{id: 1, lang: 'en'}</code>.
                Can be calculated dynamically via function.
                 @property pk 
                @type string|object|function
                @default null
                **/
                pk: null,
                /**
                Initial value. If not defined - will be taken from element's content.
                For __select__ type should be defined (as it is ID of shown text).
                 @property value 
                @type string|object
                @default null
                **/
                value: null,
                /**
                Value that will be displayed in input if original field value is empty (`null|undefined|''`).
                 @property defaultValue 
                @type string|object
                @default null
                @since 1.4.6
                **/
                defaultValue: null,
                /**
                Strategy for sending data on server. Can be `auto|always|never`.
                When 'auto' data will be sent on server **only if pk and url defined**, otherwise new value will be stored locally.
                 @property send 
                @type string
                @default 'auto'
                **/
                send: 'auto',
                /**
                Function for client-side validation. If returns string - means validation not passed and string showed as error.
                Since 1.5.1 you can modify submitted value by returning object from `validate`: 
                `{newValue: '...'}` or `{newValue: '...', msg: '...'}`
                 @property validate 
                @type function
                @default null
                @example
                validate: function(value) {
                    if($.trim(value) == '') {
                        return 'This field is required';
                    }
                }
                **/
                validate: null,
                /**
                Success callback. Called when value successfully sent on server and **response status = 200**.  
                Usefull to work with json response. For example, if your backend response can be <code>{success: true}</code>
                or <code>{success: false, msg: "server error"}</code> you can check it inside this callback.  
                If it returns **string** - means error occured and string is shown as error message.  
                If it returns **object like** <code>{newValue: &lt;something&gt;}</code> - it overwrites value, submitted by user.  
                Otherwise newValue simply rendered into element.
                
                @property success 
                @type function
                @default null
                @example
                success: function(response, newValue) {
                    if(!response.success) return response.msg;
                }
                **/
                success: null,
                /**
                Error callback. Called when request failed (response status != 200).  
                Usefull when you want to parse error response and display a custom message.
                Must return **string** - the message to be displayed in the error block.
                        
                @property error 
                @type function
                @default null
                @since 1.4.4
                @example
                error: function(response, newValue) {
                    if(response.status === 500) {
                        return 'Service unavailable. Please try later.';
                    } else {
                        return response.responseText;
                    }
                }
                **/
                error: null,
                /**
                Additional options for submit ajax request.
                List of values: http://api.jquery.com/jQuery.ajax
                
                @property ajaxOptions 
                @type object
                @default null
                @since 1.1.1        
                @example 
                ajaxOptions: {
                    type: 'put',
                    dataType: 'json'
                }        
                **/
                ajaxOptions: null,
                /**
                Where to show buttons: left(true)|bottom|false  
                Form without buttons is auto-submitted.
                 @property showbuttons 
                @type boolean|string
                @default true
                @since 1.1.1
                **/
                showbuttons: true,
                /**
                Scope for callback methods (success, validate).  
                If <code>null</code> means editableform instance itself. 
                 @property scope 
                @type DOMElement|object
                @default null
                @since 1.2.0
                @private
                **/
                scope: null,
                /**
                Whether to save or cancel value when it was not changed but form was submitted
                 @property savenochange 
                @type boolean
                @default false
                @since 1.2.0
                **/
                savenochange: false
            };

            /*
            Note: following params could redefined in engine: bootstrap or jqueryui:
            Classes 'control-group' and 'editable-error-block' must always present!
            */
            $.fn.editableform.template = '<form class="form-inline editableform">' + '<div class="control-group">' + '<div><div class="editable-input"></div><div class="editable-buttons"></div></div>' + '<div class="editable-error-block"></div>' + '</div>' + '</form>';

            //loading div
            $.fn.editableform.loading = '<div class="editableform-loading"></div>';

            //buttons
            $.fn.editableform.buttons = '<button type="submit" class="editable-submit">ok</button>' + '<button type="button" class="editable-cancel">cancel</button>';

            //error class attached to control-group
            $.fn.editableform.errorGroupClass = null;

            //error class attached to editable-error-block
            $.fn.editableform.errorBlockClass = 'editable-error';

            //engine
            $.fn.editableform.engine = 'jquery';
        })(window.jQuery);

        /**
        * EditableForm utilites
        */
        (function ($) {
            "use strict";

            //utils

            $.fn.editableutils = {
                /**
                * classic JS inheritance function
                */
                inherit: function (Child, Parent) {
                    var F = function () {};
                    F.prototype = Parent.prototype;
                    Child.prototype = new F();
                    Child.prototype.constructor = Child;
                    Child.superclass = Parent.prototype;
                },

                /**
                * set caret position in input
                * see http://stackoverflow.com/questions/499126/jquery-set-cursor-position-in-text-area
                */
                setCursorPosition: function (elem, pos) {
                    if (elem.setSelectionRange) {
                        elem.setSelectionRange(pos, pos);
                    } else if (elem.createTextRange) {
                        var range = elem.createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', pos);
                        range.moveStart('character', pos);
                        range.select();
                    }
                },

                /**
                * function to parse JSON in *single* quotes. (jquery automatically parse only double quotes)
                * That allows such code as: <a data-source="{'a': 'b', 'c': 'd'}">
                * safe = true --> means no exception will be thrown
                * for details see http://stackoverflow.com/questions/7410348/how-to-set-json-format-to-html5-data-attributes-in-the-jquery
                */
                tryParseJson: function (s, safe) {
                    if (typeof s === 'string' && s.length && s.match(/^[\{\[].*[\}\]]$/)) {
                        if (safe) {
                            try {
                                /*jslint evil: true*/
                                s = new Function('return ' + s)();
                                /*jslint evil: false*/
                            } catch (e) {} finally {
                                return s;
                            }
                        } else {
                            /*jslint evil: true*/
                            s = new Function('return ' + s)();
                            /*jslint evil: false*/
                        }
                    }
                    return s;
                },

                /**
                * slice object by specified keys
                */
                sliceObj: function (obj, keys, caseSensitive /* default: false */) {
                    var key,
                        keyLower,
                        newObj = {};

                    if (!$.isArray(keys) || !keys.length) {
                        return newObj;
                    }

                    for (var i = 0; i < keys.length; i++) {
                        key = keys[i];
                        if (obj.hasOwnProperty(key)) {
                            newObj[key] = obj[key];
                        }

                        if (caseSensitive === true) {
                            continue;
                        }

                        //when getting data-* attributes via $.data() it's converted to lowercase.
                        //details: http://stackoverflow.com/questions/7602565/using-data-attributes-with-jquery
                        //workaround is code below.
                        keyLower = key.toLowerCase();
                        if (obj.hasOwnProperty(keyLower)) {
                            newObj[key] = obj[keyLower];
                        }
                    }

                    return newObj;
                },

                /*
                exclude complex objects from $.data() before pass to config
                */
                getConfigData: function ($element) {
                    var data = {};
                    $.each($element.data(), function (k, v) {
                        if (typeof v !== 'object' || v && typeof v === 'object' && (v.constructor === Object || v.constructor === Array)) {
                            data[k] = v;
                        }
                    });
                    return data;
                },

                /*
                 returns keys of object
                */
                objectKeys: function (o) {
                    if (Object.keys) {
                        return Object.keys(o);
                    } else {
                        if (o !== Object(o)) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var k = [],
                            p;
                        for (p in o) {
                            if (Object.prototype.hasOwnProperty.call(o, p)) {
                                k.push(p);
                            }
                        }
                        return k;
                    }
                },

                /**
                 method to escape html.
                **/
                escape: function (str) {
                    return $('<div>').text(str).html();
                },

                /*
                 returns array items from sourceData having value property equal or inArray of 'value'
                */
                itemsByValue: function (value, sourceData, valueProp) {
                    if (!sourceData || value === null) {
                        return [];
                    }

                    if (typeof valueProp !== "function") {
                        var idKey = valueProp || 'value';
                        valueProp = function (e) {
                            return e[idKey];
                        };
                    }

                    var isValArray = $.isArray(value),
                        result = [],
                        that = this;

                    $.each(sourceData, function (i, o) {
                        if (o.children) {
                            result = result.concat(that.itemsByValue(value, o.children, valueProp));
                        } else {
                            /*jslint eqeq: true*/
                            if (isValArray) {
                                if ($.grep(value, function (v) {
                                    return v == (o && typeof o === 'object' ? valueProp(o) : o);
                                }).length) {
                                    result.push(o);
                                }
                            } else {
                                var itemValue = o && typeof o === 'object' ? valueProp(o) : o;
                                if (value == itemValue) {
                                    result.push(o);
                                }
                            }
                            /*jslint eqeq: false*/
                        }
                    });

                    return result;
                },

                /*
                Returns input by options: type, mode. 
                */
                createInput: function (options) {
                    var TypeConstructor,
                        typeOptions,
                        input,
                        type = options.type;

                    //`date` is some kind of virtual type that is transformed to one of exact types
                    //depending on mode and core lib
                    if (type === 'date') {
                        //inline
                        if (options.mode === 'inline') {
                            if ($.fn.editabletypes.datefield) {
                                type = 'datefield';
                            } else if ($.fn.editabletypes.dateuifield) {
                                type = 'dateuifield';
                            }
                            //popup
                        } else {
                            if ($.fn.editabletypes.date) {
                                type = 'date';
                            } else if ($.fn.editabletypes.dateui) {
                                type = 'dateui';
                            }
                        }

                        //if type still `date` and not exist in types, replace with `combodate` that is base input
                        if (type === 'date' && !$.fn.editabletypes.date) {
                            type = 'combodate';
                        }
                    }

                    //`datetime` should be datetimefield in 'inline' mode
                    if (type === 'datetime' && options.mode === 'inline') {
                        type = 'datetimefield';
                    }

                    //change wysihtml5 to textarea for jquery UI and plain versions
                    if (type === 'wysihtml5' && !$.fn.editabletypes[type]) {
                        type = 'textarea';
                    }

                    //create input of specified type. Input will be used for converting value, not in form
                    if (typeof $.fn.editabletypes[type] === 'function') {
                        TypeConstructor = $.fn.editabletypes[type];
                        typeOptions = this.sliceObj(options, this.objectKeys(TypeConstructor.defaults));
                        input = new TypeConstructor(typeOptions);
                        return input;
                    } else {
                        $.error('Unknown type: ' + type);
                        return false;
                    }
                },

                //see http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
                supportsTransitions: function () {
                    var b = document.body || document.documentElement,
                        s = b.style,
                        p = 'transition',
                        v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];

                    if (typeof s[p] === 'string') {
                        return true;
                    }

                    // Tests for vendor specific prop
                    p = p.charAt(0).toUpperCase() + p.substr(1);
                    for (var i = 0; i < v.length; i++) {
                        if (typeof s[v[i] + p] === 'string') {
                            return true;
                        }
                    }
                    return false;
                }

            };
        })(window.jQuery);

        /**
        Attaches stand-alone container with editable-form to HTML element. Element is used only for positioning, value is not stored anywhere.<br>
        This method applied internally in <code>$().editable()</code>. You should subscribe on it's events (save / cancel) to get profit of it.<br>
        Final realization can be different: bootstrap-popover, jqueryui-tooltip, poshytip, inline-div. It depends on which js file you include.<br>
        Applied as jQuery method.
        
        @class editableContainer
        @uses editableform
        **/
        (function ($) {
            "use strict";

            var Popup = function (element, options) {
                this.init(element, options);
            };

            var Inline = function (element, options) {
                this.init(element, options);
            };

            //methods
            Popup.prototype = {
                containerName: null, //method to call container on element
                containerDataName: null, //object name in element's .data()
                innerCss: null, //tbd in child class
                containerClass: 'editable-container editable-popup', //css class applied to container element
                defaults: {}, //container itself defaults

                init: function (element, options) {
                    this.$element = $(element);
                    //since 1.4.1 container do not use data-* directly as they already merged into options.
                    this.options = $.extend({}, $.fn.editableContainer.defaults, options);
                    this.splitOptions();

                    //set scope of form callbacks to element
                    this.formOptions.scope = this.$element[0];

                    this.initContainer();

                    //flag to hide container, when saving value will finish
                    this.delayedHide = false;

                    //bind 'destroyed' listener to destroy container when element is removed from dom
                    this.$element.on('destroyed', $.proxy(function () {
                        this.destroy();
                    }, this));

                    //attach document handler to close containers on click / escape
                    if (!$(document).data('editable-handlers-attached')) {
                        //close all on escape
                        $(document).on('keyup.editable', function (e) {
                            if (e.which === 27) {
                                $('.editable-open').editableContainer('hide');
                                //todo: return focus on element 
                            }
                        });

                        //close containers when click outside 
                        //(mousedown could be better than click, it closes everything also on drag drop)
                        $(document).on('click.editable', function (e) {
                            var $target = $(e.target),
                                i,
                                exclude_classes = ['.editable-container', '.ui-datepicker-header', '.datepicker', //in inline mode datepicker is rendered into body
                            '.modal-backdrop', '.bootstrap-wysihtml5-insert-image-modal', '.bootstrap-wysihtml5-insert-link-modal'];

                            //check if element is detached. It occurs when clicking in bootstrap datepicker
                            if (!$.contains(document.documentElement, e.target)) {
                                return;
                            }

                            //for some reason FF 20 generates extra event (click) in select2 widget with e.target = document
                            //we need to filter it via construction below. See https://github.com/vitalets/x-editable/issues/199
                            //Possibly related to http://stackoverflow.com/questions/10119793/why-does-firefox-react-differently-from-webkit-and-ie-to-click-event-on-selec
                            if ($target.is(document)) {
                                return;
                            }

                            //if click inside one of exclude classes --> no nothing
                            for (i = 0; i < exclude_classes.length; i++) {
                                if ($target.is(exclude_classes[i]) || $target.parents(exclude_classes[i]).length) {
                                    return;
                                }
                            }

                            //close all open containers (except one - target)
                            Popup.prototype.closeOthers(e.target);
                        });

                        $(document).data('editable-handlers-attached', true);
                    }
                },

                //split options on containerOptions and formOptions
                splitOptions: function () {
                    this.containerOptions = {};
                    this.formOptions = {};

                    if (!$.fn[this.containerName]) {
                        throw new Error(this.containerName + ' not found. Have you included corresponding js file?');
                    }

                    //keys defined in container defaults go to container, others go to form
                    for (var k in this.options) {
                        if (k in this.defaults) {
                            this.containerOptions[k] = this.options[k];
                        } else {
                            this.formOptions[k] = this.options[k];
                        }
                    }
                },

                /*
                Returns jquery object of container
                @method tip()
                */
                tip: function () {
                    return this.container() ? this.container().$tip : null;
                },

                /* returns container object */
                container: function () {
                    var container;
                    //first, try get it by `containerDataName`
                    if (this.containerDataName) {
                        if (container = this.$element.data(this.containerDataName)) {
                            return container;
                        }
                    }
                    //second, try `containerName`
                    container = this.$element.data(this.containerName);
                    return container;
                },

                /* call native method of underlying container, e.g. this.$element.popover('method') */
                call: function () {
                    this.$element[this.containerName].apply(this.$element, arguments);
                },

                initContainer: function () {
                    this.call(this.containerOptions);
                },

                renderForm: function () {
                    this.$form.editableform(this.formOptions).on({
                        save: $.proxy(this.save, this), //click on submit button (value changed)
                        nochange: $.proxy(function () {
                            this.hide('nochange');
                        }, this), //click on submit button (value NOT changed)                
                        cancel: $.proxy(function () {
                            this.hide('cancel');
                        }, this), //click on calcel button
                        show: $.proxy(function () {
                            if (this.delayedHide) {
                                this.hide(this.delayedHide.reason);
                                this.delayedHide = false;
                            } else {
                                this.setPosition();
                            }
                        }, this), //re-position container every time form is shown (occurs each time after loading state)
                        rendering: $.proxy(this.setPosition, this), //this allows to place container correctly when loading shown
                        resize: $.proxy(this.setPosition, this), //this allows to re-position container when form size is changed 
                        rendered: $.proxy(function () {
                            /**        
                            Fired when container is shown and form is rendered (for select will wait for loading dropdown options).  
                            **Note:** Bootstrap popover has own `shown` event that now cannot be separated from x-editable's one.
                            The workaround is to check `arguments.length` that is always `2` for x-editable.                     
                            
                            @event shown 
                            @param {Object} event event object
                            @example
                            $('#username').on('shown', function(e, editable) {
                                editable.input.$input.val('overwriting value of input..');
                            });                     
                            **/
                            /*
                             TODO: added second param mainly to distinguish from bootstrap's shown event. It's a hotfix that will be solved in future versions via namespaced events.  
                            */
                            this.$element.triggerHandler('shown', $(this.options.scope).data('editable'));
                        }, this)
                    }).editableform('render');
                },

                /**
                Shows container with form
                @method show()
                @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.
                **/
                /* Note: poshytip owerwrites this method totally! */
                show: function (closeAll) {
                    this.$element.addClass('editable-open');
                    if (closeAll !== false) {
                        //close all open containers (except this)
                        this.closeOthers(this.$element[0]);
                    }

                    //show container itself
                    this.innerShow();
                    this.tip().addClass(this.containerClass);

                    /*
                    Currently, form is re-rendered on every show. 
                    The main reason is that we dont know, what will container do with content when closed:
                    remove(), detach() or just hide() - it depends on container.
                    
                    Detaching form itself before hide and re-insert before show is good solution, 
                    but visually it looks ugly --> container changes size before hide.  
                    */

                    //if form already exist - delete previous data 
                    if (this.$form) {
                        //todo: destroy prev data!
                        //this.$form.destroy();
                    }

                    this.$form = $('<div>');

                    //insert form into container body
                    if (this.tip().is(this.innerCss)) {
                        //for inline container
                        this.tip().append(this.$form);
                    } else {
                        this.tip().find(this.innerCss).append(this.$form);
                    }

                    //render form
                    this.renderForm();
                },

                /**
                Hides container with form
                @method hide()
                @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|undefined (=manual)</code>
                **/
                hide: function (reason) {
                    if (!this.tip() || !this.tip().is(':visible') || !this.$element.hasClass('editable-open')) {
                        return;
                    }

                    //if form is saving value, schedule hide
                    if (this.$form.data('editableform').isSaving) {
                        this.delayedHide = { reason: reason };
                        return;
                    } else {
                        this.delayedHide = false;
                    }

                    this.$element.removeClass('editable-open');
                    this.innerHide();

                    /**
                    Fired when container was hidden. It occurs on both save or cancel.  
                    **Note:** Bootstrap popover has own `hidden` event that now cannot be separated from x-editable's one.
                    The workaround is to check `arguments.length` that is always `2` for x-editable. 
                     @event hidden 
                    @param {object} event event object
                    @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|manual</code>
                    @example
                    $('#username').on('hidden', function(e, reason) {
                        if(reason === 'save' || reason === 'cancel') {
                            //auto-open next editable
                            $(this).closest('tr').next().find('.editable').editable('show');
                        } 
                    });
                    **/
                    this.$element.triggerHandler('hidden', reason || 'manual');
                },

                /* internal show method. To be overwritten in child classes */
                innerShow: function () {},

                /* internal hide method. To be overwritten in child classes */
                innerHide: function () {},

                /**
                Toggles container visibility (show / hide)
                @method toggle()
                @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.
                **/
                toggle: function (closeAll) {
                    if (this.container() && this.tip() && this.tip().is(':visible')) {
                        this.hide();
                    } else {
                        this.show(closeAll);
                    }
                },

                /*
                Updates the position of container when content changed.
                @method setPosition()
                */
                setPosition: function () {
                    //tbd in child class
                },

                save: function (e, params) {
                    /**        
                    Fired when new value was submitted. You can use <code>$(this).data('editableContainer')</code> inside handler to access to editableContainer instance
                    
                    @event save 
                    @param {Object} event event object
                    @param {Object} params additional params
                    @param {mixed} params.newValue submitted value
                    @param {Object} params.response ajax response
                    @example
                    $('#username').on('save', function(e, params) {
                        //assuming server response: '{success: true}'
                        var pk = $(this).data('editableContainer').options.pk;
                        if(params.response && params.response.success) {
                            alert('value: ' + params.newValue + ' with pk: ' + pk + ' saved!');
                        } else {
                            alert('error!'); 
                        } 
                    });
                    **/
                    this.$element.triggerHandler('save', params);

                    //hide must be after trigger, as saving value may require methods of plugin, applied to input
                    this.hide('save');
                },

                /**
                Sets new option
                
                @method option(key, value)
                @param {string} key 
                @param {mixed} value 
                **/
                option: function (key, value) {
                    this.options[key] = value;
                    if (key in this.containerOptions) {
                        this.containerOptions[key] = value;
                        this.setContainerOption(key, value);
                    } else {
                        this.formOptions[key] = value;
                        if (this.$form) {
                            this.$form.editableform('option', key, value);
                        }
                    }
                },

                setContainerOption: function (key, value) {
                    this.call('option', key, value);
                },

                /**
                Destroys the container instance
                @method destroy()
                **/
                destroy: function () {
                    this.hide();
                    this.innerDestroy();
                    this.$element.off('destroyed');
                    this.$element.removeData('editableContainer');
                },

                /* to be overwritten in child classes */
                innerDestroy: function () {},

                /*
                Closes other containers except one related to passed element. 
                Other containers can be cancelled or submitted (depends on onblur option)
                */
                closeOthers: function (element) {
                    $('.editable-open').each(function (i, el) {
                        //do nothing with passed element and it's children
                        if (el === element || $(el).find(element).length) {
                            return;
                        }

                        //otherwise cancel or submit all open containers 
                        var $el = $(el),
                            ec = $el.data('editableContainer');

                        if (!ec) {
                            return;
                        }

                        if (ec.options.onblur === 'cancel') {
                            $el.data('editableContainer').hide('onblur');
                        } else if (ec.options.onblur === 'submit') {
                            $el.data('editableContainer').tip().find('form').submit();
                        }
                    });
                },

                /**
                Activates input of visible container (e.g. set focus)
                @method activate()
                **/
                activate: function () {
                    if (this.tip && this.tip().is(':visible') && this.$form) {
                        this.$form.data('editableform').input.activate();
                    }
                }

            };

            /**
            jQuery method to initialize editableContainer.
            
            @method $().editableContainer(options)
            @params {Object} options
            @example
            $('#edit').editableContainer({
                type: 'text',
                url: '/post',
                pk: 1,
                value: 'hello'
            });
            **/
            $.fn.editableContainer = function (option) {
                var args = arguments;
                return this.each(function () {
                    var $this = $(this),
                        dataKey = 'editableContainer',
                        data = $this.data(dataKey),
                        options = typeof option === 'object' && option,
                        Constructor = options.mode === 'inline' ? Inline : Popup;

                    if (!data) {
                        $this.data(dataKey, data = new Constructor(this, options));
                    }

                    if (typeof option === 'string') {
                        //call method 
                        data[option].apply(data, Array.prototype.slice.call(args, 1));
                    }
                });
            };

            //store constructors
            $.fn.editableContainer.Popup = Popup;
            $.fn.editableContainer.Inline = Inline;

            //defaults
            $.fn.editableContainer.defaults = {
                /**
                Initial value of form input
                 @property value 
                @type mixed
                @default null
                @private
                **/
                value: null,
                /**
                Placement of container relative to element. Can be <code>top|right|bottom|left</code>. Not used for inline container.
                 @property placement 
                @type string
                @default 'top'
                **/
                placement: 'top',
                /**
                Whether to hide container on save/cancel.
                 @property autohide 
                @type boolean
                @default true
                @private 
                **/
                autohide: true,
                /**
                Action when user clicks outside the container. Can be <code>cancel|submit|ignore</code>.  
                Setting <code>ignore</code> allows to have several containers open. 
                 @property onblur 
                @type string
                @default 'cancel'
                @since 1.1.1
                **/
                onblur: 'cancel',

                /**
                Animation speed (inline mode only)
                @property anim 
                @type string
                @default false
                **/
                anim: false,

                /**
                Mode of editable, can be `popup` or `inline` 
                
                @property mode 
                @type string         
                @default 'popup'
                @since 1.4.0        
                **/
                mode: 'popup'
            };

            /* 
            * workaround to have 'destroyed' event to destroy popover when element is destroyed
            * see http://stackoverflow.com/questions/2200494/jquery-trigger-event-when-an-element-is-removed-from-the-dom
            */
            jQuery.event.special.destroyed = {
                remove: function (o) {
                    if (o.handler) {
                        o.handler();
                    }
                }
            };
        })(window.jQuery);

        /**
        * Editable Inline 
        * ---------------------
        */
        (function ($) {
            "use strict";

            //copy prototype from EditableContainer
            //extend methods

            $.extend($.fn.editableContainer.Inline.prototype, $.fn.editableContainer.Popup.prototype, {
                containerName: 'editableform',
                innerCss: '.editable-inline',
                containerClass: 'editable-container editable-inline', //css class applied to container element

                initContainer: function () {
                    //container is <span> element
                    this.$tip = $('<span></span>');

                    //convert anim to miliseconds (int)
                    if (!this.options.anim) {
                        this.options.anim = 0;
                    }
                },

                splitOptions: function () {
                    //all options are passed to form
                    this.containerOptions = {};
                    this.formOptions = this.options;
                },

                tip: function () {
                    return this.$tip;
                },

                innerShow: function () {
                    this.$element.hide();
                    this.tip().insertAfter(this.$element).show();
                },

                innerHide: function () {
                    this.$tip.hide(this.options.anim, $.proxy(function () {
                        this.$element.show();
                        this.innerDestroy();
                    }, this));
                },

                innerDestroy: function () {
                    if (this.tip()) {
                        this.tip().empty().remove();
                    }
                }
            });
        })(window.jQuery);
        /**
        Makes editable any HTML element on the page. Applied as jQuery method.
        
        @class editable
        @uses editableContainer
        **/
        (function ($) {
            "use strict";

            var Editable = function (element, options) {
                this.$element = $(element);
                //data-* has more priority over js options: because dynamically created elements may change data-* 
                this.options = $.extend({}, $.fn.editable.defaults, options, $.fn.editableutils.getConfigData(this.$element));
                if (this.options.selector) {
                    this.initLive();
                } else {
                    this.init();
                }

                //check for transition support
                if (this.options.highlight && !$.fn.editableutils.supportsTransitions()) {
                    this.options.highlight = false;
                }
            };

            Editable.prototype = {
                constructor: Editable,
                init: function () {
                    var isValueByText = false,
                        doAutotext,
                        finalize;

                    //name
                    this.options.name = this.options.name || this.$element.attr('id');

                    //create input of specified type. Input needed already here to convert value for initial display (e.g. show text by id for select)
                    //also we set scope option to have access to element inside input specific callbacks (e. g. source as function)
                    this.options.scope = this.$element[0];
                    this.input = $.fn.editableutils.createInput(this.options);
                    if (!this.input) {
                        return;
                    }

                    //set value from settings or by element's text
                    if (this.options.value === undefined || this.options.value === null) {
                        this.value = this.input.html2value($.trim(this.$element.html()));
                        isValueByText = true;
                    } else {
                        /*
                          value can be string when received from 'data-value' attribute
                          for complext objects value can be set as json string in data-value attribute, 
                          e.g. data-value="{city: 'Moscow', street: 'Lenina'}"
                        */
                        this.options.value = $.fn.editableutils.tryParseJson(this.options.value, true);
                        if (typeof this.options.value === 'string') {
                            this.value = this.input.str2value(this.options.value);
                        } else {
                            this.value = this.options.value;
                        }
                    }

                    //add 'editable' class to every editable element
                    this.$element.addClass('editable');

                    //specifically for "textarea" add class .editable-pre-wrapped to keep linebreaks
                    if (this.input.type === 'textarea') {
                        this.$element.addClass('editable-pre-wrapped');
                    }

                    //attach handler activating editable. In disabled mode it just prevent default action (useful for links)
                    if (this.options.toggle !== 'manual') {
                        this.$element.addClass('editable-click');
                        this.$element.on(this.options.toggle + '.editable', $.proxy(function (e) {
                            //prevent following link if editable enabled
                            if (!this.options.disabled) {
                                e.preventDefault();
                            }

                            //stop propagation not required because in document click handler it checks event target
                            //e.stopPropagation();

                            if (this.options.toggle === 'mouseenter') {
                                //for hover only show container
                                this.show();
                            } else {
                                //when toggle='click' we should not close all other containers as they will be closed automatically in document click listener
                                var closeAll = this.options.toggle !== 'click';
                                this.toggle(closeAll);
                            }
                        }, this));
                    } else {
                        this.$element.attr('tabindex', -1); //do not stop focus on element when toggled manually
                    }

                    //if display is function it's far more convinient to have autotext = always to render correctly on init
                    //see https://github.com/vitalets/x-editable-yii/issues/34
                    if (typeof this.options.display === 'function') {
                        this.options.autotext = 'always';
                    }

                    //check conditions for autotext:
                    switch (this.options.autotext) {
                        case 'always':
                            doAutotext = true;
                            break;
                        case 'auto':
                            //if element text is empty and value is defined and value not generated by text --> run autotext
                            doAutotext = !$.trim(this.$element.text()).length && this.value !== null && this.value !== undefined && !isValueByText;
                            break;
                        default:
                            doAutotext = false;
                    }

                    //depending on autotext run render() or just finilize init
                    $.when(doAutotext ? this.render() : true).then($.proxy(function () {
                        if (this.options.disabled) {
                            this.disable();
                        } else {
                            this.enable();
                        }
                        /**        
                        Fired when element was initialized by `$().editable()` method. 
                        Please note that you should setup `init` handler **before** applying `editable`. 
                                       
                        @event init 
                        @param {Object} event event object
                        @param {Object} editable editable instance (as here it cannot accessed via data('editable'))
                        @since 1.2.0
                        @example
                        $('#username').on('init', function(e, editable) {
                            alert('initialized ' + editable.options.name);
                        });
                        $('#username').editable();
                        **/
                        this.$element.triggerHandler('init', this);
                    }, this));
                },

                /*
                 Initializes parent element for live editables 
                */
                initLive: function () {
                    //store selector 
                    var selector = this.options.selector;
                    //modify options for child elements
                    this.options.selector = false;
                    this.options.autotext = 'never';
                    //listen toggle events
                    this.$element.on(this.options.toggle + '.editable', selector, $.proxy(function (e) {
                        var $target = $(e.target);
                        if (!$target.data('editable')) {
                            //if delegated element initially empty, we need to clear it's text (that was manually set to `empty` by user)
                            //see https://github.com/vitalets/x-editable/issues/137 
                            if ($target.hasClass(this.options.emptyclass)) {
                                $target.empty();
                            }
                            $target.editable(this.options).trigger(e);
                        }
                    }, this));
                },

                /*
                Renders value into element's text.
                Can call custom display method from options.
                Can return deferred object.
                @method render()
                @param {mixed} response server response (if exist) to pass into display function
                */
                render: function (response) {
                    //do not display anything
                    if (this.options.display === false) {
                        return;
                    }

                    //if input has `value2htmlFinal` method, we pass callback in third param to be called when source is loaded
                    if (this.input.value2htmlFinal) {
                        return this.input.value2html(this.value, this.$element[0], this.options.display, response);
                        //if display method defined --> use it    
                    } else if (typeof this.options.display === 'function') {
                        return this.options.display.call(this.$element[0], this.value, response);
                        //else use input's original value2html() method    
                    } else {
                        return this.input.value2html(this.value, this.$element[0]);
                    }
                },

                /**
                Enables editable
                @method enable()
                **/
                enable: function () {
                    this.options.disabled = false;
                    this.$element.removeClass('editable-disabled');
                    this.handleEmpty(this.isEmpty);
                    if (this.options.toggle !== 'manual') {
                        if (this.$element.attr('tabindex') === '-1') {
                            this.$element.removeAttr('tabindex');
                        }
                    }
                },

                /**
                Disables editable
                @method disable()
                **/
                disable: function () {
                    this.options.disabled = true;
                    this.hide();
                    this.$element.addClass('editable-disabled');
                    this.handleEmpty(this.isEmpty);
                    //do not stop focus on this element
                    this.$element.attr('tabindex', -1);
                },

                /**
                Toggles enabled / disabled state of editable element
                @method toggleDisabled()
                **/
                toggleDisabled: function () {
                    if (this.options.disabled) {
                        this.enable();
                    } else {
                        this.disable();
                    }
                },

                /**
                Sets new option
                
                @method option(key, value)
                @param {string|object} key option name or object with several options
                @param {mixed} value option new value
                @example
                $('.editable').editable('option', 'pk', 2);
                **/
                option: function (key, value) {
                    //set option(s) by object
                    if (key && typeof key === 'object') {
                        $.each(key, $.proxy(function (k, v) {
                            this.option($.trim(k), v);
                        }, this));
                        return;
                    }

                    //set option by string             
                    this.options[key] = value;

                    //disabled
                    if (key === 'disabled') {
                        return value ? this.disable() : this.enable();
                    }

                    //value
                    if (key === 'value') {
                        this.setValue(value);
                    }

                    //transfer new option to container! 
                    if (this.container) {
                        this.container.option(key, value);
                    }

                    //pass option to input directly (as it points to the same in form)
                    if (this.input.option) {
                        this.input.option(key, value);
                    }
                },

                /*
                * set emptytext if element is empty
                */
                handleEmpty: function (isEmpty) {
                    //do not handle empty if we do not display anything
                    if (this.options.display === false) {
                        return;
                    }

                    /* 
                    isEmpty may be set directly as param of method.
                    It is required when we enable/disable field and can't rely on content 
                    as node content is text: "Empty" that is not empty %)
                    */
                    if (isEmpty !== undefined) {
                        this.isEmpty = isEmpty;
                    } else {
                        //detect empty
                        //for some inputs we need more smart check
                        //e.g. wysihtml5 may have <br>, <p></p>, <img>
                        if (typeof this.input.isEmpty === 'function') {
                            this.isEmpty = this.input.isEmpty(this.$element);
                        } else {
                            this.isEmpty = $.trim(this.$element.html()) === '';
                        }
                    }

                    //emptytext shown only for enabled
                    if (!this.options.disabled) {
                        if (this.isEmpty) {
                            this.$element.html(this.options.emptytext);
                            if (this.options.emptyclass) {
                                this.$element.addClass(this.options.emptyclass);
                            }
                        } else if (this.options.emptyclass) {
                            this.$element.removeClass(this.options.emptyclass);
                        }
                    } else {
                        //below required if element disable property was changed
                        if (this.isEmpty) {
                            this.$element.empty();
                            if (this.options.emptyclass) {
                                this.$element.removeClass(this.options.emptyclass);
                            }
                        }
                    }
                },

                /**
                Shows container with form
                @method show()
                @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.
                **/
                show: function (closeAll) {
                    if (this.options.disabled) {
                        return;
                    }

                    //init editableContainer: popover, tooltip, inline, etc..
                    if (!this.container) {
                        var containerOptions = $.extend({}, this.options, {
                            value: this.value,
                            input: this.input //pass input to form (as it is already created)
                        });
                        this.$element.editableContainer(containerOptions);
                        //listen `save` event 
                        this.$element.on("save.internal", $.proxy(this.save, this));
                        this.container = this.$element.data('editableContainer');
                    } else if (this.container.tip().is(':visible')) {
                        return;
                    }

                    //show container
                    this.container.show(closeAll);
                },

                /**
                Hides container with form
                @method hide()
                **/
                hide: function () {
                    if (this.container) {
                        this.container.hide();
                    }
                },

                /**
                Toggles container visibility (show / hide)
                @method toggle()
                @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.
                **/
                toggle: function (closeAll) {
                    if (this.container && this.container.tip().is(':visible')) {
                        this.hide();
                    } else {
                        this.show(closeAll);
                    }
                },

                /*
                * called when form was submitted
                */
                save: function (e, params) {
                    //mark element with unsaved class if needed
                    if (this.options.unsavedclass) {
                        /*
                         Add unsaved css to element if:
                          - url is not user's function 
                          - value was not sent to server
                          - params.response === undefined, that means data was not sent
                          - value changed 
                        */
                        var sent = false;
                        sent = sent || typeof this.options.url === 'function';
                        sent = sent || this.options.display === false;
                        sent = sent || params.response !== undefined;
                        sent = sent || this.options.savenochange && this.input.value2str(this.value) !== this.input.value2str(params.newValue);

                        if (sent) {
                            this.$element.removeClass(this.options.unsavedclass);
                        } else {
                            this.$element.addClass(this.options.unsavedclass);
                        }
                    }

                    //highlight when saving
                    if (this.options.highlight) {
                        var $e = this.$element,
                            bgColor = $e.css('background-color');

                        $e.css('background-color', this.options.highlight);
                        setTimeout(function () {
                            if (bgColor === 'transparent') {
                                bgColor = '';
                            }
                            $e.css('background-color', bgColor);
                            $e.addClass('editable-bg-transition');
                            setTimeout(function () {
                                $e.removeClass('editable-bg-transition');
                            }, 1700);
                        }, 10);
                    }

                    //set new value
                    this.setValue(params.newValue, false, params.response);

                    /**        
                    Fired when new value was submitted. You can use <code>$(this).data('editable')</code> to access to editable instance
                    
                    @event save 
                    @param {Object} event event object
                    @param {Object} params additional params
                    @param {mixed} params.newValue submitted value
                    @param {Object} params.response ajax response
                    @example
                    $('#username').on('save', function(e, params) {
                        alert('Saved value: ' + params.newValue);
                    });
                    **/
                    //event itself is triggered by editableContainer. Description here is only for documentation              
                },

                validate: function () {
                    if (typeof this.options.validate === 'function') {
                        return this.options.validate.call(this, this.value);
                    }
                },

                /**
                Sets new value of editable
                @method setValue(value, convertStr)
                @param {mixed} value new value 
                @param {boolean} convertStr whether to convert value from string to internal format
                **/
                setValue: function (value, convertStr, response) {
                    if (convertStr) {
                        this.value = this.input.str2value(value);
                    } else {
                        this.value = value;
                    }
                    if (this.container) {
                        this.container.option('value', this.value);
                    }
                    $.when(this.render(response)).then($.proxy(function () {
                        this.handleEmpty();
                    }, this));
                },

                /**
                Activates input of visible container (e.g. set focus)
                @method activate()
                **/
                activate: function () {
                    if (this.container) {
                        this.container.activate();
                    }
                },

                /**
                Removes editable feature from element
                @method destroy()
                **/
                destroy: function () {
                    this.disable();

                    if (this.container) {
                        this.container.destroy();
                    }

                    this.input.destroy();

                    if (this.options.toggle !== 'manual') {
                        this.$element.removeClass('editable-click');
                        this.$element.off(this.options.toggle + '.editable');
                    }

                    this.$element.off("save.internal");

                    this.$element.removeClass('editable editable-open editable-disabled');
                    this.$element.removeData('editable');
                }
            };

            /* EDITABLE PLUGIN DEFINITION
            * ======================= */

            /**
            jQuery method to initialize editable element.
            
            @method $().editable(options)
            @params {Object} options
            @example
            $('#username').editable({
                type: 'text',
                url: '/post',
                pk: 1
            });
            **/
            $.fn.editable = function (option) {
                //special API methods returning non-jquery object
                var result = {},
                    args = arguments,
                    datakey = 'editable';
                switch (option) {
                    /**
                    Runs client-side validation for all matched editables
                    
                    @method validate()
                    @returns {Object} validation errors map
                    @example
                    $('#username, #fullname').editable('validate');
                    // possible result:
                    {
                      username: "username is required",
                      fullname: "fullname should be minimum 3 letters length"
                    }
                    **/
                    case 'validate':
                        this.each(function () {
                            var $this = $(this),
                                data = $this.data(datakey),
                                error;
                            if (data && (error = data.validate())) {
                                result[data.options.name] = error;
                            }
                        });
                        return result;

                    /**
                    Returns current values of editable elements.   
                    Note that it returns an **object** with name-value pairs, not a value itself. It allows to get data from several elements.    
                    If value of some editable is `null` or `undefined` it is excluded from result object.
                    When param `isSingle` is set to **true** - it is supposed you have single element and will return value of editable instead of object.   
                     
                    @method getValue()
                    @param {bool} isSingle whether to return just value of single element
                    @returns {Object} object of element names and values
                    @example
                    $('#username, #fullname').editable('getValue');
                    //result:
                    {
                    username: "superuser",
                    fullname: "John"
                    }
                    //isSingle = true
                    $('#username').editable('getValue', true);
                    //result "superuser" 
                    **/
                    case 'getValue':
                        if (arguments.length === 2 && arguments[1] === true) {
                            //isSingle = true
                            result = this.eq(0).data(datakey).value;
                        } else {
                            this.each(function () {
                                var $this = $(this),
                                    data = $this.data(datakey);
                                if (data && data.value !== undefined && data.value !== null) {
                                    result[data.options.name] = data.input.value2submit(data.value);
                                }
                            });
                        }
                        return result;

                    /**
                    This method collects values from several editable elements and submit them all to server.   
                    Internally it runs client-side validation for all fields and submits only in case of success.  
                    See <a href="#newrecord">creating new records</a> for details.  
                    Since 1.5.1 `submit` can be applied to single element to send data programmatically. In that case
                    `url`, `success` and `error` is taken from initial options and you can just call `$('#username').editable('submit')`. 
                    
                    @method submit(options)
                    @param {object} options 
                    @param {object} options.url url to submit data 
                    @param {object} options.data additional data to submit
                    @param {object} options.ajaxOptions additional ajax options
                    @param {function} options.error(obj) error handler 
                    @param {function} options.success(obj,config) success handler
                    @returns {Object} jQuery object
                    **/
                    case 'submit':
                        //collects value, validate and submit to server for creating new record
                        var config = arguments[1] || {},
                            $elems = this,
                            errors = this.editable('validate');

                        // validation ok
                        if ($.isEmptyObject(errors)) {
                            var ajaxOptions = {};

                            // for single element use url, success etc from options
                            if ($elems.length === 1) {
                                var editable = $elems.data('editable');
                                //standard params
                                var params = {
                                    name: editable.options.name || '',
                                    value: editable.input.value2submit(editable.value),
                                    pk: typeof editable.options.pk === 'function' ? editable.options.pk.call(editable.options.scope) : editable.options.pk
                                };

                                //additional params
                                if (typeof editable.options.params === 'function') {
                                    params = editable.options.params.call(editable.options.scope, params);
                                } else {
                                    //try parse json in single quotes (from data-params attribute)
                                    editable.options.params = $.fn.editableutils.tryParseJson(editable.options.params, true);
                                    $.extend(params, editable.options.params);
                                }

                                ajaxOptions = {
                                    url: editable.options.url,
                                    data: params,
                                    type: 'POST'
                                };

                                // use success / error from options 
                                config.success = config.success || editable.options.success;
                                config.error = config.error || editable.options.error;

                                // multiple elements
                            } else {
                                var values = this.editable('getValue');

                                ajaxOptions = {
                                    url: config.url,
                                    data: values,
                                    type: 'POST'
                                };
                            }

                            // ajax success callabck (response 200 OK)
                            ajaxOptions.success = typeof config.success === 'function' ? function (response) {
                                config.success.call($elems, response, config);
                            } : $.noop;

                            // ajax error callabck
                            ajaxOptions.error = typeof config.error === 'function' ? function () {
                                config.error.apply($elems, arguments);
                            } : $.noop;

                            // extend ajaxOptions    
                            if (config.ajaxOptions) {
                                $.extend(ajaxOptions, config.ajaxOptions);
                            }

                            // extra data 
                            if (config.data) {
                                $.extend(ajaxOptions.data, config.data);
                            }

                            // perform ajax request
                            $.ajax(ajaxOptions);
                        } else {
                            //client-side validation error
                            if (typeof config.error === 'function') {
                                config.error.call($elems, errors);
                            }
                        }
                        return this;
                }

                //return jquery object
                return this.each(function () {
                    var $this = $(this),
                        data = $this.data(datakey),
                        options = typeof option === 'object' && option;

                    //for delegated targets do not store `editable` object for element
                    //it's allows several different selectors.
                    //see: https://github.com/vitalets/x-editable/issues/312    
                    if (options && options.selector) {
                        data = new Editable(this, options);
                        return;
                    }

                    if (!data) {
                        $this.data(datakey, data = new Editable(this, options));
                    }

                    if (typeof option === 'string') {
                        //call method 
                        data[option].apply(data, Array.prototype.slice.call(args, 1));
                    }
                });
            };

            $.fn.editable.defaults = {
                /**
                Type of input. Can be <code>text|textarea|select|date|checklist</code> and more
                 @property type 
                @type string
                @default 'text'
                **/
                type: 'text',
                /**
                Sets disabled state of editable
                 @property disabled 
                @type boolean
                @default false
                **/
                disabled: false,
                /**
                How to toggle editable. Can be <code>click|dblclick|mouseenter|manual</code>.   
                When set to <code>manual</code> you should manually call <code>show/hide</code> methods of editable.    
                **Note**: if you call <code>show</code> or <code>toggle</code> inside **click** handler of some DOM element, 
                you need to apply <code>e.stopPropagation()</code> because containers are being closed on any click on document.
                
                @example
                $('#edit-button').click(function(e) {
                    e.stopPropagation();
                    $('#username').editable('toggle');
                });
                 @property toggle 
                @type string
                @default 'click'
                **/
                toggle: 'click',
                /**
                Text shown when element is empty.
                 @property emptytext 
                @type string
                @default 'Empty'
                **/
                emptytext: 'Empty',
                /**
                Allows to automatically set element's text based on it's value. Can be <code>auto|always|never</code>. Useful for select and date.
                For example, if dropdown list is <code>{1: 'a', 2: 'b'}</code> and element's value set to <code>1</code>, it's html will be automatically set to <code>'a'</code>.  
                <code>auto</code> - text will be automatically set only if element is empty.  
                <code>always|never</code> - always(never) try to set element's text.
                 @property autotext 
                @type string
                @default 'auto'
                **/
                autotext: 'auto',
                /**
                Initial value of input. If not set, taken from element's text.  
                Note, that if element's text is empty - text is automatically generated from value and can be customized (see `autotext` option).  
                For example, to display currency sign:
                @example
                <a id="price" data-type="text" data-value="100"></a>
                <script>
                $('#price').editable({
                    ...
                    display: function(value) {
                      $(this).text(value + '$');
                    } 
                }) 
                </script>
                        
                @property value 
                @type mixed
                @default element's text
                **/
                value: null,
                /**
                Callback to perform custom displaying of value in element's text.  
                If `null`, default input's display used.  
                If `false`, no displaying methods will be called, element's text will never change.  
                Runs under element's scope.  
                _**Parameters:**_  
                
                * `value` current value to be displayed
                * `response` server response (if display called after ajax submit), since 1.4.0
                 
                For _inputs with source_ (select, checklist) parameters are different:  
                  
                * `value` current value to be displayed
                * `sourceData` array of items for current input (e.g. dropdown items) 
                * `response` server response (if display called after ajax submit), since 1.4.0
                          
                To get currently selected items use `$.fn.editableutils.itemsByValue(value, sourceData)`.
                
                @property display 
                @type function|boolean
                @default null
                @since 1.2.0
                @example
                display: function(value, sourceData) {
                   //display checklist as comma-separated values
                   var html = [],
                       checked = $.fn.editableutils.itemsByValue(value, sourceData);
                       
                   if(checked.length) {
                       $.each(checked, function(i, v) { html.push($.fn.editableutils.escape(v.text)); });
                       $(this).html(html.join(', '));
                   } else {
                       $(this).empty(); 
                   }
                }
                **/
                display: null,
                /**
                Css class applied when editable text is empty.
                 @property emptyclass 
                @type string
                @since 1.4.1        
                @default editable-empty
                **/
                emptyclass: 'editable-empty',
                /**
                Css class applied when value was stored but not sent to server (`pk` is empty or `send = 'never'`).  
                You may set it to `null` if you work with editables locally and submit them together.  
                 @property unsavedclass 
                @type string
                @since 1.4.1        
                @default editable-unsaved
                **/
                unsavedclass: 'editable-unsaved',
                /**
                If selector is provided, editable will be delegated to the specified targets.  
                Usefull for dynamically generated DOM elements.  
                **Please note**, that delegated targets can't be initialized with `emptytext` and `autotext` options, 
                as they actually become editable only after first click.  
                You should manually set class `editable-click` to these elements.  
                Also, if element originally empty you should add class `editable-empty`, set `data-value=""` and write emptytext into element:
                 @property selector 
                @type string
                @since 1.4.1        
                @default null
                @example
                <div id="user">
                  <!-- empty -->
                  <a href="#" data-name="username" data-type="text" class="editable-click editable-empty" data-value="" title="Username">Empty</a>
                  <!-- non-empty -->
                  <a href="#" data-name="group" data-type="select" data-source="/groups" data-value="1" class="editable-click" title="Group">Operator</a>
                </div>     
                
                <script>
                $('#user').editable({
                    selector: 'a',
                    url: '/post',
                    pk: 1
                });
                </script>
                **/
                selector: null,
                /**
                Color used to highlight element after update. Implemented via CSS3 transition, works in modern browsers.
                
                @property highlight 
                @type string|boolean
                @since 1.4.5        
                @default #FFFF80 
                **/
                highlight: '#FFFF80'
            };
        })(window.jQuery);

        /**
        AbstractInput - base class for all editable inputs.
        It defines interface to be implemented by any input type.
        To create your own input you can inherit from this class.
        
        @class abstractinput
        **/
        (function ($) {
            "use strict";

            //types

            $.fn.editabletypes = {};

            var AbstractInput = function () {};

            AbstractInput.prototype = {
                /**
                 Initializes input
                  @method init() 
                 **/
                init: function (type, options, defaults) {
                    this.type = type;
                    this.options = $.extend({}, defaults, options);
                },

                /*
                this method called before render to init $tpl that is inserted in DOM
                */
                prerender: function () {
                    this.$tpl = $(this.options.tpl); //whole tpl as jquery object    
                    this.$input = this.$tpl; //control itself, can be changed in render method
                    this.$clear = null; //clear button
                    this.error = null; //error message, if input cannot be rendered           
                },

                /**
                 Renders input from tpl. Can return jQuery deferred object.
                 Can be overwritten in child objects
                  @method render()
                **/
                render: function () {},

                /**
                 Sets element's html by value. 
                  @method value2html(value, element)
                 @param {mixed} value
                 @param {DOMElement} element
                **/
                value2html: function (value, element) {
                    $(element)[this.options.escape ? 'text' : 'html']($.trim(value));
                },

                /**
                 Converts element's html to value
                  @method html2value(html)
                 @param {string} html
                 @returns {mixed}
                **/
                html2value: function (html) {
                    return $('<div>').html(html).text();
                },

                /**
                 Converts value to string (for internal compare). For submitting to server used value2submit().
                  @method value2str(value) 
                 @param {mixed} value
                 @returns {string}
                **/
                value2str: function (value) {
                    return value;
                },

                /**
                 Converts string received from server into value. Usually from `data-value` attribute.
                  @method str2value(str)
                 @param {string} str
                 @returns {mixed}
                **/
                str2value: function (str) {
                    return str;
                },

                /**
                 Converts value for submitting to server. Result can be string or object.
                  @method value2submit(value) 
                 @param {mixed} value
                 @returns {mixed}
                **/
                value2submit: function (value) {
                    return value;
                },

                /**
                 Sets value of input.
                  @method value2input(value) 
                 @param {mixed} value
                **/
                value2input: function (value) {
                    this.$input.val(value);
                },

                /**
                 Returns value of input. Value can be object (e.g. datepicker)
                  @method input2value() 
                **/
                input2value: function () {
                    return this.$input.val();
                },

                /**
                 Activates input. For text it sets focus.
                  @method activate() 
                **/
                activate: function () {
                    if (this.$input.is(':visible')) {
                        this.$input.focus();
                    }
                },

                /**
                 Creates input.
                  @method clear() 
                **/
                clear: function () {
                    this.$input.val(null);
                },

                /**
                 method to escape html.
                **/
                escape: function (str) {
                    return $('<div>').text(str).html();
                },

                /**
                 attach handler to automatically submit form when value changed (useful when buttons not shown)
                **/
                autosubmit: function () {},

                /**
                Additional actions when destroying element 
                **/
                destroy: function () {},

                // -------- helper functions --------
                setClass: function () {
                    if (this.options.inputclass) {
                        this.$input.addClass(this.options.inputclass);
                    }
                },

                setAttr: function (attr) {
                    if (this.options[attr] !== undefined && this.options[attr] !== null) {
                        this.$input.attr(attr, this.options[attr]);
                    }
                },

                option: function (key, value) {
                    this.options[key] = value;
                }

            };

            AbstractInput.defaults = {
                /**
                HTML template of input. Normally you should not change it.
                 @property tpl 
                @type string
                @default ''
                **/
                tpl: '',
                /**
                CSS class automatically applied to input
                
                @property inputclass 
                @type string
                @default null
                **/
                inputclass: null,

                /**
                If `true` - html will be escaped in content of element via $.text() method.  
                If `false` - html will not be escaped, $.html() used.  
                When you use own `display` function, this option obviosly has no effect.
                
                @property escape 
                @type boolean
                @since 1.5.0
                @default true
                **/
                escape: true,

                //scope for external methods (e.g. source defined as function)
                //for internal use only
                scope: null,

                //need to re-declare showbuttons here to get it's value from common config (passed only options existing in defaults)
                showbuttons: true
            };

            $.extend($.fn.editabletypes, { abstractinput: AbstractInput });
        })(window.jQuery);

        /**
        List - abstract class for inputs that have source option loaded from js array or via ajax
        
        @class list
        @extends abstractinput
        **/
        (function ($) {
            "use strict";

            var List = function (options) {};

            $.fn.editableutils.inherit(List, $.fn.editabletypes.abstractinput);

            $.extend(List.prototype, {
                render: function () {
                    var deferred = $.Deferred();

                    this.error = null;
                    this.onSourceReady(function () {
                        this.renderList();
                        deferred.resolve();
                    }, function () {
                        this.error = this.options.sourceError;
                        deferred.resolve();
                    });

                    return deferred.promise();
                },

                html2value: function (html) {
                    return null; //can't set value by text
                },

                value2html: function (value, element, display, response) {
                    var deferred = $.Deferred(),
                        success = function () {
                        if (typeof display === 'function') {
                            //custom display method
                            display.call(element, value, this.sourceData, response);
                        } else {
                            this.value2htmlFinal(value, element);
                        }
                        deferred.resolve();
                    };

                    //for null value just call success without loading source
                    if (value === null) {
                        success.call(this);
                    } else {
                        this.onSourceReady(success, function () {
                            deferred.resolve();
                        });
                    }

                    return deferred.promise();
                },

                // ------------- additional functions ------------

                onSourceReady: function (success, error) {
                    //run source if it function
                    var source;
                    if ($.isFunction(this.options.source)) {
                        source = this.options.source.call(this.options.scope);
                        this.sourceData = null;
                        //note: if function returns the same source as URL - sourceData will be taken from cahce and no extra request performed
                    } else {
                        source = this.options.source;
                    }

                    //if allready loaded just call success
                    if (this.options.sourceCache && $.isArray(this.sourceData)) {
                        success.call(this);
                        return;
                    }

                    //try parse json in single quotes (for double quotes jquery does automatically)
                    try {
                        source = $.fn.editableutils.tryParseJson(source, false);
                    } catch (e) {
                        error.call(this);
                        return;
                    }

                    //loading from url
                    if (typeof source === 'string') {
                        //try to get sourceData from cache
                        if (this.options.sourceCache) {
                            var cacheID = source,
                                cache;

                            if (!$(document).data(cacheID)) {
                                $(document).data(cacheID, {});
                            }
                            cache = $(document).data(cacheID);

                            //check for cached data
                            if (cache.loading === false && cache.sourceData) {
                                //take source from cache
                                this.sourceData = cache.sourceData;
                                this.doPrepend();
                                success.call(this);
                                return;
                            } else if (cache.loading === true) {
                                //cache is loading, put callback in stack to be called later
                                cache.callbacks.push($.proxy(function () {
                                    this.sourceData = cache.sourceData;
                                    this.doPrepend();
                                    success.call(this);
                                }, this));

                                //also collecting error callbacks
                                cache.err_callbacks.push($.proxy(error, this));
                                return;
                            } else {
                                //no cache yet, activate it
                                cache.loading = true;
                                cache.callbacks = [];
                                cache.err_callbacks = [];
                            }
                        }

                        //ajaxOptions for source. Can be overwritten bt options.sourceOptions
                        var ajaxOptions = $.extend({
                            url: source,
                            type: 'get',
                            cache: false,
                            dataType: 'json',
                            success: $.proxy(function (data) {
                                if (cache) {
                                    cache.loading = false;
                                }
                                this.sourceData = this.makeArray(data);
                                if ($.isArray(this.sourceData)) {
                                    if (cache) {
                                        //store result in cache
                                        cache.sourceData = this.sourceData;
                                        //run success callbacks for other fields waiting for this source
                                        $.each(cache.callbacks, function () {
                                            this.call();
                                        });
                                    }
                                    this.doPrepend();
                                    success.call(this);
                                } else {
                                    error.call(this);
                                    if (cache) {
                                        //run error callbacks for other fields waiting for this source
                                        $.each(cache.err_callbacks, function () {
                                            this.call();
                                        });
                                    }
                                }
                            }, this),
                            error: $.proxy(function () {
                                error.call(this);
                                if (cache) {
                                    cache.loading = false;
                                    //run error callbacks for other fields
                                    $.each(cache.err_callbacks, function () {
                                        this.call();
                                    });
                                }
                            }, this)
                        }, this.options.sourceOptions);

                        //loading sourceData from server
                        $.ajax(ajaxOptions);
                    } else {
                        //options as json/array
                        this.sourceData = this.makeArray(source);

                        if ($.isArray(this.sourceData)) {
                            this.doPrepend();
                            success.call(this);
                        } else {
                            error.call(this);
                        }
                    }
                },

                doPrepend: function () {
                    if (this.options.prepend === null || this.options.prepend === undefined) {
                        return;
                    }

                    if (!$.isArray(this.prependData)) {
                        //run prepend if it is function (once)
                        if ($.isFunction(this.options.prepend)) {
                            this.options.prepend = this.options.prepend.call(this.options.scope);
                        }

                        //try parse json in single quotes
                        this.options.prepend = $.fn.editableutils.tryParseJson(this.options.prepend, true);

                        //convert prepend from string to object
                        if (typeof this.options.prepend === 'string') {
                            this.options.prepend = { '': this.options.prepend };
                        }

                        this.prependData = this.makeArray(this.options.prepend);
                    }

                    if ($.isArray(this.prependData) && $.isArray(this.sourceData)) {
                        this.sourceData = this.prependData.concat(this.sourceData);
                    }
                },

                /*
                 renders input list
                */
                renderList: function () {
                    // this method should be overwritten in child class
                },

                /*
                set element's html by value
                */
                value2htmlFinal: function (value, element) {
                    // this method should be overwritten in child class
                },

                /**
                * convert data to array suitable for sourceData, e.g. [{value: 1, text: 'abc'}, {...}]
                */
                makeArray: function (data) {
                    var count,
                        obj,
                        result = [],
                        item,
                        iterateItem;
                    if (!data || typeof data === 'string') {
                        return null;
                    }

                    if ($.isArray(data)) {
                        //array
                        /* 
                           function to iterate inside item of array if item is object.
                           Caclulates count of keys in item and store in obj. 
                        */
                        iterateItem = function (k, v) {
                            obj = { value: k, text: v };
                            if (count++ >= 2) {
                                return false; // exit from `each` if item has more than one key.
                            }
                        };

                        for (var i = 0; i < data.length; i++) {
                            item = data[i];
                            if (typeof item === 'object') {
                                count = 0; //count of keys inside item
                                $.each(item, iterateItem);
                                //case: [{val1: 'text1'}, {val2: 'text2} ...]
                                if (count === 1) {
                                    result.push(obj);
                                    //case: [{value: 1, text: 'text1'}, {value: 2, text: 'text2'}, ...]
                                } else if (count > 1) {
                                    //removed check of existance: item.hasOwnProperty('value') && item.hasOwnProperty('text')
                                    if (item.children) {
                                        item.children = this.makeArray(item.children);
                                    }
                                    result.push(item);
                                }
                            } else {
                                //case: ['text1', 'text2' ...]
                                result.push({ value: item, text: item });
                            }
                        }
                    } else {
                        //case: {val1: 'text1', val2: 'text2, ...}
                        $.each(data, function (k, v) {
                            result.push({ value: k, text: v });
                        });
                    }
                    return result;
                },

                option: function (key, value) {
                    this.options[key] = value;
                    if (key === 'source') {
                        this.sourceData = null;
                    }
                    if (key === 'prepend') {
                        this.prependData = null;
                    }
                }

            });

            List.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
                /**
                Source data for list.  
                If **array** - it should be in format: `[{value: 1, text: "text1"}, {value: 2, text: "text2"}, ...]`  
                For compability, object format is also supported: `{"1": "text1", "2": "text2" ...}` but it does not guarantee elements order.
                
                If **string** - considered ajax url to load items. In that case results will be cached for fields with the same source and name. See also `sourceCache` option.
                  
                If **function**, it should return data in format above (since 1.4.0).
                
                Since 1.4.1 key `children` supported to render OPTGROUP (for **select** input only).  
                `[{text: "group1", children: [{value: 1, text: "text1"}, {value: 2, text: "text2"}]}, ...]` 
                    @property source 
                @type string | array | object | function
                @default null
                **/
                source: null,
                /**
                Data automatically prepended to the beginning of dropdown list.
                
                @property prepend 
                @type string | array | object | function
                @default false
                **/
                prepend: false,
                /**
                Error message when list cannot be loaded (e.g. ajax error)
                
                @property sourceError 
                @type string
                @default Error when loading list
                **/
                sourceError: 'Error when loading list',
                /**
                if <code>true</code> and source is **string url** - results will be cached for fields with the same source.    
                Usefull for editable column in grid to prevent extra requests.
                
                @property sourceCache 
                @type boolean
                @default true
                @since 1.2.0
                **/
                sourceCache: true,
                /**
                Additional ajax options to be used in $.ajax() when loading list from server.
                Useful to send extra parameters (`data` key) or change request method (`type` key).
                
                @property sourceOptions 
                @type object|function
                @default null
                @since 1.5.0
                **/
                sourceOptions: null
            });

            $.fn.editabletypes.list = List;
        })(window.jQuery);

        /**
        Text input
        
        @class text
        @extends abstractinput
        @final
        @example
        <a href="#" id="username" data-type="text" data-pk="1">awesome</a>
        <script>
        $(function(){
            $('#username').editable({
                url: '/post',
                title: 'Enter username'
            });
        });
        </script>
        **/
        (function ($) {
            "use strict";

            var Text = function (options) {
                this.init('text', options, Text.defaults);
            };

            $.fn.editableutils.inherit(Text, $.fn.editabletypes.abstractinput);

            $.extend(Text.prototype, {
                render: function () {
                    this.renderClear();
                    this.setClass();
                    this.setAttr('placeholder');
                },

                activate: function () {
                    if (this.$input.is(':visible')) {
                        this.$input.focus();
                        $.fn.editableutils.setCursorPosition(this.$input.get(0), this.$input.val().length);
                        if (this.toggleClear) {
                            this.toggleClear();
                        }
                    }
                },

                //render clear button
                renderClear: function () {
                    if (this.options.clear) {
                        this.$clear = $('<span class="editable-clear-x"></span>');
                        this.$input.after(this.$clear).css('padding-right', 24).keyup($.proxy(function (e) {
                            //arrows, enter, tab, etc
                            if (~$.inArray(e.keyCode, [40, 38, 9, 13, 27])) {
                                return;
                            }

                            clearTimeout(this.t);
                            var that = this;
                            this.t = setTimeout(function () {
                                that.toggleClear(e);
                            }, 100);
                        }, this)).parent().css('position', 'relative');

                        this.$clear.click($.proxy(this.clear, this));
                    }
                },

                postrender: function () {
                    /*
                    //now `clear` is positioned via css
                    if(this.$clear) {
                        //can position clear button only here, when form is shown and height can be calculated
                    //                var h = this.$input.outerHeight(true) || 20,
                        var h = this.$clear.parent().height(),
                            delta = (h - this.$clear.height()) / 2;
                            
                        //this.$clear.css({bottom: delta, right: delta});
                    }
                    */
                },

                //show / hide clear button
                toggleClear: function (e) {
                    if (!this.$clear) {
                        return;
                    }

                    var len = this.$input.val().length,
                        visible = this.$clear.is(':visible');

                    if (len && !visible) {
                        this.$clear.show();
                    }

                    if (!len && visible) {
                        this.$clear.hide();
                    }
                },

                clear: function () {
                    this.$clear.hide();
                    this.$input.val('').focus();
                }
            });

            Text.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
                /**
                @property tpl 
                @default <input type="text">
                **/
                tpl: '<input type="text">',
                /**
                Placeholder attribute of input. Shown when input is empty.
                 @property placeholder 
                @type string
                @default null
                **/
                placeholder: null,

                /**
                Whether to show `clear` button 
                
                @property clear 
                @type boolean
                @default true        
                **/
                clear: true
            });

            $.fn.editabletypes.text = Text;
        })(window.jQuery);

        /**
        Textarea input
        
        @class textarea
        @extends abstractinput
        @final
        @example
        <a href="#" id="comments" data-type="textarea" data-pk="1">awesome comment!</a>
        <script>
        $(function(){
            $('#comments').editable({
                url: '/post',
                title: 'Enter comments',
                rows: 10
            });
        });
        </script>
        **/
        (function ($) {
            "use strict";

            var Textarea = function (options) {
                this.init('textarea', options, Textarea.defaults);
            };

            $.fn.editableutils.inherit(Textarea, $.fn.editabletypes.abstractinput);

            $.extend(Textarea.prototype, {
                render: function () {
                    this.setClass();
                    this.setAttr('placeholder');
                    this.setAttr('rows');

                    //ctrl + enter
                    this.$input.keydown(function (e) {
                        if (e.ctrlKey && e.which === 13) {
                            $(this).closest('form').submit();
                        }
                    });
                },

                //using `white-space: pre-wrap` solves \n  <--> BR conversion very elegant!
                /* 
                value2html: function(value, element) {
                     var html = '', lines;
                     if(value) {
                         lines = value.split("\n");
                         for (var i = 0; i < lines.length; i++) {
                             lines[i] = $('<div>').text(lines[i]).html();
                         }
                         html = lines.join('<br>');
                     }
                     $(element).html(html);
                 },
                
                 html2value: function(html) {
                     if(!html) {
                         return '';
                     }
                      var regex = new RegExp(String.fromCharCode(10), 'g');
                     var lines = html.split(/<br\s*\/?>/i);
                     for (var i = 0; i < lines.length; i++) {
                         var text = $('<div>').html(lines[i]).text();
                          // Remove newline characters (\n) to avoid them being converted by value2html() method
                         // thus adding extra <br> tags
                         text = text.replace(regex, '');
                          lines[i] = text;
                     }
                     return lines.join("\n");
                 },
                  */
                activate: function () {
                    $.fn.editabletypes.text.prototype.activate.call(this);
                }
            });

            Textarea.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
                /**
                @property tpl
                @default <textarea></textarea>
                **/
                tpl: '<textarea></textarea>',
                /**
                @property inputclass
                @default input-large
                **/
                inputclass: 'input-large',
                /**
                Placeholder attribute of input. Shown when input is empty.
                 @property placeholder
                @type string
                @default null
                **/
                placeholder: null,
                /**
                Number of rows in textarea
                 @property rows
                @type integer
                @default 7
                **/
                rows: 7
            });

            $.fn.editabletypes.textarea = Textarea;
        })(window.jQuery);

        /**
        Select (dropdown)
        
        @class select
        @extends list
        @final
        @example
        <a href="#" id="status" data-type="select" data-pk="1" data-url="/post" data-title="Select status"></a>
        <script>
        $(function(){
            $('#status').editable({
                value: 2,    
                source: [
                      {value: 1, text: 'Active'},
                      {value: 2, text: 'Blocked'},
                      {value: 3, text: 'Deleted'}
                   ]
            });
        });
        </script>
        **/
        (function ($) {
            "use strict";

            var Select = function (options) {
                this.init('select', options, Select.defaults);
            };

            $.fn.editableutils.inherit(Select, $.fn.editabletypes.list);

            $.extend(Select.prototype, {
                renderList: function () {
                    this.$input.empty();

                    var fillItems = function ($el, data) {
                        var attr;
                        if ($.isArray(data)) {
                            for (var i = 0; i < data.length; i++) {
                                attr = {};
                                if (data[i].children) {
                                    attr.label = data[i].text;
                                    $el.append(fillItems($('<optgroup>', attr), data[i].children));
                                } else {
                                    attr.value = data[i].value;
                                    if (data[i].disabled) {
                                        attr.disabled = true;
                                    }
                                    $el.append($('<option>', attr).text(data[i].text));
                                }
                            }
                        }
                        return $el;
                    };

                    fillItems(this.$input, this.sourceData);

                    this.setClass();

                    //enter submit
                    this.$input.on('keydown.editable', function (e) {
                        if (e.which === 13) {
                            $(this).closest('form').submit();
                        }
                    });
                },

                value2htmlFinal: function (value, element) {
                    var text = '',
                        items = $.fn.editableutils.itemsByValue(value, this.sourceData);

                    if (items.length) {
                        text = items[0].text;
                    }

                    //$(element).text(text);
                    $.fn.editabletypes.abstractinput.prototype.value2html.call(this, text, element);
                },

                autosubmit: function () {
                    this.$input.off('keydown.editable').on('change.editable', function () {
                        $(this).closest('form').submit();
                    });
                }
            });

            Select.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {
                /**
                @property tpl 
                @default <select></select>
                **/
                tpl: '<select></select>'
            });

            $.fn.editabletypes.select = Select;
        })(window.jQuery);

        /**
        List of checkboxes. 
        Internally value stored as javascript array of values.
        
        @class checklist
        @extends list
        @final
        @example
        <a href="#" id="options" data-type="checklist" data-pk="1" data-url="/post" data-title="Select options"></a>
        <script>
        $(function(){
            $('#options').editable({
                value: [2, 3],    
                source: [
                      {value: 1, text: 'option1'},
                      {value: 2, text: 'option2'},
                      {value: 3, text: 'option3'}
                   ]
            });
        });
        </script>
        **/
        (function ($) {
            "use strict";

            var Checklist = function (options) {
                this.init('checklist', options, Checklist.defaults);
            };

            $.fn.editableutils.inherit(Checklist, $.fn.editabletypes.list);

            $.extend(Checklist.prototype, {
                renderList: function () {
                    var $label, $div;

                    this.$tpl.empty();

                    if (!$.isArray(this.sourceData)) {
                        return;
                    }

                    for (var i = 0; i < this.sourceData.length; i++) {
                        $label = $('<label>').append($('<input>', {
                            type: 'checkbox',
                            value: this.sourceData[i].value
                        })).append($('<span>').text(' ' + this.sourceData[i].text));

                        $('<div>').append($label).appendTo(this.$tpl);
                    }

                    this.$input = this.$tpl.find('input[type="checkbox"]');
                    this.setClass();
                },

                value2str: function (value) {
                    return $.isArray(value) ? value.sort().join($.trim(this.options.separator)) : '';
                },

                //parse separated string
                str2value: function (str) {
                    var reg,
                        value = null;
                    if (typeof str === 'string' && str.length) {
                        reg = new RegExp('\\s*' + $.trim(this.options.separator) + '\\s*');
                        value = str.split(reg);
                    } else if ($.isArray(str)) {
                        value = str;
                    } else {
                        value = [str];
                    }
                    return value;
                },

                //set checked on required checkboxes
                value2input: function (value) {
                    this.$input.prop('checked', false);
                    if ($.isArray(value) && value.length) {
                        this.$input.each(function (i, el) {
                            var $el = $(el);
                            // cannot use $.inArray as it performs strict comparison
                            $.each(value, function (j, val) {
                                /*jslint eqeq: true*/
                                if ($el.val() == val) {
                                    /*jslint eqeq: false*/
                                    $el.prop('checked', true);
                                }
                            });
                        });
                    }
                },

                input2value: function () {
                    var checked = [];
                    this.$input.filter(':checked').each(function (i, el) {
                        checked.push($(el).val());
                    });
                    return checked;
                },

                //collect text of checked boxes
                value2htmlFinal: function (value, element) {
                    var html = [],
                        checked = $.fn.editableutils.itemsByValue(value, this.sourceData),
                        escape = this.options.escape;

                    if (checked.length) {
                        $.each(checked, function (i, v) {
                            var text = escape ? $.fn.editableutils.escape(v.text) : v.text;
                            html.push(text);
                        });
                        $(element).html(html.join('<br>'));
                    } else {
                        $(element).empty();
                    }
                },

                activate: function () {
                    this.$input.first().focus();
                },

                autosubmit: function () {
                    this.$input.on('keydown', function (e) {
                        if (e.which === 13) {
                            $(this).closest('form').submit();
                        }
                    });
                }
            });

            Checklist.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {
                /**
                @property tpl 
                @default <div></div>
                **/
                tpl: '<div class="editable-checklist"></div>',

                /**
                @property inputclass 
                @type string
                @default null
                **/
                inputclass: null,

                /**
                Separator of values when reading from `data-value` attribute
                 @property separator 
                @type string
                @default ','
                **/
                separator: ','
            });

            $.fn.editabletypes.checklist = Checklist;
        })(window.jQuery);

        /**
        HTML5 input types.
        Following types are supported:
        
        * password
        * email
        * url
        * tel
        * number
        * range
        * time
        
        Learn more about html5 inputs:  
        http://www.w3.org/wiki/HTML5_form_additions  
        To check browser compatibility please see:  
        https://developer.mozilla.org/en-US/docs/HTML/Element/Input
                    
        @class html5types 
        @extends text
        @final
        @since 1.3.0
        @example
        <a href="#" id="email" data-type="email" data-pk="1">admin@example.com</a>
        <script>
        $(function(){
            $('#email').editable({
                url: '/post',
                title: 'Enter email'
            });
        });
        </script>
        **/

        /**
        @property tpl 
        @default depends on type
        **/

        /*
        Password
        */
        (function ($) {
            "use strict";

            var Password = function (options) {
                this.init('password', options, Password.defaults);
            };
            $.fn.editableutils.inherit(Password, $.fn.editabletypes.text);
            $.extend(Password.prototype, {
                //do not display password, show '[hidden]' instead
                value2html: function (value, element) {
                    if (value) {
                        $(element).text('[hidden]');
                    } else {
                        $(element).empty();
                    }
                },
                //as password not displayed, should not set value by html
                html2value: function (html) {
                    return null;
                }
            });
            Password.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
                tpl: '<input type="password">'
            });
            $.fn.editabletypes.password = Password;
        })(window.jQuery);

        /*
        Email
        */
        (function ($) {
            "use strict";

            var Email = function (options) {
                this.init('email', options, Email.defaults);
            };
            $.fn.editableutils.inherit(Email, $.fn.editabletypes.text);
            Email.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
                tpl: '<input type="email">'
            });
            $.fn.editabletypes.email = Email;
        })(window.jQuery);

        /*
        Url
        */
        (function ($) {
            "use strict";

            var Url = function (options) {
                this.init('url', options, Url.defaults);
            };
            $.fn.editableutils.inherit(Url, $.fn.editabletypes.text);
            Url.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
                tpl: '<input type="url">'
            });
            $.fn.editabletypes.url = Url;
        })(window.jQuery);

        /*
        Tel
        */
        (function ($) {
            "use strict";

            var Tel = function (options) {
                this.init('tel', options, Tel.defaults);
            };
            $.fn.editableutils.inherit(Tel, $.fn.editabletypes.text);
            Tel.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
                tpl: '<input type="tel">'
            });
            $.fn.editabletypes.tel = Tel;
        })(window.jQuery);

        /*
        Number
        */
        (function ($) {
            "use strict";

            var NumberInput = function (options) {
                this.init('number', options, NumberInput.defaults);
            };
            $.fn.editableutils.inherit(NumberInput, $.fn.editabletypes.text);
            $.extend(NumberInput.prototype, {
                render: function () {
                    NumberInput.superclass.render.call(this);
                    this.setAttr('min');
                    this.setAttr('max');
                    this.setAttr('step');
                },
                postrender: function () {
                    if (this.$clear) {
                        //increase right ffset  for up/down arrows
                        this.$clear.css({ right: 24 });
                        /*
                        //can position clear button only here, when form is shown and height can be calculated
                        var h = this.$input.outerHeight(true) || 20,
                            delta = (h - this.$clear.height()) / 2;
                        
                        //add 12px to offset right for up/down arrows    
                        this.$clear.css({top: delta, right: delta + 16});
                        */
                    }
                }
            });
            NumberInput.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
                tpl: '<input type="number">',
                inputclass: 'input-mini',
                min: null,
                max: null,
                step: null
            });
            $.fn.editabletypes.number = NumberInput;
        })(window.jQuery);

        /*
        Range (inherit from number)
        */
        (function ($) {
            "use strict";

            var Range = function (options) {
                this.init('range', options, Range.defaults);
            };
            $.fn.editableutils.inherit(Range, $.fn.editabletypes.number);
            $.extend(Range.prototype, {
                render: function () {
                    this.$input = this.$tpl.filter('input');

                    this.setClass();
                    this.setAttr('min');
                    this.setAttr('max');
                    this.setAttr('step');

                    this.$input.on('input', function () {
                        $(this).siblings('output').text($(this).val());
                    });
                },
                activate: function () {
                    this.$input.focus();
                }
            });
            Range.defaults = $.extend({}, $.fn.editabletypes.number.defaults, {
                tpl: '<input type="range"><output style="width: 30px; display: inline-block"></output>',
                inputclass: 'input-medium'
            });
            $.fn.editabletypes.range = Range;
        })(window.jQuery);

        /*
        Time
        */
        (function ($) {
            "use strict";

            var Time = function (options) {
                this.init('time', options, Time.defaults);
            };
            //inherit from abstract, as inheritance from text gives selection error.
            $.fn.editableutils.inherit(Time, $.fn.editabletypes.abstractinput);
            $.extend(Time.prototype, {
                render: function () {
                    this.setClass();
                }
            });
            Time.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
                tpl: '<input type="time">'
            });
            $.fn.editabletypes.time = Time;
        })(window.jQuery);

        /**
        Select2 input. Based on amazing work of Igor Vaynberg https://github.com/ivaynberg/select2.  
        Please see [original select2 docs](http://ivaynberg.github.com/select2) for detailed description and options.  
         
        You should manually download and include select2 distributive:  
        
            <link href="select2/select2.css" rel="stylesheet" type="text/css"></link>  
            <script src="select2/select2.js"></script>  
            
        To make it **bootstrap-styled** you can use css from [here](https://github.com/t0m/select2-bootstrap-css): 
        
            <link href="select2-bootstrap.css" rel="stylesheet" type="text/css"></link>    
            
        **Note:** currently `autotext` feature does not work for select2 with `ajax` remote source.    
        You need initially put both `data-value` and element's text youself:    
        
            <a href="#" data-type="select2" data-value="1">Text1</a>
            
            
        @class select2
        @extends abstractinput
        @since 1.4.1
        @final
        @example
        <a href="#" id="country" data-type="select2" data-pk="1" data-value="ru" data-url="/post" data-title="Select country"></a>
        <script>
        $(function(){
            //local source
            $('#country').editable({
                source: [
                      {id: 'gb', text: 'Great Britain'},
                      {id: 'us', text: 'United States'},
                      {id: 'ru', text: 'Russia'}
                   ],
                select2: {
                   multiple: true
                }
            });
            //remote source (simple)
            $('#country').editable({
                source: '/getCountries',
                select2: {
                    placeholder: 'Select Country',
                    minimumInputLength: 1
                }
            });
            //remote source (advanced)
            $('#country').editable({
                select2: {
                    placeholder: 'Select Country',
                    allowClear: true,
                    minimumInputLength: 3,
                    id: function (item) {
                        return item.CountryId;
                    },
                    ajax: {
                        url: '/getCountries',
                        dataType: 'json',
                        data: function (term, page) {
                            return { query: term };
                        },
                        results: function (data, page) {
                            return { results: data };
                        }
                    },
                    formatResult: function (item) {
                        return item.CountryName;
                    },
                    formatSelection: function (item) {
                        return item.CountryName;
                    },
                    initSelection: function (element, callback) {
                        return $.get('/getCountryById', { query: element.val() }, function (data) {
                            callback(data);
                        });
                    } 
                }  
            });
        });
        </script>
        **/
        (function ($) {
            "use strict";

            var Constructor = function (options) {
                this.init('select2', options, Constructor.defaults);

                options.select2 = options.select2 || {};

                this.sourceData = null;

                //placeholder
                if (options.placeholder) {
                    options.select2.placeholder = options.placeholder;
                }

                //if not `tags` mode, use source
                if (!options.select2.tags && options.source) {
                    var source = options.source;
                    //if source is function, call it (once!)
                    if ($.isFunction(options.source)) {
                        source = options.source.call(options.scope);
                    }

                    if (typeof source === 'string') {
                        options.select2.ajax = options.select2.ajax || {};
                        //some default ajax params
                        if (!options.select2.ajax.data) {
                            options.select2.ajax.data = function (term) {
                                return { query: term };
                            };
                        }
                        if (!options.select2.ajax.results) {
                            options.select2.ajax.results = function (data) {
                                return { results: data };
                            };
                        }
                        options.select2.ajax.url = source;
                    } else {
                        //check format and convert x-editable format to select2 format (if needed)
                        this.sourceData = this.convertSource(source);
                        options.select2.data = this.sourceData;
                    }
                }

                //overriding objects in config (as by default jQuery extend() is not recursive)
                this.options.select2 = $.extend({}, Constructor.defaults.select2, options.select2);

                //detect whether it is multi-valued
                this.isMultiple = this.options.select2.tags || this.options.select2.multiple;
                this.isRemote = 'ajax' in this.options.select2;

                //store function returning ID of item
                //should be here as used inautotext for local source
                this.idFunc = this.options.select2.id;
                if (typeof this.idFunc !== "function") {
                    var idKey = this.idFunc || 'id';
                    this.idFunc = function (e) {
                        return e[idKey];
                    };
                }

                //store function that renders text in select2
                this.formatSelection = this.options.select2.formatSelection;
                if (typeof this.formatSelection !== "function") {
                    this.formatSelection = function (e) {
                        return e.text;
                    };
                }
            };

            $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);

            $.extend(Constructor.prototype, {
                render: function () {
                    this.setClass();

                    //can not apply select2 here as it calls initSelection 
                    //over input that does not have correct value yet.
                    //apply select2 only in value2input
                    //this.$input.select2(this.options.select2);

                    //when data is loaded via ajax, we need to know when it's done to populate listData
                    if (this.isRemote) {
                        //listen to loaded event to populate data
                        this.$input.on('select2-loaded', $.proxy(function (e) {
                            this.sourceData = e.items.results;
                        }, this));
                    }

                    //trigger resize of editableform to re-position container in multi-valued mode
                    if (this.isMultiple) {
                        this.$input.on('change', function () {
                            $(this).closest('form').parent().triggerHandler('resize');
                        });
                    }
                },

                value2html: function (value, element) {
                    var text = '',
                        data,
                        that = this;

                    if (this.options.select2.tags) {
                        //in tags mode just assign value
                        data = value;
                        //data = $.fn.editableutils.itemsByValue(value, this.options.select2.tags, this.idFunc);
                    } else if (this.sourceData) {
                        data = $.fn.editableutils.itemsByValue(value, this.sourceData, this.idFunc);
                    } else {}
                    //can not get list of possible values 
                    //(e.g. autotext for select2 with ajax source)


                    //data may be array (when multiple values allowed)
                    if ($.isArray(data)) {
                        //collect selected data and show with separator
                        text = [];
                        $.each(data, function (k, v) {
                            text.push(v && typeof v === 'object' ? that.formatSelection(v) : v);
                        });
                    } else if (data) {
                        text = that.formatSelection(data);
                    }

                    text = $.isArray(text) ? text.join(this.options.viewseparator) : text;

                    //$(element).text(text);
                    Constructor.superclass.value2html.call(this, text, element);
                },

                html2value: function (html) {
                    return this.options.select2.tags ? this.str2value(html, this.options.viewseparator) : null;
                },

                value2input: function (value) {
                    // if value array => join it anyway
                    if ($.isArray(value)) {
                        value = value.join(this.getSeparator());
                    }

                    //for remote source just set value, text is updated by initSelection
                    if (!this.$input.data('select2')) {
                        this.$input.val(value);
                        this.$input.select2(this.options.select2);
                    } else {
                        //second argument needed to separate initial change from user's click (for autosubmit)   
                        this.$input.val(value).trigger('change', true);

                        //Uncaught Error: cannot call val() if initSelection() is not defined
                        //this.$input.select2('val', value);
                    }

                    // if defined remote source AND no multiple mode AND no user's initSelection provided --> 
                    // we should somehow get text for provided id.
                    // The solution is to use element's text as text for that id (exclude empty)
                    if (this.isRemote && !this.isMultiple && !this.options.select2.initSelection) {
                        // customId and customText are methods to extract `id` and `text` from data object
                        // we can use this workaround only if user did not define these methods
                        // otherwise we cant construct data object
                        var customId = this.options.select2.id,
                            customText = this.options.select2.formatSelection;

                        if (!customId && !customText) {
                            var $el = $(this.options.scope);
                            if (!$el.data('editable').isEmpty) {
                                var data = { id: value, text: $el.text() };
                                this.$input.select2('data', data);
                            }
                        }
                    }
                },

                input2value: function () {
                    return this.$input.select2('val');
                },

                str2value: function (str, separator) {
                    if (typeof str !== 'string' || !this.isMultiple) {
                        return str;
                    }

                    separator = separator || this.getSeparator();

                    var val, i, l;

                    if (str === null || str.length < 1) {
                        return null;
                    }
                    val = str.split(separator);
                    for (i = 0, l = val.length; i < l; i = i + 1) {
                        val[i] = $.trim(val[i]);
                    }

                    return val;
                },

                autosubmit: function () {
                    this.$input.on('change', function (e, isInitial) {
                        if (!isInitial) {
                            $(this).closest('form').submit();
                        }
                    });
                },

                getSeparator: function () {
                    return this.options.select2.separator || $.fn.select2.defaults.separator;
                },

                /*
                Converts source from x-editable format: {value: 1, text: "1"} to
                select2 format: {id: 1, text: "1"}
                */
                convertSource: function (source) {
                    if ($.isArray(source) && source.length && source[0].value !== undefined) {
                        for (var i = 0; i < source.length; i++) {
                            if (source[i].value !== undefined) {
                                source[i].id = source[i].value;
                                delete source[i].value;
                            }
                        }
                    }
                    return source;
                },

                destroy: function () {
                    if (this.$input.data('select2')) {
                        this.$input.select2('destroy');
                    }
                }

            });

            Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
                /**
                @property tpl 
                @default <input type="hidden">
                **/
                tpl: '<input type="hidden">',
                /**
                Configuration of select2. [Full list of options](http://ivaynberg.github.com/select2).
                 @property select2 
                @type object
                @default null
                **/
                select2: null,
                /**
                Placeholder attribute of select
                 @property placeholder 
                @type string
                @default null
                **/
                placeholder: null,
                /**
                Source data for select. It will be assigned to select2 `data` property and kept here just for convenience.
                Please note, that format is different from simple `select` input: use 'id' instead of 'value'.
                E.g. `[{id: 1, text: "text1"}, {id: 2, text: "text2"}, ...]`.
                 @property source 
                @type array|string|function
                @default null        
                **/
                source: null,
                /**
                Separator used to display tags.
                 @property viewseparator 
                @type string
                @default ', '        
                **/
                viewseparator: ', '
            });

            $.fn.editabletypes.select2 = Constructor;
        })(window.jQuery);

        /**
        * Combodate - 1.0.5
        * Dropdown date and time picker.
        * Converts text input into dropdowns to pick day, month, year, hour, minute and second.
        * Uses momentjs as datetime library http://momentjs.com.
        * For i18n include corresponding file from https://github.com/timrwood/moment/tree/master/lang 
        *
        * Confusion at noon and midnight - see http://en.wikipedia.org/wiki/12-hour_clock#Confusion_at_noon_and_midnight
        * In combodate: 
        * 12:00 pm --> 12:00 (24-h format, midday)
        * 12:00 am --> 00:00 (24-h format, midnight, start of day)
        * 
        * Differs from momentjs parse rules:
        * 00:00 pm, 12:00 pm --> 12:00 (24-h format, day not change)
        * 00:00 am, 12:00 am --> 00:00 (24-h format, day not change)
        * 
        * 
        * Author: Vitaliy Potapov
        * Project page: http://github.com/vitalets/combodate
        * Copyright (c) 2012 Vitaliy Potapov. Released under MIT License.
        **/
        (function ($) {

            var Combodate = function (element, options) {
                this.$element = $(element);
                if (!this.$element.is('input')) {
                    $.error('Combodate should be applied to INPUT element');
                    return;
                }
                this.options = $.extend({}, $.fn.combodate.defaults, options, this.$element.data());
                this.init();
            };

            Combodate.prototype = {
                constructor: Combodate,
                init: function () {
                    this.map = {
                        //key   regexp    moment.method
                        day: ['D', 'date'],
                        month: ['M', 'month'],
                        year: ['Y', 'year'],
                        hour: ['[Hh]', 'hours'],
                        minute: ['m', 'minutes'],
                        second: ['s', 'seconds'],
                        ampm: ['[Aa]', '']
                    };

                    this.$widget = $('<span class="combodate"></span>').html(this.getTemplate());

                    this.initCombos();

                    //update original input on change 
                    this.$widget.on('change', 'select', $.proxy(function (e) {
                        this.$element.val(this.getValue()).change();
                        // update days count if month or year changes
                        if (this.options.smartDays) {
                            if ($(e.target).is('.month') || $(e.target).is('.year')) {
                                this.fillCombo('day');
                            }
                        }
                    }, this));

                    this.$widget.find('select').css('width', 'auto');

                    // hide original input and insert widget                                       
                    this.$element.hide().after(this.$widget);

                    // set initial value
                    this.setValue(this.$element.val() || this.options.value);
                },

                /*
                 Replace tokens in template with <select> elements 
                */
                getTemplate: function () {
                    var tpl = this.options.template;

                    //first pass
                    $.each(this.map, function (k, v) {
                        v = v[0];
                        var r = new RegExp(v + '+'),
                            token = v.length > 1 ? v.substring(1, 2) : v;

                        tpl = tpl.replace(r, '{' + token + '}');
                    });

                    //replace spaces with &nbsp;
                    tpl = tpl.replace(/ /g, '&nbsp;');

                    //second pass
                    $.each(this.map, function (k, v) {
                        v = v[0];
                        var token = v.length > 1 ? v.substring(1, 2) : v;

                        tpl = tpl.replace('{' + token + '}', '<select class="' + k + '"></select>');
                    });

                    return tpl;
                },

                /*
                 Initialize combos that presents in template 
                */
                initCombos: function () {
                    for (var k in this.map) {
                        var $c = this.$widget.find('.' + k);
                        // set properties like this.$day, this.$month etc.
                        this['$' + k] = $c.length ? $c : null;
                        // fill with items
                        this.fillCombo(k);
                    }
                },

                /*
                 Fill combo with items 
                */
                fillCombo: function (k) {
                    var $combo = this['$' + k];
                    if (!$combo) {
                        return;
                    }

                    // define method name to fill items, e.g `fillDays`
                    var f = 'fill' + k.charAt(0).toUpperCase() + k.slice(1);
                    var items = this[f]();
                    var value = $combo.val();

                    $combo.empty();
                    for (var i = 0; i < items.length; i++) {
                        $combo.append('<option value="' + items[i][0] + '">' + items[i][1] + '</option>');
                    }

                    $combo.val(value);
                },

                /*
                 Initialize items of combos. Handles `firstItem` option 
                */
                fillCommon: function (key) {
                    var values = [],
                        relTime;

                    if (this.options.firstItem === 'name') {
                        //need both to support moment ver < 2 and  >= 2
                        relTime = moment.relativeTime || moment.langData()._relativeTime;
                        var header = typeof relTime[key] === 'function' ? relTime[key](1, true, key, false) : relTime[key];
                        //take last entry (see momentjs lang files structure) 
                        header = header.split(' ').reverse()[0];
                        values.push(['', header]);
                    } else if (this.options.firstItem === 'empty') {
                        values.push(['', '']);
                    }
                    return values;
                },

                /*
                fill day
                */
                fillDay: function () {
                    var items = this.fillCommon('d'),
                        name,
                        i,
                        twoDigit = this.options.template.indexOf('DD') !== -1,
                        daysCount = 31;

                    // detect days count (depends on month and year)
                    // originally https://github.com/vitalets/combodate/pull/7
                    if (this.options.smartDays && this.$month && this.$year) {
                        var month = parseInt(this.$month.val(), 10);
                        var year = parseInt(this.$year.val(), 10);

                        if (!isNaN(month) && !isNaN(year)) {
                            daysCount = moment([year, month]).daysInMonth();
                        }
                    }

                    for (i = 1; i <= daysCount; i++) {
                        name = twoDigit ? this.leadZero(i) : i;
                        items.push([i, name]);
                    }
                    return items;
                },

                /*
                fill month
                */
                fillMonth: function () {
                    var items = this.fillCommon('M'),
                        name,
                        i,
                        longNames = this.options.template.indexOf('MMMM') !== -1,
                        shortNames = this.options.template.indexOf('MMM') !== -1,
                        twoDigit = this.options.template.indexOf('MM') !== -1;

                    for (i = 0; i <= 11; i++) {
                        if (longNames) {
                            //see https://github.com/timrwood/momentjs.com/pull/36
                            name = moment().date(1).month(i).format('MMMM');
                        } else if (shortNames) {
                            name = moment().date(1).month(i).format('MMM');
                        } else if (twoDigit) {
                            name = this.leadZero(i + 1);
                        } else {
                            name = i + 1;
                        }
                        items.push([i, name]);
                    }
                    return items;
                },

                /*
                fill year
                */
                fillYear: function () {
                    var items = [],
                        name,
                        i,
                        longNames = this.options.template.indexOf('YYYY') !== -1;

                    for (i = this.options.maxYear; i >= this.options.minYear; i--) {
                        name = longNames ? i : (i + '').substring(2);
                        items[this.options.yearDescending ? 'push' : 'unshift']([i, name]);
                    }

                    items = this.fillCommon('y').concat(items);

                    return items;
                },

                /*
                fill hour
                */
                fillHour: function () {
                    var items = this.fillCommon('h'),
                        name,
                        i,
                        h12 = this.options.template.indexOf('h') !== -1,
                        h24 = this.options.template.indexOf('H') !== -1,
                        twoDigit = this.options.template.toLowerCase().indexOf('hh') !== -1,
                        min = h12 ? 1 : 0,
                        max = h12 ? 12 : 23;

                    for (i = min; i <= max; i++) {
                        name = twoDigit ? this.leadZero(i) : i;
                        items.push([i, name]);
                    }
                    return items;
                },

                /*
                fill minute
                */
                fillMinute: function () {
                    var items = this.fillCommon('m'),
                        name,
                        i,
                        twoDigit = this.options.template.indexOf('mm') !== -1;

                    for (i = 0; i <= 59; i += this.options.minuteStep) {
                        name = twoDigit ? this.leadZero(i) : i;
                        items.push([i, name]);
                    }
                    return items;
                },

                /*
                fill second
                */
                fillSecond: function () {
                    var items = this.fillCommon('s'),
                        name,
                        i,
                        twoDigit = this.options.template.indexOf('ss') !== -1;

                    for (i = 0; i <= 59; i += this.options.secondStep) {
                        name = twoDigit ? this.leadZero(i) : i;
                        items.push([i, name]);
                    }
                    return items;
                },

                /*
                fill ampm
                */
                fillAmpm: function () {
                    var ampmL = this.options.template.indexOf('a') !== -1,
                        ampmU = this.options.template.indexOf('A') !== -1,
                        items = [['am', ampmL ? 'am' : 'AM'], ['pm', ampmL ? 'pm' : 'PM']];
                    return items;
                },

                /*
                 Returns current date value from combos. 
                 If format not specified - `options.format` used.
                 If format = `null` - Moment object returned.
                */
                getValue: function (format) {
                    var dt,
                        values = {},
                        that = this,
                        notSelected = false;

                    //getting selected values    
                    $.each(this.map, function (k, v) {
                        if (k === 'ampm') {
                            return;
                        }
                        var def = k === 'day' ? 1 : 0;

                        values[k] = that['$' + k] ? parseInt(that['$' + k].val(), 10) : def;

                        if (isNaN(values[k])) {
                            notSelected = true;
                            return false;
                        }
                    });

                    //if at least one visible combo not selected - return empty string
                    if (notSelected) {
                        return '';
                    }

                    //convert hours 12h --> 24h 
                    if (this.$ampm) {
                        //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)
                        if (values.hour === 12) {
                            values.hour = this.$ampm.val() === 'am' ? 0 : 12;
                        } else {
                            values.hour = this.$ampm.val() === 'am' ? values.hour : values.hour + 12;
                        }
                    }

                    dt = moment([values.year, values.month, values.day, values.hour, values.minute, values.second]);

                    //highlight invalid date
                    this.highlight(dt);

                    format = format === undefined ? this.options.format : format;
                    if (format === null) {
                        return dt.isValid() ? dt : null;
                    } else {
                        return dt.isValid() ? dt.format(format) : '';
                    }
                },

                setValue: function (value) {
                    if (!value) {
                        return;
                    }

                    var dt = typeof value === 'string' ? moment(value, this.options.format) : moment(value),
                        that = this,
                        values = {};

                    //function to find nearest value in select options
                    function getNearest($select, value) {
                        var delta = {};
                        $select.children('option').each(function (i, opt) {
                            var optValue = $(opt).attr('value'),
                                distance;

                            if (optValue === '') return;
                            distance = Math.abs(optValue - value);
                            if (typeof delta.distance === 'undefined' || distance < delta.distance) {
                                delta = { value: optValue, distance: distance };
                            }
                        });
                        return delta.value;
                    }

                    if (dt.isValid()) {
                        //read values from date object
                        $.each(this.map, function (k, v) {
                            if (k === 'ampm') {
                                return;
                            }
                            values[k] = dt[v[1]]();
                        });

                        if (this.$ampm) {
                            //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)
                            if (values.hour >= 12) {
                                values.ampm = 'pm';
                                if (values.hour > 12) {
                                    values.hour -= 12;
                                }
                            } else {
                                values.ampm = 'am';
                                if (values.hour === 0) {
                                    values.hour = 12;
                                }
                            }
                        }

                        $.each(values, function (k, v) {
                            //call val() for each existing combo, e.g. this.$hour.val()
                            if (that['$' + k]) {

                                if (k === 'minute' && that.options.minuteStep > 1 && that.options.roundTime) {
                                    v = getNearest(that['$' + k], v);
                                }

                                if (k === 'second' && that.options.secondStep > 1 && that.options.roundTime) {
                                    v = getNearest(that['$' + k], v);
                                }

                                that['$' + k].val(v);
                            }
                        });

                        // update days count
                        if (this.options.smartDays) {
                            this.fillCombo('day');
                        }

                        this.$element.val(dt.format(this.options.format)).change();
                    }
                },

                /*
                 highlight combos if date is invalid
                */
                highlight: function (dt) {
                    if (!dt.isValid()) {
                        if (this.options.errorClass) {
                            this.$widget.addClass(this.options.errorClass);
                        } else {
                            //store original border color
                            if (!this.borderColor) {
                                this.borderColor = this.$widget.find('select').css('border-color');
                            }
                            this.$widget.find('select').css('border-color', 'red');
                        }
                    } else {
                        if (this.options.errorClass) {
                            this.$widget.removeClass(this.options.errorClass);
                        } else {
                            this.$widget.find('select').css('border-color', this.borderColor);
                        }
                    }
                },

                leadZero: function (v) {
                    return v <= 9 ? '0' + v : v;
                },

                destroy: function () {
                    this.$widget.remove();
                    this.$element.removeData('combodate').show();
                }

                //todo: clear method        
            };

            $.fn.combodate = function (option) {
                var d,
                    args = Array.apply(null, arguments);
                args.shift();

                //getValue returns date as string / object (not jQuery object)
                if (option === 'getValue' && this.length && (d = this.eq(0).data('combodate'))) {
                    return d.getValue.apply(d, args);
                }

                return this.each(function () {
                    var $this = $(this),
                        data = $this.data('combodate'),
                        options = typeof option == 'object' && option;
                    if (!data) {
                        $this.data('combodate', data = new Combodate(this, options));
                    }
                    if (typeof option == 'string' && typeof data[option] == 'function') {
                        data[option].apply(data, args);
                    }
                });
            };

            $.fn.combodate.defaults = {
                //in this format value stored in original input
                format: 'DD-MM-YYYY HH:mm',
                //in this format items in dropdowns are displayed
                template: 'D / MMM / YYYY   H : mm',
                //initial value, can be `new Date()`    
                value: null,
                minYear: 1970,
                maxYear: 2015,
                yearDescending: true,
                minuteStep: 5,
                secondStep: 1,
                firstItem: 'empty', //'name', 'empty', 'none'
                errorClass: null,
                roundTime: true, // whether to round minutes and seconds if step > 1
                smartDays: false // whether days in combo depend on selected month: 31, 30, 28
            };
        })(window.jQuery);
        /**
        Combodate input - dropdown date and time picker.    
        Based on [combodate](http://vitalets.github.com/combodate) plugin (included). To use it you should manually include [momentjs](http://momentjs.com).
        
            <script src="js/moment.min.js"></script>
           
        Allows to input:
        
        * only date
        * only time 
        * both date and time  
        
        Please note, that format is taken from momentjs and **not compatible** with bootstrap-datepicker / jquery UI datepicker.  
        Internally value stored as `momentjs` object. 
        
        @class combodate
        @extends abstractinput
        @final
        @since 1.4.0
        @example
        <a href="#" id="dob" data-type="combodate" data-pk="1" data-url="/post" data-value="1984-05-15" data-title="Select date"></a>
        <script>
        $(function(){
            $('#dob').editable({
                format: 'YYYY-MM-DD',    
                viewformat: 'DD.MM.YYYY',    
                template: 'D / MMMM / YYYY',    
                combodate: {
                        minYear: 2000,
                        maxYear: 2015,
                        minuteStep: 1
                   }
                }
            });
        });
        </script>
        **/

        /*global moment*/

        (function ($) {
            "use strict";

            var Constructor = function (options) {
                this.init('combodate', options, Constructor.defaults);

                //by default viewformat equals to format
                if (!this.options.viewformat) {
                    this.options.viewformat = this.options.format;
                }

                //try parse combodate config defined as json string in data-combodate
                options.combodate = $.fn.editableutils.tryParseJson(options.combodate, true);

                //overriding combodate config (as by default jQuery extend() is not recursive)
                this.options.combodate = $.extend({}, Constructor.defaults.combodate, options.combodate, {
                    format: this.options.format,
                    template: this.options.template
                });
            };

            $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);

            $.extend(Constructor.prototype, {
                render: function () {
                    this.$input.combodate(this.options.combodate);

                    if ($.fn.editableform.engine === 'bs3') {
                        this.$input.siblings().find('select').addClass('form-control');
                    }

                    if (this.options.inputclass) {
                        this.$input.siblings().find('select').addClass(this.options.inputclass);
                    }
                    //"clear" link
                    /*
                    if(this.options.clear) {
                        this.$clear = $('<a href="#"></a>').html(this.options.clear).click($.proxy(function(e){
                            e.preventDefault();
                            e.stopPropagation();
                            this.clear();
                        }, this));
                        
                        this.$tpl.parent().append($('<div class="editable-clear">').append(this.$clear));  
                    } 
                    */
                },

                value2html: function (value, element) {
                    var text = value ? value.format(this.options.viewformat) : '';
                    //$(element).text(text);
                    Constructor.superclass.value2html.call(this, text, element);
                },

                html2value: function (html) {
                    return html ? moment(html, this.options.viewformat) : null;
                },

                value2str: function (value) {
                    return value ? value.format(this.options.format) : '';
                },

                str2value: function (str) {
                    return str ? moment(str, this.options.format) : null;
                },

                value2submit: function (value) {
                    return this.value2str(value);
                },

                value2input: function (value) {
                    this.$input.combodate('setValue', value);
                },

                input2value: function () {
                    return this.$input.combodate('getValue', null);
                },

                activate: function () {
                    this.$input.siblings('.combodate').find('select').eq(0).focus();
                },

                /*
                clear:  function() {
                   this.$input.data('datepicker').date = null;
                   this.$input.find('.active').removeClass('active');
                },
                */

                autosubmit: function () {}

            });

            Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
                /**
                @property tpl 
                @default <input type="text">
                **/
                tpl: '<input type="text">',
                /**
                @property inputclass 
                @default null
                **/
                inputclass: null,
                /**
                Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>
                See list of tokens in [momentjs docs](http://momentjs.com/docs/#/parsing/string-format)  
                
                @property format 
                @type string
                @default YYYY-MM-DD
                **/
                format: 'YYYY-MM-DD',
                /**
                Format used for displaying date. Also applied when converting date from element's text on init.   
                If not specified equals to `format`.
                
                @property viewformat 
                @type string
                @default null
                **/
                viewformat: null,
                /**
                Template used for displaying dropdowns.
                
                @property template 
                @type string
                @default D / MMM / YYYY
                **/
                template: 'D / MMM / YYYY',
                /**
                Configuration of combodate.
                Full list of options: http://vitalets.github.com/combodate/#docs
                
                @property combodate 
                @type object
                @default null
                **/
                combodate: null

                /*
                (not implemented yet)
                Text shown as clear date button. 
                If <code>false</code> clear button will not be rendered.
                
                @property clear 
                @type boolean|string
                @default 'x clear'         
                */
                //clear: '&times; clear'
            });

            $.fn.editabletypes.combodate = Constructor;
        })(window.jQuery);

        /*
        Editableform based on Twitter Bootstrap 3
        */
        (function ($) {
            "use strict";

            //store parent methods

            var pInitInput = $.fn.editableform.Constructor.prototype.initInput;

            $.extend($.fn.editableform.Constructor.prototype, {
                initTemplate: function () {
                    this.$form = $($.fn.editableform.template);
                    this.$form.find('.control-group').addClass('form-group');
                    this.$form.find('.editable-error-block').addClass('help-block');
                },
                initInput: function () {
                    pInitInput.apply(this);

                    //for bs3 set default class `input-sm` to standard inputs
                    var emptyInputClass = this.input.options.inputclass === null || this.input.options.inputclass === false;
                    var defaultClass = 'input-sm';

                    //bs3 add `form-control` class to standard inputs
                    var stdtypes = 'text,select,textarea,password,email,url,tel,number,range,time,typeaheadjs'.split(',');
                    if (~$.inArray(this.input.type, stdtypes)) {
                        this.input.$input.addClass('form-control');
                        if (emptyInputClass) {
                            this.input.options.inputclass = defaultClass;
                            this.input.$input.addClass(defaultClass);
                        }
                    }

                    //apply bs3 size class also to buttons (to fit size of control)
                    var $btn = this.$form.find('.editable-buttons');
                    var classes = emptyInputClass ? [defaultClass] : this.input.options.inputclass.split(' ');
                    for (var i = 0; i < classes.length; i++) {
                        // `btn-sm` is default now
                        /*
                        if(classes[i].toLowerCase() === 'input-sm') { 
                            $btn.find('button').addClass('btn-sm');  
                        }
                        */
                        if (classes[i].toLowerCase() === 'input-lg') {
                            $btn.find('button').removeClass('btn-sm').addClass('btn-lg');
                        }
                    }
                }
            });

            //buttons
            $.fn.editableform.buttons = '<button type="submit" class="btn btn-primary btn-sm editable-submit">' + '<i class="glyphicon glyphicon-ok"></i>' + '</button>' + '<button type="button" class="btn btn-default btn-sm editable-cancel">' + '<i class="glyphicon glyphicon-remove"></i>' + '</button>';

            //error classes
            $.fn.editableform.errorGroupClass = 'has-error';
            $.fn.editableform.errorBlockClass = null;
            //engine
            $.fn.editableform.engine = 'bs3';
        })(window.jQuery);
        /**
        * Editable Popover3 (for Bootstrap 3) 
        * ---------------------
        * requires bootstrap-popover.js
        */
        (function ($) {
            "use strict";

            //extend methods

            $.extend($.fn.editableContainer.Popup.prototype, {
                containerName: 'popover',
                containerDataName: 'bs.popover',
                innerCss: '.popover-content',
                defaults: $.fn.popover.Constructor.DEFAULTS,

                initContainer: function () {
                    $.extend(this.containerOptions, {
                        trigger: 'manual',
                        selector: false,
                        content: ' ',
                        template: this.defaults.template
                    });

                    //as template property is used in inputs, hide it from popover
                    var t;
                    if (this.$element.data('template')) {
                        t = this.$element.data('template');
                        this.$element.removeData('template');
                    }

                    this.call(this.containerOptions);

                    if (t) {
                        //restore data('template')
                        this.$element.data('template', t);
                    }
                },

                /* show */
                innerShow: function () {
                    this.call('show');
                },

                /* hide */
                innerHide: function () {
                    this.call('hide');
                },

                /* destroy */
                innerDestroy: function () {
                    this.call('destroy');
                },

                setContainerOption: function (key, value) {
                    this.container().options[key] = value;
                },

                /**
                * move popover to new position. This function mainly copied from bootstrap-popover.
                */
                /*jshint laxcomma: true, eqeqeq: false*/
                setPosition: function () {

                    (function () {
                        /*    
                            var $tip = this.tip()
                            , inside
                            , pos
                            , actualWidth
                            , actualHeight
                            , placement
                            , tp
                            , tpt
                            , tpb
                            , tpl
                            , tpr;
                             placement = typeof this.options.placement === 'function' ?
                            this.options.placement.call(this, $tip[0], this.$element[0]) :
                            this.options.placement;
                             inside = /in/.test(placement);
                           
                            $tip
                          //  .detach()
                          //vitalets: remove any placement class because otherwise they dont influence on re-positioning of visible popover
                            .removeClass('top right bottom left')
                            .css({ top: 0, left: 0, display: 'block' });
                          //  .insertAfter(this.$element);
                           
                            pos = this.getPosition(inside);
                             actualWidth = $tip[0].offsetWidth;
                            actualHeight = $tip[0].offsetHeight;
                             placement = inside ? placement.split(' ')[1] : placement;
                             tpb = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2};
                            tpt = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2};
                            tpl = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth};
                            tpr = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width};
                             switch (placement) {
                                case 'bottom':
                                    if ((tpb.top + actualHeight) > ($(window).scrollTop() + $(window).height())) {
                                        if (tpt.top > $(window).scrollTop()) {
                                            placement = 'top';
                                        } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {
                                            placement = 'right';
                                        } else if (tpl.left > $(window).scrollLeft()) {
                                            placement = 'left';
                                        } else {
                                            placement = 'right';
                                        }
                                    }
                                    break;
                                case 'top':
                                    if (tpt.top < $(window).scrollTop()) {
                                        if ((tpb.top + actualHeight) < ($(window).scrollTop() + $(window).height())) {
                                            placement = 'bottom';
                                        } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {
                                            placement = 'right';
                                        } else if (tpl.left > $(window).scrollLeft()) {
                                            placement = 'left';
                                        } else {
                                            placement = 'right';
                                        }
                                    }
                                    break;
                                case 'left':
                                    if (tpl.left < $(window).scrollLeft()) {
                                        if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {
                                            placement = 'right';
                                        } else if (tpt.top > $(window).scrollTop()) {
                                            placement = 'top';
                                        } else if (tpt.top > $(window).scrollTop()) {
                                            placement = 'bottom';
                                        } else {
                                            placement = 'right';
                                        }
                                    }
                                    break;
                                case 'right':
                                    if ((tpr.left + actualWidth) > ($(window).scrollLeft() + $(window).width())) {
                                        if (tpl.left > $(window).scrollLeft()) {
                                            placement = 'left';
                                        } else if (tpt.top > $(window).scrollTop()) {
                                            placement = 'top';
                                        } else if (tpt.top > $(window).scrollTop()) {
                                            placement = 'bottom';
                                        }
                                    }
                                    break;
                            }
                             switch (placement) {
                                case 'bottom':
                                    tp = tpb;
                                    break;
                                case 'top':
                                    tp = tpt;
                                    break;
                                case 'left':
                                    tp = tpl;
                                    break;
                                case 'right':
                                    tp = tpr;
                                    break;
                            }
                             $tip
                            .offset(tp)
                            .addClass(placement)
                            .addClass('in');
                        */

                        var $tip = this.tip();

                        var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;

                        var autoToken = /\s?auto?\s?/i;
                        var autoPlace = autoToken.test(placement);
                        if (autoPlace) {
                            placement = placement.replace(autoToken, '') || 'top';
                        }

                        var pos = this.getPosition();
                        var actualWidth = $tip[0].offsetWidth;
                        var actualHeight = $tip[0].offsetHeight;

                        if (autoPlace) {
                            var $parent = this.$element.parent();

                            var orgPlacement = placement;
                            var docScroll = document.documentElement.scrollTop || document.body.scrollTop;
                            var parentWidth = this.options.container == 'body' ? window.innerWidth : $parent.outerWidth();
                            var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight();
                            var parentLeft = this.options.container == 'body' ? 0 : $parent.offset().left;

                            placement = placement == 'bottom' && pos.top + pos.height + actualHeight - docScroll > parentHeight ? 'top' : placement == 'top' && pos.top - docScroll - actualHeight < 0 ? 'bottom' : placement == 'right' && pos.right + actualWidth > parentWidth ? 'left' : placement == 'left' && pos.left - actualWidth < parentLeft ? 'right' : placement;

                            $tip.removeClass(orgPlacement).addClass(placement);
                        }

                        var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);

                        this.applyPlacement(calculatedOffset, placement);
                    }).call(this.container());
                    /*jshint laxcomma: false, eqeqeq: true*/
                }
            });
        })(window.jQuery);

        /* =========================================================
         * bootstrap-datepicker.js
         * http://www.eyecon.ro/bootstrap-datepicker
         * =========================================================
         * Copyright 2012 Stefan Petre
         * Improvements by Andrew Rowls
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         * ========================================================= */

        (function ($) {

            function UTCDate() {
                return new Date(Date.UTC.apply(Date, arguments));
            }
            function UTCToday() {
                var today = new Date();
                return UTCDate(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate());
            }

            // Picker object

            var Datepicker = function (element, options) {
                var that = this;

                this._process_options(options);

                this.element = $(element);
                this.isInline = false;
                this.isInput = this.element.is('input');
                this.component = this.element.is('.date') ? this.element.find('.add-on, .btn') : false;
                this.hasInput = this.component && this.element.find('input').length;
                if (this.component && this.component.length === 0) this.component = false;

                this.picker = $(DPGlobal.template);
                this._buildEvents();
                this._attachEvents();

                if (this.isInline) {
                    this.picker.addClass('datepicker-inline').appendTo(this.element);
                } else {
                    this.picker.addClass('datepicker-dropdown dropdown-menu');
                }

                if (this.o.rtl) {
                    this.picker.addClass('datepicker-rtl');
                    this.picker.find('.prev i, .next i').toggleClass('icon-arrow-left icon-arrow-right');
                }

                this.viewMode = this.o.startView;

                if (this.o.calendarWeeks) this.picker.find('tfoot th.today').attr('colspan', function (i, val) {
                    return parseInt(val) + 1;
                });

                this._allow_update = false;

                this.setStartDate(this.o.startDate);
                this.setEndDate(this.o.endDate);
                this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);

                this.fillDow();
                this.fillMonths();

                this._allow_update = true;

                this.update();
                this.showMode();

                if (this.isInline) {
                    this.show();
                }
            };

            Datepicker.prototype = {
                constructor: Datepicker,

                _process_options: function (opts) {
                    // Store raw options for reference
                    this._o = $.extend({}, this._o, opts);
                    // Processed options
                    var o = this.o = $.extend({}, this._o);

                    // Check if "de-DE" style date is available, if not language should
                    // fallback to 2 letter code eg "de"
                    var lang = o.language;
                    if (!dates[lang]) {
                        lang = lang.split('-')[0];
                        if (!dates[lang]) lang = defaults.language;
                    }
                    o.language = lang;

                    switch (o.startView) {
                        case 2:
                        case 'decade':
                            o.startView = 2;
                            break;
                        case 1:
                        case 'year':
                            o.startView = 1;
                            break;
                        default:
                            o.startView = 0;
                    }

                    switch (o.minViewMode) {
                        case 1:
                        case 'months':
                            o.minViewMode = 1;
                            break;
                        case 2:
                        case 'years':
                            o.minViewMode = 2;
                            break;
                        default:
                            o.minViewMode = 0;
                    }

                    o.startView = Math.max(o.startView, o.minViewMode);

                    o.weekStart %= 7;
                    o.weekEnd = (o.weekStart + 6) % 7;

                    var format = DPGlobal.parseFormat(o.format);
                    if (o.startDate !== -Infinity) {
                        o.startDate = DPGlobal.parseDate(o.startDate, format, o.language);
                    }
                    if (o.endDate !== Infinity) {
                        o.endDate = DPGlobal.parseDate(o.endDate, format, o.language);
                    }

                    o.daysOfWeekDisabled = o.daysOfWeekDisabled || [];
                    if (!$.isArray(o.daysOfWeekDisabled)) o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\s]*/);
                    o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function (d) {
                        return parseInt(d, 10);
                    });
                },
                _events: [],
                _secondaryEvents: [],
                _applyEvents: function (evs) {
                    for (var i = 0, el, ev; i < evs.length; i++) {
                        el = evs[i][0];
                        ev = evs[i][1];
                        el.on(ev);
                    }
                },
                _unapplyEvents: function (evs) {
                    for (var i = 0, el, ev; i < evs.length; i++) {
                        el = evs[i][0];
                        ev = evs[i][1];
                        el.off(ev);
                    }
                },
                _buildEvents: function () {
                    if (this.isInput) {
                        // single input
                        this._events = [[this.element, {
                            focus: $.proxy(this.show, this),
                            keyup: $.proxy(this.update, this),
                            keydown: $.proxy(this.keydown, this)
                        }]];
                    } else if (this.component && this.hasInput) {
                        // component: input + button
                        this._events = [
                        // For components that are not readonly, allow keyboard nav
                        [this.element.find('input'), {
                            focus: $.proxy(this.show, this),
                            keyup: $.proxy(this.update, this),
                            keydown: $.proxy(this.keydown, this)
                        }], [this.component, {
                            click: $.proxy(this.show, this)
                        }]];
                    } else if (this.element.is('div')) {
                        // inline datepicker
                        this.isInline = true;
                    } else {
                        this._events = [[this.element, {
                            click: $.proxy(this.show, this)
                        }]];
                    }

                    this._secondaryEvents = [[this.picker, {
                        click: $.proxy(this.click, this)
                    }], [$(window), {
                        resize: $.proxy(this.place, this)
                    }], [$(document), {
                        mousedown: $.proxy(function (e) {
                            // Clicked outside the datepicker, hide it
                            if (!(this.element.is(e.target) || this.element.find(e.target).size() || this.picker.is(e.target) || this.picker.find(e.target).size())) {
                                this.hide();
                            }
                        }, this)
                    }]];
                },
                _attachEvents: function () {
                    this._detachEvents();
                    this._applyEvents(this._events);
                },
                _detachEvents: function () {
                    this._unapplyEvents(this._events);
                },
                _attachSecondaryEvents: function () {
                    this._detachSecondaryEvents();
                    this._applyEvents(this._secondaryEvents);
                },
                _detachSecondaryEvents: function () {
                    this._unapplyEvents(this._secondaryEvents);
                },
                _trigger: function (event, altdate) {
                    var date = altdate || this.date,
                        local_date = new Date(date.getTime() + date.getTimezoneOffset() * 60000);

                    this.element.trigger({
                        type: event,
                        date: local_date,
                        format: $.proxy(function (altformat) {
                            var format = altformat || this.o.format;
                            return DPGlobal.formatDate(date, format, this.o.language);
                        }, this)
                    });
                },

                show: function (e) {
                    if (!this.isInline) this.picker.appendTo('body');
                    this.picker.show();
                    this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
                    this.place();
                    this._attachSecondaryEvents();
                    if (e) {
                        e.preventDefault();
                    }
                    this._trigger('show');
                },

                hide: function (e) {
                    if (this.isInline) return;
                    if (!this.picker.is(':visible')) return;
                    this.picker.hide().detach();
                    this._detachSecondaryEvents();
                    this.viewMode = this.o.startView;
                    this.showMode();

                    if (this.o.forceParse && (this.isInput && this.element.val() || this.hasInput && this.element.find('input').val())) this.setValue();
                    this._trigger('hide');
                },

                remove: function () {
                    this.hide();
                    this._detachEvents();
                    this._detachSecondaryEvents();
                    this.picker.remove();
                    delete this.element.data().datepicker;
                    if (!this.isInput) {
                        delete this.element.data().date;
                    }
                },

                getDate: function () {
                    var d = this.getUTCDate();
                    return new Date(d.getTime() + d.getTimezoneOffset() * 60000);
                },

                getUTCDate: function () {
                    return this.date;
                },

                setDate: function (d) {
                    this.setUTCDate(new Date(d.getTime() - d.getTimezoneOffset() * 60000));
                },

                setUTCDate: function (d) {
                    this.date = d;
                    this.setValue();
                },

                setValue: function () {
                    var formatted = this.getFormattedDate();
                    if (!this.isInput) {
                        if (this.component) {
                            this.element.find('input').val(formatted);
                        }
                    } else {
                        this.element.val(formatted);
                    }
                },

                getFormattedDate: function (format) {
                    if (format === undefined) format = this.o.format;
                    return DPGlobal.formatDate(this.date, format, this.o.language);
                },

                setStartDate: function (startDate) {
                    this._process_options({ startDate: startDate });
                    this.update();
                    this.updateNavArrows();
                },

                setEndDate: function (endDate) {
                    this._process_options({ endDate: endDate });
                    this.update();
                    this.updateNavArrows();
                },

                setDaysOfWeekDisabled: function (daysOfWeekDisabled) {
                    this._process_options({ daysOfWeekDisabled: daysOfWeekDisabled });
                    this.update();
                    this.updateNavArrows();
                },

                place: function () {
                    if (this.isInline) return;
                    var zIndex = parseInt(this.element.parents().filter(function () {
                        return $(this).css('z-index') != 'auto';
                    }).first().css('z-index')) + 10;
                    var offset = this.component ? this.component.parent().offset() : this.element.offset();
                    var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(true);
                    this.picker.css({
                        top: offset.top + height,
                        left: offset.left,
                        zIndex: zIndex
                    });
                },

                _allow_update: true,
                update: function () {
                    if (!this._allow_update) return;

                    var date,
                        fromArgs = false;
                    if (arguments && arguments.length && (typeof arguments[0] === 'string' || arguments[0] instanceof Date)) {
                        date = arguments[0];
                        fromArgs = true;
                    } else {
                        date = this.isInput ? this.element.val() : this.element.data('date') || this.element.find('input').val();
                        delete this.element.data().date;
                    }

                    this.date = DPGlobal.parseDate(date, this.o.format, this.o.language);

                    if (fromArgs) this.setValue();

                    if (this.date < this.o.startDate) {
                        this.viewDate = new Date(this.o.startDate);
                    } else if (this.date > this.o.endDate) {
                        this.viewDate = new Date(this.o.endDate);
                    } else {
                        this.viewDate = new Date(this.date);
                    }
                    this.fill();
                },

                fillDow: function () {
                    var dowCnt = this.o.weekStart,
                        html = '<tr>';
                    if (this.o.calendarWeeks) {
                        var cell = '<th class="cw">&nbsp;</th>';
                        html += cell;
                        this.picker.find('.datepicker-days thead tr:first-child').prepend(cell);
                    }
                    while (dowCnt < this.o.weekStart + 7) {
                        html += '<th class="dow">' + dates[this.o.language].daysMin[dowCnt++ % 7] + '</th>';
                    }
                    html += '</tr>';
                    this.picker.find('.datepicker-days thead').append(html);
                },

                fillMonths: function () {
                    var html = '',
                        i = 0;
                    while (i < 12) {
                        html += '<span class="month">' + dates[this.o.language].monthsShort[i++] + '</span>';
                    }
                    this.picker.find('.datepicker-months td').html(html);
                },

                setRange: function (range) {
                    if (!range || !range.length) delete this.range;else this.range = $.map(range, function (d) {
                        return d.valueOf();
                    });
                    this.fill();
                },

                getClassNames: function (date) {
                    var cls = [],
                        year = this.viewDate.getUTCFullYear(),
                        month = this.viewDate.getUTCMonth(),
                        currentDate = this.date.valueOf(),
                        today = new Date();
                    if (date.getUTCFullYear() < year || date.getUTCFullYear() == year && date.getUTCMonth() < month) {
                        cls.push('old');
                    } else if (date.getUTCFullYear() > year || date.getUTCFullYear() == year && date.getUTCMonth() > month) {
                        cls.push('new');
                    }
                    // Compare internal UTC date with local today, not UTC today
                    if (this.o.todayHighlight && date.getUTCFullYear() == today.getFullYear() && date.getUTCMonth() == today.getMonth() && date.getUTCDate() == today.getDate()) {
                        cls.push('today');
                    }
                    if (currentDate && date.valueOf() == currentDate) {
                        cls.push('active');
                    }
                    if (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate || $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1) {
                        cls.push('disabled');
                    }
                    if (this.range) {
                        if (date > this.range[0] && date < this.range[this.range.length - 1]) {
                            cls.push('range');
                        }
                        if ($.inArray(date.valueOf(), this.range) != -1) {
                            cls.push('selected');
                        }
                    }
                    return cls;
                },

                fill: function () {
                    var d = new Date(this.viewDate),
                        year = d.getUTCFullYear(),
                        month = d.getUTCMonth(),
                        startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
                        startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
                        endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
                        endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
                        currentDate = this.date && this.date.valueOf(),
                        tooltip;
                    this.picker.find('.datepicker-days thead th.datepicker-switch').text(dates[this.o.language].months[month] + ' ' + year);
                    this.picker.find('tfoot th.today').text(dates[this.o.language].today).toggle(this.o.todayBtn !== false);
                    this.picker.find('tfoot th.clear').text(dates[this.o.language].clear).toggle(this.o.clearBtn !== false);
                    this.updateNavArrows();
                    this.fillMonths();
                    var prevMonth = UTCDate(year, month - 1, 28, 0, 0, 0, 0),
                        day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
                    prevMonth.setUTCDate(day);
                    prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7) % 7);
                    var nextMonth = new Date(prevMonth);
                    nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
                    nextMonth = nextMonth.valueOf();
                    var html = [];
                    var clsName;
                    while (prevMonth.valueOf() < nextMonth) {
                        if (prevMonth.getUTCDay() == this.o.weekStart) {
                            html.push('<tr>');
                            if (this.o.calendarWeeks) {
                                // ISO 8601: First week contains first thursday.
                                // ISO also states week starts on Monday, but we can be more abstract here.
                                var
                                // Start of current week: based on weekstart/current date
                                ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),

                                // Thursday of this week
                                th = new Date(+ws + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),

                                // First Thursday of year, year from thursday
                                yth = new Date(+(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),

                                // Calendar week: ms between thursdays, div ms per day, div 7 days
                                calWeek = (th - yth) / 864e5 / 7 + 1;
                                html.push('<td class="cw">' + calWeek + '</td>');
                            }
                        }
                        clsName = this.getClassNames(prevMonth);
                        clsName.push('day');

                        var before = this.o.beforeShowDay(prevMonth);
                        if (before === undefined) before = {};else if (typeof before === 'boolean') before = { enabled: before };else if (typeof before === 'string') before = { classes: before };
                        if (before.enabled === false) clsName.push('disabled');
                        if (before.classes) clsName = clsName.concat(before.classes.split(/\s+/));
                        if (before.tooltip) tooltip = before.tooltip;

                        clsName = $.unique(clsName);
                        html.push('<td class="' + clsName.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + prevMonth.getUTCDate() + '</td>');
                        if (prevMonth.getUTCDay() == this.o.weekEnd) {
                            html.push('</tr>');
                        }
                        prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
                    }
                    this.picker.find('.datepicker-days tbody').empty().append(html.join(''));
                    var currentYear = this.date && this.date.getUTCFullYear();

                    var months = this.picker.find('.datepicker-months').find('th:eq(1)').text(year).end().find('span').removeClass('active');
                    if (currentYear && currentYear == year) {
                        months.eq(this.date.getUTCMonth()).addClass('active');
                    }
                    if (year < startYear || year > endYear) {
                        months.addClass('disabled');
                    }
                    if (year == startYear) {
                        months.slice(0, startMonth).addClass('disabled');
                    }
                    if (year == endYear) {
                        months.slice(endMonth + 1).addClass('disabled');
                    }

                    html = '';
                    year = parseInt(year / 10, 10) * 10;
                    var yearCont = this.picker.find('.datepicker-years').find('th:eq(1)').text(year + '-' + (year + 9)).end().find('td');
                    year -= 1;
                    for (var i = -1; i < 11; i++) {
                        html += '<span class="year' + (i == -1 ? ' old' : i == 10 ? ' new' : '') + (currentYear == year ? ' active' : '') + (year < startYear || year > endYear ? ' disabled' : '') + '">' + year + '</span>';
                        year += 1;
                    }
                    yearCont.html(html);
                },

                updateNavArrows: function () {
                    if (!this._allow_update) return;

                    var d = new Date(this.viewDate),
                        year = d.getUTCFullYear(),
                        month = d.getUTCMonth();
                    switch (this.viewMode) {
                        case 0:
                            if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()) {
                                this.picker.find('.prev').css({ visibility: 'hidden' });
                            } else {
                                this.picker.find('.prev').css({ visibility: 'visible' });
                            }
                            if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()) {
                                this.picker.find('.next').css({ visibility: 'hidden' });
                            } else {
                                this.picker.find('.next').css({ visibility: 'visible' });
                            }
                            break;
                        case 1:
                        case 2:
                            if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()) {
                                this.picker.find('.prev').css({ visibility: 'hidden' });
                            } else {
                                this.picker.find('.prev').css({ visibility: 'visible' });
                            }
                            if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()) {
                                this.picker.find('.next').css({ visibility: 'hidden' });
                            } else {
                                this.picker.find('.next').css({ visibility: 'visible' });
                            }
                            break;
                    }
                },

                click: function (e) {
                    e.preventDefault();
                    var target = $(e.target).closest('span, td, th');
                    if (target.length == 1) {
                        switch (target[0].nodeName.toLowerCase()) {
                            case 'th':
                                switch (target[0].className) {
                                    case 'datepicker-switch':
                                        this.showMode(1);
                                        break;
                                    case 'prev':
                                    case 'next':
                                        var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);
                                        switch (this.viewMode) {
                                            case 0:
                                                this.viewDate = this.moveMonth(this.viewDate, dir);
                                                break;
                                            case 1:
                                            case 2:
                                                this.viewDate = this.moveYear(this.viewDate, dir);
                                                break;
                                        }
                                        this.fill();
                                        break;
                                    case 'today':
                                        var date = new Date();
                                        date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);

                                        this.showMode(-2);
                                        var which = this.o.todayBtn == 'linked' ? null : 'view';
                                        this._setDate(date, which);
                                        break;
                                    case 'clear':
                                        var element;
                                        if (this.isInput) element = this.element;else if (this.component) element = this.element.find('input');
                                        if (element) element.val("").change();
                                        this._trigger('changeDate');
                                        this.update();
                                        if (this.o.autoclose) this.hide();
                                        break;
                                }
                                break;
                            case 'span':
                                if (!target.is('.disabled')) {
                                    this.viewDate.setUTCDate(1);
                                    if (target.is('.month')) {
                                        var day = 1;
                                        var month = target.parent().find('span').index(target);
                                        var year = this.viewDate.getUTCFullYear();
                                        this.viewDate.setUTCMonth(month);
                                        this._trigger('changeMonth', this.viewDate);
                                        if (this.o.minViewMode === 1) {
                                            this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));
                                        }
                                    } else {
                                        var year = parseInt(target.text(), 10) || 0;
                                        var day = 1;
                                        var month = 0;
                                        this.viewDate.setUTCFullYear(year);
                                        this._trigger('changeYear', this.viewDate);
                                        if (this.o.minViewMode === 2) {
                                            this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));
                                        }
                                    }
                                    this.showMode(-1);
                                    this.fill();
                                }
                                break;
                            case 'td':
                                if (target.is('.day') && !target.is('.disabled')) {
                                    var day = parseInt(target.text(), 10) || 1;
                                    var year = this.viewDate.getUTCFullYear(),
                                        month = this.viewDate.getUTCMonth();
                                    if (target.is('.old')) {
                                        if (month === 0) {
                                            month = 11;
                                            year -= 1;
                                        } else {
                                            month -= 1;
                                        }
                                    } else if (target.is('.new')) {
                                        if (month == 11) {
                                            month = 0;
                                            year += 1;
                                        } else {
                                            month += 1;
                                        }
                                    }
                                    this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));
                                }
                                break;
                        }
                    }
                },

                _setDate: function (date, which) {
                    if (!which || which == 'date') this.date = new Date(date);
                    if (!which || which == 'view') this.viewDate = new Date(date);
                    this.fill();
                    this.setValue();
                    this._trigger('changeDate');
                    var element;
                    if (this.isInput) {
                        element = this.element;
                    } else if (this.component) {
                        element = this.element.find('input');
                    }
                    if (element) {
                        element.change();
                        if (this.o.autoclose && (!which || which == 'date')) {
                            this.hide();
                        }
                    }
                },

                moveMonth: function (date, dir) {
                    if (!dir) return date;
                    var new_date = new Date(date.valueOf()),
                        day = new_date.getUTCDate(),
                        month = new_date.getUTCMonth(),
                        mag = Math.abs(dir),
                        new_month,
                        test;
                    dir = dir > 0 ? 1 : -1;
                    if (mag == 1) {
                        test = dir == -1
                        // If going back one month, make sure month is not current month
                        // (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
                        ? function () {
                            return new_date.getUTCMonth() == month;
                        }
                        // If going forward one month, make sure month is as expected
                        // (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
                        : function () {
                            return new_date.getUTCMonth() != new_month;
                        };
                        new_month = month + dir;
                        new_date.setUTCMonth(new_month);
                        // Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
                        if (new_month < 0 || new_month > 11) new_month = (new_month + 12) % 12;
                    } else {
                        // For magnitudes >1, move one month at a time...
                        for (var i = 0; i < mag; i++)
                        // ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
                        new_date = this.moveMonth(new_date, dir);
                        // ...then reset the day, keeping it in the new month
                        new_month = new_date.getUTCMonth();
                        new_date.setUTCDate(day);
                        test = function () {
                            return new_month != new_date.getUTCMonth();
                        };
                    }
                    // Common date-resetting loop -- if date is beyond end of month, make it
                    // end of month
                    while (test()) {
                        new_date.setUTCDate(--day);
                        new_date.setUTCMonth(new_month);
                    }
                    return new_date;
                },

                moveYear: function (date, dir) {
                    return this.moveMonth(date, dir * 12);
                },

                dateWithinRange: function (date) {
                    return date >= this.o.startDate && date <= this.o.endDate;
                },

                keydown: function (e) {
                    if (this.picker.is(':not(:visible)')) {
                        if (e.keyCode == 27) // allow escape to hide and re-show picker
                            this.show();
                        return;
                    }
                    var dateChanged = false,
                        dir,
                        day,
                        month,
                        newDate,
                        newViewDate;
                    switch (e.keyCode) {
                        case 27:
                            // escape
                            this.hide();
                            e.preventDefault();
                            break;
                        case 37: // left
                        case 39:
                            // right
                            if (!this.o.keyboardNavigation) break;
                            dir = e.keyCode == 37 ? -1 : 1;
                            if (e.ctrlKey) {
                                newDate = this.moveYear(this.date, dir);
                                newViewDate = this.moveYear(this.viewDate, dir);
                            } else if (e.shiftKey) {
                                newDate = this.moveMonth(this.date, dir);
                                newViewDate = this.moveMonth(this.viewDate, dir);
                            } else {
                                newDate = new Date(this.date);
                                newDate.setUTCDate(this.date.getUTCDate() + dir);
                                newViewDate = new Date(this.viewDate);
                                newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir);
                            }
                            if (this.dateWithinRange(newDate)) {
                                this.date = newDate;
                                this.viewDate = newViewDate;
                                this.setValue();
                                this.update();
                                e.preventDefault();
                                dateChanged = true;
                            }
                            break;
                        case 38: // up
                        case 40:
                            // down
                            if (!this.o.keyboardNavigation) break;
                            dir = e.keyCode == 38 ? -1 : 1;
                            if (e.ctrlKey) {
                                newDate = this.moveYear(this.date, dir);
                                newViewDate = this.moveYear(this.viewDate, dir);
                            } else if (e.shiftKey) {
                                newDate = this.moveMonth(this.date, dir);
                                newViewDate = this.moveMonth(this.viewDate, dir);
                            } else {
                                newDate = new Date(this.date);
                                newDate.setUTCDate(this.date.getUTCDate() + dir * 7);
                                newViewDate = new Date(this.viewDate);
                                newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir * 7);
                            }
                            if (this.dateWithinRange(newDate)) {
                                this.date = newDate;
                                this.viewDate = newViewDate;
                                this.setValue();
                                this.update();
                                e.preventDefault();
                                dateChanged = true;
                            }
                            break;
                        case 13:
                            // enter
                            this.hide();
                            e.preventDefault();
                            break;
                        case 9:
                            // tab
                            this.hide();
                            break;
                    }
                    if (dateChanged) {
                        this._trigger('changeDate');
                        var element;
                        if (this.isInput) {
                            element = this.element;
                        } else if (this.component) {
                            element = this.element.find('input');
                        }
                        if (element) {
                            element.change();
                        }
                    }
                },

                showMode: function (dir) {
                    if (dir) {
                        this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));
                    }
                    /*
                    	vitalets: fixing bug of very special conditions:
                    	jquery 1.7.1 + webkit + show inline datepicker in bootstrap popover.
                    	Method show() does not set display css correctly and datepicker is not shown.
                    	Changed to .css('display', 'block') solve the problem.
                    	See https://github.com/vitalets/x-editable/issues/37
                    		In jquery 1.7.2+ everything works fine.
                    */
                    //this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();
                    this.picker.find('>div').hide().filter('.datepicker-' + DPGlobal.modes[this.viewMode].clsName).css('display', 'block');
                    this.updateNavArrows();
                }
            };

            var DateRangePicker = function (element, options) {
                this.element = $(element);
                this.inputs = $.map(options.inputs, function (i) {
                    return i.jquery ? i[0] : i;
                });
                delete options.inputs;

                $(this.inputs).datepicker(options).bind('changeDate', $.proxy(this.dateUpdated, this));

                this.pickers = $.map(this.inputs, function (i) {
                    return $(i).data('datepicker');
                });
                this.updateDates();
            };
            DateRangePicker.prototype = {
                updateDates: function () {
                    this.dates = $.map(this.pickers, function (i) {
                        return i.date;
                    });
                    this.updateRanges();
                },
                updateRanges: function () {
                    var range = $.map(this.dates, function (d) {
                        return d.valueOf();
                    });
                    $.each(this.pickers, function (i, p) {
                        p.setRange(range);
                    });
                },
                dateUpdated: function (e) {
                    var dp = $(e.target).data('datepicker'),
                        new_date = dp.getUTCDate(),
                        i = $.inArray(e.target, this.inputs),
                        l = this.inputs.length;
                    if (i == -1) return;

                    if (new_date < this.dates[i]) {
                        // Date being moved earlier/left
                        while (i >= 0 && new_date < this.dates[i]) {
                            this.pickers[i--].setUTCDate(new_date);
                        }
                    } else if (new_date > this.dates[i]) {
                        // Date being moved later/right
                        while (i < l && new_date > this.dates[i]) {
                            this.pickers[i++].setUTCDate(new_date);
                        }
                    }
                    this.updateDates();
                },
                remove: function () {
                    $.map(this.pickers, function (p) {
                        p.remove();
                    });
                    delete this.element.data().datepicker;
                }
            };

            function opts_from_el(el, prefix) {
                // Derive options from element data-attrs
                var data = $(el).data(),
                    out = {},
                    inkey,
                    replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])'),
                    prefix = new RegExp('^' + prefix.toLowerCase());
                for (var key in data) if (prefix.test(key)) {
                    inkey = key.replace(replace, function (_, a) {
                        return a.toLowerCase();
                    });
                    out[inkey] = data[key];
                }
                return out;
            }

            function opts_from_locale(lang) {
                // Derive options from locale plugins
                var out = {};
                // Check if "de-DE" style date is available, if not language should
                // fallback to 2 letter code eg "de"
                if (!dates[lang]) {
                    lang = lang.split('-')[0];
                    if (!dates[lang]) return;
                }
                var d = dates[lang];
                $.each(locale_opts, function (i, k) {
                    if (k in d) out[k] = d[k];
                });
                return out;
            }

            var old = $.fn.datepicker;
            var datepicker = $.fn.datepicker = function (option) {
                var args = Array.apply(null, arguments);
                args.shift();
                var internal_return, this_return;
                this.each(function () {
                    var $this = $(this),
                        data = $this.data('datepicker'),
                        options = typeof option == 'object' && option;
                    if (!data) {
                        var elopts = opts_from_el(this, 'date'),

                        // Preliminary otions
                        xopts = $.extend({}, defaults, elopts, options),
                            locopts = opts_from_locale(xopts.language),

                        // Options priority: js args, data-attrs, locales, defaults
                        opts = $.extend({}, defaults, locopts, elopts, options);
                        if ($this.is('.input-daterange') || opts.inputs) {
                            var ropts = {
                                inputs: opts.inputs || $this.find('input').toArray()
                            };
                            $this.data('datepicker', data = new DateRangePicker(this, $.extend(opts, ropts)));
                        } else {
                            $this.data('datepicker', data = new Datepicker(this, opts));
                        }
                    }
                    if (typeof option == 'string' && typeof data[option] == 'function') {
                        internal_return = data[option].apply(data, args);
                        if (internal_return !== undefined) return false;
                    }
                });
                if (internal_return !== undefined) return internal_return;else return this;
            };

            var defaults = $.fn.datepicker.defaults = {
                autoclose: false,
                beforeShowDay: $.noop,
                calendarWeeks: false,
                clearBtn: false,
                daysOfWeekDisabled: [],
                endDate: Infinity,
                forceParse: true,
                format: 'mm/dd/yyyy',
                keyboardNavigation: true,
                language: 'en',
                minViewMode: 0,
                rtl: false,
                startDate: -Infinity,
                startView: 0,
                todayBtn: false,
                todayHighlight: false,
                weekStart: 0
            };
            var locale_opts = $.fn.datepicker.locale_opts = ['format', 'rtl', 'weekStart'];
            $.fn.datepicker.Constructor = Datepicker;
            var dates = $.fn.datepicker.dates = {
                en: {
                    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
                    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
                    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
                    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                    today: "Today",
                    clear: "Clear"
                }
            };

            var DPGlobal = {
                modes: [{
                    clsName: 'days',
                    navFnc: 'Month',
                    navStep: 1
                }, {
                    clsName: 'months',
                    navFnc: 'FullYear',
                    navStep: 1
                }, {
                    clsName: 'years',
                    navFnc: 'FullYear',
                    navStep: 10
                }],
                isLeapYear: function (year) {
                    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
                },
                getDaysInMonth: function (year, month) {
                    return [31, DPGlobal.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
                },
                validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
                nonpunctuation: /[^ -\/:-@\[\u3400-\u9fff-`{-~\t\n\r]+/g,
                parseFormat: function (format) {
                    // IE treats \0 as a string end in inputs (truncating the value),
                    // so it's a bad format delimiter, anyway
                    var separators = format.replace(this.validParts, '\0').split('\0'),
                        parts = format.match(this.validParts);
                    if (!separators || !separators.length || !parts || parts.length === 0) {
                        throw new Error("Invalid date format.");
                    }
                    return { separators: separators, parts: parts };
                },
                parseDate: function (date, format, language) {
                    if (date instanceof Date) return date;
                    if (typeof format === 'string') format = DPGlobal.parseFormat(format);
                    if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date)) {
                        var part_re = /([\-+]\d+)([dmwy])/,
                            parts = date.match(/([\-+]\d+)([dmwy])/g),
                            part,
                            dir;
                        date = new Date();
                        for (var i = 0; i < parts.length; i++) {
                            part = part_re.exec(parts[i]);
                            dir = parseInt(part[1]);
                            switch (part[2]) {
                                case 'd':
                                    date.setUTCDate(date.getUTCDate() + dir);
                                    break;
                                case 'm':
                                    date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);
                                    break;
                                case 'w':
                                    date.setUTCDate(date.getUTCDate() + dir * 7);
                                    break;
                                case 'y':
                                    date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);
                                    break;
                            }
                        }
                        return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
                    }
                    var parts = date && date.match(this.nonpunctuation) || [],
                        date = new Date(),
                        parsed = {},
                        setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
                        setters_map = {
                        yyyy: function (d, v) {
                            return d.setUTCFullYear(v);
                        },
                        yy: function (d, v) {
                            return d.setUTCFullYear(2000 + v);
                        },
                        m: function (d, v) {
                            v -= 1;
                            while (v < 0) v += 12;
                            v %= 12;
                            d.setUTCMonth(v);
                            while (d.getUTCMonth() != v) d.setUTCDate(d.getUTCDate() - 1);
                            return d;
                        },
                        d: function (d, v) {
                            return d.setUTCDate(v);
                        }
                    },
                        val,
                        filtered,
                        part;
                    setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
                    setters_map['dd'] = setters_map['d'];
                    date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
                    var fparts = format.parts.slice();
                    // Remove noop parts
                    if (parts.length != fparts.length) {
                        fparts = $(fparts).filter(function (i, p) {
                            return $.inArray(p, setters_order) !== -1;
                        }).toArray();
                    }
                    // Process remainder
                    if (parts.length == fparts.length) {
                        for (var i = 0, cnt = fparts.length; i < cnt; i++) {
                            val = parseInt(parts[i], 10);
                            part = fparts[i];
                            if (isNaN(val)) {
                                switch (part) {
                                    case 'MM':
                                        filtered = $(dates[language].months).filter(function () {
                                            var m = this.slice(0, parts[i].length),
                                                p = parts[i].slice(0, m.length);
                                            return m == p;
                                        });
                                        val = $.inArray(filtered[0], dates[language].months) + 1;
                                        break;
                                    case 'M':
                                        filtered = $(dates[language].monthsShort).filter(function () {
                                            var m = this.slice(0, parts[i].length),
                                                p = parts[i].slice(0, m.length);
                                            return m == p;
                                        });
                                        val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
                                        break;
                                }
                            }
                            parsed[part] = val;
                        }
                        for (var i = 0, s; i < setters_order.length; i++) {
                            s = setters_order[i];
                            if (s in parsed && !isNaN(parsed[s])) setters_map[s](date, parsed[s]);
                        }
                    }
                    return date;
                },
                formatDate: function (date, format, language) {
                    if (typeof format === 'string') format = DPGlobal.parseFormat(format);
                    var val = {
                        d: date.getUTCDate(),
                        D: dates[language].daysShort[date.getUTCDay()],
                        DD: dates[language].days[date.getUTCDay()],
                        m: date.getUTCMonth() + 1,
                        M: dates[language].monthsShort[date.getUTCMonth()],
                        MM: dates[language].months[date.getUTCMonth()],
                        yy: date.getUTCFullYear().toString().substring(2),
                        yyyy: date.getUTCFullYear()
                    };
                    val.dd = (val.d < 10 ? '0' : '') + val.d;
                    val.mm = (val.m < 10 ? '0' : '') + val.m;
                    var date = [],
                        seps = $.extend([], format.separators);
                    for (var i = 0, cnt = format.parts.length; i <= cnt; i++) {
                        if (seps.length) date.push(seps.shift());
                        date.push(val[format.parts[i]]);
                    }
                    return date.join('');
                },
                headTemplate: '<thead>' + '<tr>' + '<th class="prev"><i class="icon-arrow-left"/></th>' + '<th colspan="5" class="datepicker-switch"></th>' + '<th class="next"><i class="icon-arrow-right"/></th>' + '</tr>' + '</thead>',
                contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
                footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'
            };
            DPGlobal.template = '<div class="datepicker">' + '<div class="datepicker-days">' + '<table class=" table-condensed">' + DPGlobal.headTemplate + '<tbody></tbody>' + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class="datepicker-months">' + '<table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class="datepicker-years">' + '<table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '</div>';

            $.fn.datepicker.DPGlobal = DPGlobal;

            /* DATEPICKER NO CONFLICT
            * =================== */

            $.fn.datepicker.noConflict = function () {
                $.fn.datepicker = old;
                return this;
            };

            /* DATEPICKER DATA-API
            * ================== */

            $(document).on('focus.datepicker.data-api click.datepicker.data-api', '[data-provide="datepicker"]', function (e) {
                var $this = $(this);
                if ($this.data('datepicker')) return;
                e.preventDefault();
                // component click requires us to explicitly show it
                datepicker.call($this, 'show');
            });
            $(function () {
                //$('[data-provide="datepicker-inline"]').datepicker();
                //vit: changed to support noConflict()
                datepicker.call($('[data-provide="datepicker-inline"]'));
            });
        })(window.jQuery);

        /**
        Bootstrap-datepicker.  
        Description and examples: https://github.com/eternicode/bootstrap-datepicker.  
        For **i18n** you should include js file from here: https://github.com/eternicode/bootstrap-datepicker/tree/master/js/locales
        and set `language` option.  
        Since 1.4.0 date has different appearance in **popup** and **inline** modes. 
        
        @class date
        @extends abstractinput
        @final
        @example
        <a href="#" id="dob" data-type="date" data-pk="1" data-url="/post" data-title="Select date">15/05/1984</a>
        <script>
        $(function(){
            $('#dob').editable({
                format: 'yyyy-mm-dd',    
                viewformat: 'dd/mm/yyyy',    
                datepicker: {
                        weekStart: 1
                   }
                }
            });
        });
        </script>
        **/
        (function ($) {
            "use strict";

            //store bootstrap-datepicker as bdateicker to exclude conflict with jQuery UI one

            $.fn.bdatepicker = $.fn.datepicker.noConflict();
            if (!$.fn.datepicker) {
                //if there were no other datepickers, keep also original name
                $.fn.datepicker = $.fn.bdatepicker;
            }

            var Date = function (options) {
                this.init('date', options, Date.defaults);
                this.initPicker(options, Date.defaults);
            };

            $.fn.editableutils.inherit(Date, $.fn.editabletypes.abstractinput);

            $.extend(Date.prototype, {
                initPicker: function (options, defaults) {
                    //'format' is set directly from settings or data-* attributes

                    //by default viewformat equals to format
                    if (!this.options.viewformat) {
                        this.options.viewformat = this.options.format;
                    }

                    //try parse datepicker config defined as json string in data-datepicker
                    options.datepicker = $.fn.editableutils.tryParseJson(options.datepicker, true);

                    //overriding datepicker config (as by default jQuery extend() is not recursive)
                    //since 1.4 datepicker internally uses viewformat instead of format. Format is for submit only
                    this.options.datepicker = $.extend({}, defaults.datepicker, options.datepicker, {
                        format: this.options.viewformat
                    });

                    //language
                    this.options.datepicker.language = this.options.datepicker.language || 'en';

                    //store DPglobal
                    this.dpg = $.fn.bdatepicker.DPGlobal;

                    //store parsed formats
                    this.parsedFormat = this.dpg.parseFormat(this.options.format);
                    this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat);
                },

                render: function () {
                    this.$input.bdatepicker(this.options.datepicker);

                    //"clear" link
                    if (this.options.clear) {
                        this.$clear = $('<a href="#"></a>').html(this.options.clear).click($.proxy(function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this.clear();
                        }, this));

                        this.$tpl.parent().append($('<div class="editable-clear">').append(this.$clear));
                    }
                },

                value2html: function (value, element) {
                    var text = value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '';
                    Date.superclass.value2html.call(this, text, element);
                },

                html2value: function (html) {
                    return this.parseDate(html, this.parsedViewFormat);
                },

                value2str: function (value) {
                    return value ? this.dpg.formatDate(value, this.parsedFormat, this.options.datepicker.language) : '';
                },

                str2value: function (str) {
                    return this.parseDate(str, this.parsedFormat);
                },

                value2submit: function (value) {
                    return this.value2str(value);
                },

                value2input: function (value) {
                    this.$input.bdatepicker('update', value);
                },

                input2value: function () {
                    return this.$input.data('datepicker').date;
                },

                activate: function () {},

                clear: function () {
                    this.$input.data('datepicker').date = null;
                    this.$input.find('.active').removeClass('active');
                    if (!this.options.showbuttons) {
                        this.$input.closest('form').submit();
                    }
                },

                autosubmit: function () {
                    this.$input.on('mouseup', '.day', function (e) {
                        if ($(e.currentTarget).is('.old') || $(e.currentTarget).is('.new')) {
                            return;
                        }
                        var $form = $(this).closest('form');
                        setTimeout(function () {
                            $form.submit();
                        }, 200);
                    });
                    //changedate is not suitable as it triggered when showing datepicker. see #149
                    /*
                    this.$input.on('changeDate', function(e){
                        var $form = $(this).closest('form');
                        setTimeout(function() {
                            $form.submit();
                        }, 200);
                    });
                    */
                },

                /*
                 For incorrect date bootstrap-datepicker returns current date that is not suitable
                 for datefield.
                 This function returns null for incorrect date.  
                */
                parseDate: function (str, format) {
                    var date = null,
                        formattedBack;
                    if (str) {
                        date = this.dpg.parseDate(str, format, this.options.datepicker.language);
                        if (typeof str === 'string') {
                            formattedBack = this.dpg.formatDate(date, format, this.options.datepicker.language);
                            if (str !== formattedBack) {
                                date = null;
                            }
                        }
                    }
                    return date;
                }

            });

            Date.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
                /**
                @property tpl 
                @default <div></div>
                **/
                tpl: '<div class="editable-date well"></div>',
                /**
                @property inputclass 
                @default null
                **/
                inputclass: null,
                /**
                Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>
                Possible tokens are: <code>d, dd, m, mm, yy, yyyy</code>  
                 @property format 
                @type string
                @default yyyy-mm-dd
                **/
                format: 'yyyy-mm-dd',
                /**
                Format used for displaying date. Also applied when converting date from element's text on init.   
                If not specified equals to <code>format</code>
                 @property viewformat 
                @type string
                @default null
                **/
                viewformat: null,
                /**
                Configuration of datepicker.
                Full list of options: http://bootstrap-datepicker.readthedocs.org/en/latest/options.html
                 @property datepicker 
                @type object
                @default {
                    weekStart: 0,
                    startView: 0,
                    minViewMode: 0,
                    autoclose: false
                }
                **/
                datepicker: {
                    weekStart: 0,
                    startView: 0,
                    minViewMode: 0,
                    autoclose: false
                },
                /**
                Text shown as clear date button. 
                If <code>false</code> clear button will not be rendered.
                 @property clear 
                @type boolean|string
                @default 'x clear'
                **/
                clear: '&times; clear'
            });

            $.fn.editabletypes.date = Date;
        })(window.jQuery);

        /**
        Bootstrap datefield input - modification for inline mode.
        Shows normal <input type="text"> and binds popup datepicker.  
        Automatically shown in inline mode.
        
        @class datefield
        @extends date
        
        @since 1.4.0
        **/
        (function ($) {
            "use strict";

            var DateField = function (options) {
                this.init('datefield', options, DateField.defaults);
                this.initPicker(options, DateField.defaults);
            };

            $.fn.editableutils.inherit(DateField, $.fn.editabletypes.date);

            $.extend(DateField.prototype, {
                render: function () {
                    this.$input = this.$tpl.find('input');
                    this.setClass();
                    this.setAttr('placeholder');

                    //bootstrap-datepicker is set `bdateicker` to exclude conflict with jQuery UI one. (in date.js)        
                    this.$tpl.bdatepicker(this.options.datepicker);

                    //need to disable original event handlers
                    this.$input.off('focus keydown');

                    //update value of datepicker
                    this.$input.keyup($.proxy(function () {
                        this.$tpl.removeData('date');
                        this.$tpl.bdatepicker('update');
                    }, this));
                },

                value2input: function (value) {
                    this.$input.val(value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '');
                    this.$tpl.bdatepicker('update');
                },

                input2value: function () {
                    return this.html2value(this.$input.val());
                },

                activate: function () {
                    $.fn.editabletypes.text.prototype.activate.call(this);
                },

                autosubmit: function () {
                    //reset autosubmit to empty  
                }
            });

            DateField.defaults = $.extend({}, $.fn.editabletypes.date.defaults, {
                /**
                @property tpl 
                **/
                tpl: '<div class="input-append date"><input type="text"/><span class="add-on"><i class="icon-th"></i></span></div>',
                /**
                @property inputclass 
                @default 'input-small'
                **/
                inputclass: 'input-small',

                /* datepicker config */
                datepicker: {
                    weekStart: 0,
                    startView: 0,
                    minViewMode: 0,
                    autoclose: true
                }
            });

            $.fn.editabletypes.datefield = DateField;
        })(window.jQuery);
        /**
        Bootstrap-datetimepicker.  
        Based on [smalot bootstrap-datetimepicker plugin](https://github.com/smalot/bootstrap-datetimepicker). 
        Before usage you should manually include dependent js and css:
        
            <link href="css/datetimepicker.css" rel="stylesheet" type="text/css"></link> 
            <script src="js/bootstrap-datetimepicker.js"></script>
        
        For **i18n** you should include js file from here: https://github.com/smalot/bootstrap-datetimepicker/tree/master/js/locales
        and set `language` option.  
        
        @class datetime
        @extends abstractinput
        @final
        @since 1.4.4
        @example
        <a href="#" id="last_seen" data-type="datetime" data-pk="1" data-url="/post" title="Select date & time">15/03/2013 12:45</a>
        <script>
        $(function(){
            $('#last_seen').editable({
                format: 'yyyy-mm-dd hh:ii',    
                viewformat: 'dd/mm/yyyy hh:ii',    
                datetimepicker: {
                        weekStart: 1
                   }
                }
            });
        });
        </script>
        **/
        (function ($) {
            "use strict";

            var DateTime = function (options) {
                this.init('datetime', options, DateTime.defaults);
                this.initPicker(options, DateTime.defaults);
            };

            $.fn.editableutils.inherit(DateTime, $.fn.editabletypes.abstractinput);

            $.extend(DateTime.prototype, {
                initPicker: function (options, defaults) {
                    //'format' is set directly from settings or data-* attributes

                    //by default viewformat equals to format
                    if (!this.options.viewformat) {
                        this.options.viewformat = this.options.format;
                    }

                    //try parse datetimepicker config defined as json string in data-datetimepicker
                    options.datetimepicker = $.fn.editableutils.tryParseJson(options.datetimepicker, true);

                    //overriding datetimepicker config (as by default jQuery extend() is not recursive)
                    //since 1.4 datetimepicker internally uses viewformat instead of format. Format is for submit only
                    this.options.datetimepicker = $.extend({}, defaults.datetimepicker, options.datetimepicker, {
                        format: this.options.viewformat
                    });

                    //language
                    this.options.datetimepicker.language = this.options.datetimepicker.language || 'en';

                    //store DPglobal
                    this.dpg = $.fn.datetimepicker.DPGlobal;

                    //store parsed formats
                    this.parsedFormat = this.dpg.parseFormat(this.options.format, this.options.formatType);
                    this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat, this.options.formatType);
                },

                render: function () {
                    this.$input.datetimepicker(this.options.datetimepicker);

                    //adjust container position when viewMode changes
                    //see https://github.com/smalot/bootstrap-datetimepicker/pull/80
                    this.$input.on('changeMode', function (e) {
                        var f = $(this).closest('form').parent();
                        //timeout here, otherwise container changes position before form has new size
                        setTimeout(function () {
                            f.triggerHandler('resize');
                        }, 0);
                    });

                    //"clear" link
                    if (this.options.clear) {
                        this.$clear = $('<a href="#"></a>').html(this.options.clear).click($.proxy(function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this.clear();
                        }, this));

                        this.$tpl.parent().append($('<div class="editable-clear">').append(this.$clear));
                    }
                },

                value2html: function (value, element) {
                    //formatDate works with UTCDate!
                    var text = value ? this.dpg.formatDate(this.toUTC(value), this.parsedViewFormat, this.options.datetimepicker.language, this.options.formatType) : '';
                    if (element) {
                        DateTime.superclass.value2html.call(this, text, element);
                    } else {
                        return text;
                    }
                },

                html2value: function (html) {
                    //parseDate return utc date!
                    var value = this.parseDate(html, this.parsedViewFormat);
                    return value ? this.fromUTC(value) : null;
                },

                value2str: function (value) {
                    //formatDate works with UTCDate!
                    return value ? this.dpg.formatDate(this.toUTC(value), this.parsedFormat, this.options.datetimepicker.language, this.options.formatType) : '';
                },

                str2value: function (str) {
                    //parseDate return utc date!
                    var value = this.parseDate(str, this.parsedFormat);
                    return value ? this.fromUTC(value) : null;
                },

                value2submit: function (value) {
                    return this.value2str(value);
                },

                value2input: function (value) {
                    if (value) {
                        this.$input.data('datetimepicker').setDate(value);
                    }
                },

                input2value: function () {
                    //date may be cleared, in that case getDate() triggers error
                    var dt = this.$input.data('datetimepicker');
                    return dt.date ? dt.getDate() : null;
                },

                activate: function () {},

                clear: function () {
                    this.$input.data('datetimepicker').date = null;
                    this.$input.find('.active').removeClass('active');
                    if (!this.options.showbuttons) {
                        this.$input.closest('form').submit();
                    }
                },

                autosubmit: function () {
                    this.$input.on('mouseup', '.minute', function (e) {
                        var $form = $(this).closest('form');
                        setTimeout(function () {
                            $form.submit();
                        }, 200);
                    });
                },

                //convert date from local to utc
                toUTC: function (value) {
                    return value ? new Date(value.valueOf() - value.getTimezoneOffset() * 60000) : value;
                },

                //convert date from utc to local
                fromUTC: function (value) {
                    return value ? new Date(value.valueOf() + value.getTimezoneOffset() * 60000) : value;
                },

                /*
                 For incorrect date bootstrap-datetimepicker returns current date that is not suitable
                 for datetimefield.
                 This function returns null for incorrect date.  
                */
                parseDate: function (str, format) {
                    var date = null,
                        formattedBack;
                    if (str) {
                        date = this.dpg.parseDate(str, format, this.options.datetimepicker.language, this.options.formatType);
                        if (typeof str === 'string') {
                            formattedBack = this.dpg.formatDate(date, format, this.options.datetimepicker.language, this.options.formatType);
                            if (str !== formattedBack) {
                                date = null;
                            }
                        }
                    }
                    return date;
                }

            });

            DateTime.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
                /**
                @property tpl 
                @default <div></div>
                **/
                tpl: '<div class="editable-date well"></div>',
                /**
                @property inputclass 
                @default null
                **/
                inputclass: null,
                /**
                Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>
                Possible tokens are: <code>d, dd, m, mm, yy, yyyy, h, i</code>  
                
                @property format 
                @type string
                @default yyyy-mm-dd hh:ii
                **/
                format: 'yyyy-mm-dd hh:ii',
                formatType: 'standard',
                /**
                Format used for displaying date. Also applied when converting date from element's text on init.   
                If not specified equals to <code>format</code>
                
                @property viewformat 
                @type string
                @default null
                **/
                viewformat: null,
                /**
                Configuration of datetimepicker.
                Full list of options: https://github.com/smalot/bootstrap-datetimepicker
                 @property datetimepicker 
                @type object
                @default { }
                **/
                datetimepicker: {
                    todayHighlight: false,
                    autoclose: false
                },
                /**
                Text shown as clear date button. 
                If <code>false</code> clear button will not be rendered.
                 @property clear 
                @type boolean|string
                @default 'x clear'
                **/
                clear: '&times; clear'
            });

            $.fn.editabletypes.datetime = DateTime;
        })(window.jQuery);
        /**
        Bootstrap datetimefield input - datetime input for inline mode.
        Shows normal <input type="text"> and binds popup datetimepicker.  
        Automatically shown in inline mode.
        
        @class datetimefield
        @extends datetime
        
        **/
        (function ($) {
            "use strict";

            var DateTimeField = function (options) {
                this.init('datetimefield', options, DateTimeField.defaults);
                this.initPicker(options, DateTimeField.defaults);
            };

            $.fn.editableutils.inherit(DateTimeField, $.fn.editabletypes.datetime);

            $.extend(DateTimeField.prototype, {
                render: function () {
                    this.$input = this.$tpl.find('input');
                    this.setClass();
                    this.setAttr('placeholder');

                    this.$tpl.datetimepicker(this.options.datetimepicker);

                    //need to disable original event handlers
                    this.$input.off('focus keydown');

                    //update value of datepicker
                    this.$input.keyup($.proxy(function () {
                        this.$tpl.removeData('date');
                        this.$tpl.datetimepicker('update');
                    }, this));
                },

                value2input: function (value) {
                    this.$input.val(this.value2html(value));
                    this.$tpl.datetimepicker('update');
                },

                input2value: function () {
                    return this.html2value(this.$input.val());
                },

                activate: function () {
                    $.fn.editabletypes.text.prototype.activate.call(this);
                },

                autosubmit: function () {
                    //reset autosubmit to empty  
                }
            });

            DateTimeField.defaults = $.extend({}, $.fn.editabletypes.datetime.defaults, {
                /**
                @property tpl 
                **/
                tpl: '<div class="input-append date"><input type="text"/><span class="add-on"><i class="icon-th"></i></span></div>',
                /**
                @property inputclass 
                @default 'input-medium'
                **/
                inputclass: 'input-medium',

                /* datetimepicker config */
                datetimepicker: {
                    todayHighlight: false,
                    autoclose: true
                }
            });

            $.fn.editabletypes.datetimefield = DateTimeField;
        })(window.jQuery);
    })(this);

    return _retrieveGlobal();
});
System.registerDynamic("npm:tableexport.jquery.plugin@1.9.3.json", [], true, function() {
  return {
    "main": "tableExport.min.js",
    "format": "global",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "LICENSE": {
        "globals": {
          "process": null
        }
      },
      "bower_components/file-saver/FileSaver.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/file-saver/FileSaver.min.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/html2canvas/.npmignore": {
        "globals": {
          "process": null
        }
      },
      "bower_components/html2canvas/Gruntfile.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/html2canvas/LICENSE": {
        "globals": {
          "process": null
        }
      },
      "bower_components/html2canvas/build/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/html2canvas/examples/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/html2canvas/src/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/AUTHORS.txt": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/LICENSE.txt": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/dist/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/external/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/ajax.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/ajax/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/attributes.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/attributes/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/callbacks.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/core.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/core/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/css.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/css/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/data.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/data/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/deferred.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/deferred/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/deprecated.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/dimensions.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/effects.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/effects/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/event.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/event/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/exports/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/jquery.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/manipulation.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/manipulation/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/offset.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/queue.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/queue/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/selector-native.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/selector-sizzle.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/selector.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/serialize.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/traversing.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/traversing/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/var/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jquery/src/wrap.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jspdf-autotable/.npmignore": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jspdf-autotable/LICENSE.txt": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jspdf-autotable/build.js": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jspdf-autotable/dist/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jspdf-autotable/examples/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jspdf-autotable/samples.png": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jspdf-autotable/src/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/jspdf/dist/*": {
        "globals": {
          "process": null
        }
      },
      "bower_components/tableExport.jquery.plugin/.npmignore": {
        "globals": {
          "process": null
        }
      },
      "bower_components/tableExport.jquery.plugin/tableExport.min.js": {
        "globals": {
          "process": null
        }
      },
      "tableExport.min.js": {
        "globals": {
          "process": null
        }
      }
    }
  };
});

System.registerDynamic("npm:tableexport.jquery.plugin@1.9.3/tableExport.min.js", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = System.registry.get("@@global-helpers").prepareGlobal($__module.id, null, {});

  (function ($__global) {
    /*
     tableExport.jquery.plugin
    
     Copyright (c) 2015-2017 hhurz, https://github.com/hhurz
    
     Original Work Copyright (c) 2014 Giri Raj
    
     Licensed under the MIT License
    */
    (function (c) {
      c.fn.extend({ tableExport: function (n) {
          function N(b) {
            var a = [];c(b).find("thead").first().find("th").each(function (b, f) {
              void 0 !== c(f).attr("data-field") ? a[b] = c(f).attr("data-field") : a[b] = b.toString();
            });return a;
          }function x(b, m, e, f, z) {
            if (-1 == c.inArray(e, a.ignoreRow) && -1 == c.inArray(e - f, a.ignoreRow)) {
              var F = c(b).filter(function () {
                return "none" != c(this).data("tableexport-display") && (c(this).is(":visible") || "always" == c(this).data("tableexport-display") || "always" == c(this).closest("table").data("tableexport-display"));
              }).find(m),
                  l = 0;F.each(function (b) {
                if (("always" == c(this).data("tableexport-display") || "none" != c(this).css("display") && "hidden" != c(this).css("visibility") && "none" != c(this).data("tableexport-display")) && "function" === typeof z) {
                  var f,
                      m = 1,
                      r = 1;var d = F.length;if ("undefined" != typeof y[e] && 0 < y[e].length) {
                    var g = b;for (f = 0; f <= g; f++) "undefined" != typeof y[e][f] && (z(null, e, f), delete y[e][f], g++);b += y[e].length;d += y[e].length;
                  }c(this).is("[colspan]") && (m = parseInt(c(this).attr("colspan")) || 1, l += 0 < m ? m - 1 : 0);c(this).is("[rowspan]") && (r = parseInt(c(this).attr("rowspan")) || 1);f = d;d = b + l;g = !1;0 < a.ignoreColumn.length && ("string" == typeof a.ignoreColumn[0] ? I.length > d && "undefined" != typeof I[d] && -1 != c.inArray(I[d], a.ignoreColumn) && (g = !0) : "number" != typeof a.ignoreColumn[0] || -1 == c.inArray(d, a.ignoreColumn) && -1 == c.inArray(d - f, a.ignoreColumn) || (g = !0));if (!1 === g) for (z(this, e, b), f = 1; f < m; f++) z(null, e, b + f);if (1 < r) for (d = 1; d < r; d++) for ("undefined" == typeof y[e + d] && (y[e + d] = []), y[e + d][b + l] = "", f = 1; f < m; f++) y[e + d][b + l - f] = "";
                }
              });if ("undefined" != typeof y[e] && 0 < y[e].length) for (b = 0; b <= y[e].length; b++) "undefined" != typeof y[e][b] && (z(null, e, b), delete y[e][b]);
            }
          }function aa(b, m) {
            !0 === a.consoleLog && console.log(b.output());if ("string" === a.outputMode) return b.output();if ("base64" === a.outputMode) return D(b.output());if ("window" === a.outputMode) window.open(URL.createObjectURL(b.output("blob")));else try {
              var e = b.output("blob");saveAs(e, a.fileName + ".pdf");
            } catch (f) {
              A(a.fileName + ".pdf", "data:application/pdf" + (m ? "" : ";base64") + ",", m ? e : b.output());
            }
          }function ba(b, a, e) {
            var f = 0;"undefined" != typeof e && (f = e.colspan);if (0 <= f) {
              for (var m = b.width, c = b.textPos.x, l = a.table.columns.indexOf(a.column), r = 1; r < f; r++) m += a.table.columns[l + r].width;1 < f && ("right" === b.styles.halign ? c = b.textPos.x + m - b.width : "center" === b.styles.halign && (c = b.textPos.x + (m - b.width) / 2));b.width = m;b.textPos.x = c;"undefined" != typeof e && 1 < e.rowspan && (b.height *= e.rowspan);if ("middle" === b.styles.valign || "bottom" === b.styles.valign) e = ("string" === typeof b.text ? b.text.split(/\r\n|\r|\n/g) : b.text).length || 1, 2 < e && (b.textPos.y -= (2 - 1.15) / 2 * a.row.styles.fontSize * (e - 2) / 3);return !0;
            }return !1;
          }function ca(b, a, e) {
            "undefined" != typeof e.images && a.each(function () {
              var a = c(this).children();if (c(this).is("img")) {
                var m = da(this.src);e.images[m] = { url: this.src, src: this.src };
              }"undefined" != typeof a && 0 < a.length && ca(b, a, e);
            });
          }function ma(b, a) {
            function e(b) {
              if (b.url) {
                var f = new Image();m = ++c;f.crossOrigin = "Anonymous";f.onerror = f.onload = function () {
                  if (f.complete && (0 === f.src.indexOf("data:image/") && (f.width = b.width || f.width || 0, f.height = b.height || f.height || 0), f.width + f.height)) {
                    var e = document.createElement("canvas"),
                        l = e.getContext("2d");e.width = f.width;e.height = f.height;l.drawImage(f, 0, 0);b.src = e.toDataURL("image/jpeg");
                  }--c || a(m);
                };f.src = b.url;
              }
            }var f,
                m = 0,
                c = 0;if ("undefined" != typeof b.images) for (f in b.images) b.images.hasOwnProperty(f) && e(b.images[f]);(f = c) || (a(m), f = void 0);return f;
          }function ea(b, m, e) {
            m.each(function () {
              var f = c(this).children();if (c(this).is("div")) {
                var m = O(E(this, "background-color"), [255, 255, 255]),
                    F = O(E(this, "border-top-color"), [0, 0, 0]),
                    l = P(this, "border-top-width", a.jspdf.unit),
                    r = this.getBoundingClientRect(),
                    d = this.offsetLeft * e.dw;var g = this.offsetTop * e.dh;var h = r.width * e.dw,
                    r = r.height * e.dh;e.doc.setDrawColor.apply(void 0, F);e.doc.setFillColor.apply(void 0, m);e.doc.setLineWidth(l);e.doc.rect(b.x + d, b.y + g, h, r, l ? "FD" : "F");
              } else if (c(this).is("img") && "undefined" != typeof e.images && (g = da(this.src), m = e.images[g], "undefined" != typeof m)) {
                F = b.width / b.height;l = this.width / this.height;d = b.width;h = b.height;r = 19.049976 / 25.4;g = 0;l <= F ? (h = Math.min(b.height, this.height), d = this.width * h / this.height) : l > F && (d = Math.min(b.width, this.width), h = this.height * d / this.width);d *= r;h *= r;h < b.height && (g = (b.height - h) / 2);try {
                  e.doc.addImage(m.src, b.textPos.x, b.y + g, d, h);
                } catch (qa) {}b.textPos.x += d;
              }"undefined" != typeof f && 0 < f.length && ea(b, f, e);
            });
          }function fa(b, a, e) {
            if ("function" === typeof e.onAutotableText) e.onAutotableText(e.doc, b, a);else {
              var f = b.textPos.x,
                  m = b.textPos.y,
                  d = { halign: b.styles.halign, valign: b.styles.valign };if (a.length) {
                for (a = a[0]; a.previousSibling;) a = a.previousSibling;
                for (var l = !1, r = !1; a;) {
                  var g = a.innerText || a.textContent || "",
                      g = (g.length && " " == g[0] ? " " : "") + c.trim(g) + (1 < g.length && " " == g[g.length - 1] ? " " : "");c(a).is("br") && (f = b.textPos.x, m += e.doc.internal.getFontSize());c(a).is("b") ? l = !0 : c(a).is("i") && (r = !0);(l || r) && e.doc.setFontType(l && r ? "bolditalic" : l ? "bold" : "italic");var h = e.doc.getStringUnitWidth(g) * e.doc.internal.getFontSize();if (h) {
                    if ("linebreak" === b.styles.overflow && f > b.textPos.x && f + h > b.textPos.x + b.width) {
                      if (0 <= ".,!%*;:=-".indexOf(g.charAt(0))) {
                        var k = g.charAt(0),
                            h = e.doc.getStringUnitWidth(k) * e.doc.internal.getFontSize();f + h <= b.textPos.x + b.width && (e.doc.autoTableText(k, f, m, d), g = g.substring(1, g.length));h = e.doc.getStringUnitWidth(g) * e.doc.internal.getFontSize();
                      }f = b.textPos.x;m += e.doc.internal.getFontSize();
                    }for (; g.length && f + h > b.textPos.x + b.width;) g = g.substring(0, g.length - 1), h = e.doc.getStringUnitWidth(g) * e.doc.internal.getFontSize();e.doc.autoTableText(g, f, m, d);f += h;
                  }if (l || r) c(a).is("b") ? l = !1 : c(a).is("i") && (r = !1), e.doc.setFontType(l || r ? l ? "bold" : "italic" : "normal");
                  a = a.nextSibling;
                }b.textPos.x = f;b.textPos.y = m;
              } else e.doc.autoTableText(b.text, b.textPos.x, b.textPos.y, d);
            }
          }function Q(b, a, e) {
            return b.replace(new RegExp(a.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"), "g"), e);
          }function U(b) {
            b = Q(b || "0", a.numbers.html.thousandsSeparator, "");b = Q(b, a.numbers.html.decimalMark, ".");return "number" === typeof b || !1 !== jQuery.isNumeric(b) ? b : !1;
          }function v(b, m, e) {
            var f = "";if (null !== b) {
              var z = c(b);if (z[0].hasAttribute("data-tableexport-value")) var d = z.data("tableexport-value");else if (d = z.html(), "function" === typeof a.onCellHtmlData) d = a.onCellHtmlData(z, m, e, d);else if ("" != d) {
                b = c.parseHTML(d);var l = 0,
                    g = 0;d = "";c.each(b, function () {
                  if (c(this).is("input")) d += z.find("input").eq(l++).val();else if (c(this).is("select")) d += z.find("select option:selected").eq(g++).text();else if ("undefined" === typeof c(this).html()) d += c(this).text();else if (void 0 === jQuery().bootstrapTable || !0 !== c(this).hasClass("filterControl")) d += c(this).html();
                });
              }if (!0 === a.htmlContent) f = c.trim(d);else if ("" != d) {
                var h = d.replace(/\n/g, "\u2028").replace(/<br\s*[\/]?>/gi, "\u2060");b = c("<div/>").html(h).contents();h = "";c.each(b.text().split("\u2028"), function (b, a) {
                  0 < b && (h += " ");h += c.trim(a);
                });c.each(h.split("\u2060"), function (b, a) {
                  0 < b && (f += "\n");f += c.trim(a).replace(/\u00AD/g, "");
                });if ("json" == a.type || "excel" === a.type && "xmlss" === a.excelFileFormat || !1 === a.numbers.output) b = U(f), !1 !== b && (f = Number(b));else if (a.numbers.html.decimalMark != a.numbers.output.decimalMark || a.numbers.html.thousandsSeparator != a.numbers.output.thousandsSeparator) if (b = U(f), !1 !== b) {
                  var k = ("" + b).split(".");1 == k.length && (k[1] = "");var n = 3 < k[0].length ? k[0].length % 3 : 0,
                      f = (0 > b ? "-" : "") + (a.numbers.output.thousandsSeparator ? (n ? k[0].substr(0, n) + a.numbers.output.thousandsSeparator : "") + k[0].substr(n).replace(/(\d{3})(?=\d)/g, "$1" + a.numbers.output.thousandsSeparator) : k[0]) + (k[1].length ? a.numbers.output.decimalMark + k[1] : "");
                }
              }!0 === a.escape && (f = escape(f));"function" === typeof a.onCellData && (f = a.onCellData(z, m, e, f));
            }return f;
          }function na(b, a, e) {
            return a + "-" + e.toLowerCase();
          }function O(a, m) {
            var b = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/.exec(a),
                f = m;b && (f = [parseInt(b[1]), parseInt(b[2]), parseInt(b[3])]);return f;
          }function ga(b) {
            var a = E(b, "text-align"),
                e = E(b, "font-weight"),
                f = E(b, "font-style"),
                d = "";"start" == a && (a = "rtl" == E(b, "direction") ? "right" : "left");700 <= e && (d = "bold");"italic" == f && (d += f);"" === d && (d = "normal");a = { style: { align: a, bcolor: O(E(b, "background-color"), [255, 255, 255]), color: O(E(b, "color"), [0, 0, 0]), fstyle: d }, colspan: parseInt(c(b).attr("colspan")) || 0, rowspan: parseInt(c(b).attr("rowspan")) || 0 };null !== b && (b = b.getBoundingClientRect(), a.rect = { width: b.width, height: b.height });return a;
          }function E(a, c) {
            try {
              return window.getComputedStyle ? (c = c.replace(/([a-z])([A-Z])/, na), window.getComputedStyle(a, null).getPropertyValue(c)) : a.currentStyle ? a.currentStyle[c] : a.style[c];
            } catch (e) {}return "";
          }function P(a, c, e) {
            c = E(a, c).match(/\d+/);if (null !== c) {
              c = c[0];a = a.parentElement;var b = document.createElement("div");b.style.overflow = "hidden";b.style.visibility = "hidden";a.appendChild(b);b.style.width = 100 + e;e = 100 / b.offsetWidth;a.removeChild(b);return c * e;
            }return 0;
          }function V() {
            if (!(this instanceof V)) return new V();this.SheetNames = [];this.Sheets = {};
          }function oa(a) {
            for (var b = new ArrayBuffer(a.length), e = new Uint8Array(b), f = 0; f != a.length; ++f) e[f] = a.charCodeAt(f) & 255;return b;
          }function pa(a) {
            for (var b = {}, e = { s: { c: 1E7, r: 1E7 }, e: { c: 0, r: 0 } }, f = 0; f != a.length; ++f) for (var c = 0; c != a[f].length; ++c) {
              e.s.r > f && (e.s.r = f);e.s.c > c && (e.s.c = c);e.e.r < f && (e.e.r = f);e.e.c < c && (e.e.c = c);var d = { v: a[f][c] };if (null !== d.v) {
                var l = XLSX.utils.encode_cell({ c: c,
                  r: f });if ("number" === typeof d.v) d.t = "n";else if ("boolean" === typeof d.v) d.t = "b";else if (d.v instanceof Date) {
                  d.t = "n";d.z = XLSX.SSF._table[14];var g = d;var h = (Date.parse(d.v) - new Date(Date.UTC(1899, 11, 30))) / 864E5;g.v = h;
                } else d.t = "s";b[l] = d;
              }
            }1E7 > e.s.c && (b["!ref"] = XLSX.utils.encode_range(e));return b;
          }function da(a) {
            var b = 0,
                c;if (0 === a.length) return b;var f = 0;for (c = a.length; f < c; f++) {
              var d = a.charCodeAt(f);b = (b << 5) - b + d;b |= 0;
            }return b;
          }function A(a, c, e) {
            var b = window.navigator.userAgent;if (!1 !== a && (0 < b.indexOf("MSIE ") || b.match(/Trident.*rv\:11\./))) {
              if (window.navigator.msSaveOrOpenBlob) window.navigator.msSaveOrOpenBlob(new Blob([e]), a);else {
                if (c = document.createElement("iframe")) document.body.appendChild(c), c.setAttribute("style", "display:none"), c.contentDocument.open("txt/html", "replace"), c.contentDocument.write(e), c.contentDocument.close(), c.focus(), c.contentDocument.execCommand("SaveAs", !0, a), document.body.removeChild(c);
              }
            } else if (b = document.createElement("a")) {
              var d = null;b.style.display = "none";!1 !== a ? b.download = a : b.target = "_blank";"object" == typeof e ? (d = window.URL.createObjectURL(e), b.href = d) : 0 <= c.toLowerCase().indexOf("base64,") ? b.href = c + D(e) : b.href = c + encodeURIComponent(e);document.body.appendChild(b);if (document.createEvent) null === R && (R = document.createEvent("MouseEvents")), R.initEvent("click", !0, !1), b.dispatchEvent(R);else if (document.createEventObject) b.fireEvent("onclick");else if ("function" == typeof b.onclick) b.onclick();d && window.URL.revokeObjectURL(d);document.body.removeChild(b);
            }
          }function D(a) {
            var b = "",
                c,
                f = 0;a = a.replace(/\x0d\x0a/g, "\n");var d = "";for (c = 0; c < a.length; c++) {
              var g = a.charCodeAt(c);128 > g ? d += String.fromCharCode(g) : (127 < g && 2048 > g ? d += String.fromCharCode(g >> 6 | 192) : (d += String.fromCharCode(g >> 12 | 224), d += String.fromCharCode(g >> 6 & 63 | 128)), d += String.fromCharCode(g & 63 | 128));
            }for (a = d; f < a.length;) {
              var l = a.charCodeAt(f++);d = a.charCodeAt(f++);c = a.charCodeAt(f++);g = l >> 2;l = (l & 3) << 4 | d >> 4;var r = (d & 15) << 2 | c >> 6;var h = c & 63;isNaN(d) ? r = h = 64 : isNaN(c) && (h = 64);b = b + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(g) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(l) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(r) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(h);
            }return b;
          }var a = { consoleLog: !1, csvEnclosure: '"', csvSeparator: ",", csvUseBOM: !0, displayTableName: !1, escape: !1, excelFileFormat: "xlshtml", excelstyles: [], fileName: "tableExport", htmlContent: !1, ignoreColumn: [], ignoreRow: [], jsonScope: "all", jspdf: { orientation: "p", unit: "pt", format: "a4",
              margins: { left: 20, right: 10, top: 10, bottom: 10 }, autotable: { styles: { cellPadding: 2, rowHeight: 12, fontSize: 8, fillColor: 255, textColor: 50, fontStyle: "normal", overflow: "ellipsize", halign: "left", valign: "middle" }, headerStyles: { fillColor: [52, 73, 94], textColor: 255, fontStyle: "bold", halign: "center" }, alternateRowStyles: { fillColor: 245 }, tableExport: { onAfterAutotable: null, onBeforeAutotable: null, onAutotableText: null, onTable: null, outputImages: !0 } } }, numbers: { html: { decimalMark: ".", thousandsSeparator: "," }, output: { decimalMark: ".",
                thousandsSeparator: "," } }, onCellData: null, onCellHtmlData: null, onMsoNumberFormat: null, outputMode: "file", pdfmake: { enabled: !1, docDefinition: { pageOrientation: "portrait", defaultStyle: { font: "Roboto" } }, fonts: {} }, tbodySelector: "tr", tfootSelector: "tr", theadSelector: "tr", tableName: "myTableName", type: "csv", worksheetName: "Worksheet" },
              t = this,
              R = null,
              q = [],
              g = [],
              p = 0,
              y = [],
              h = "",
              I = [];c.extend(!0, a, n);I = N(t);if ("csv" == a.type || "tsv" == a.type || "txt" == a.type) {
            var C = "",
                J = 0,
                p = 0,
                W = function (b, d, e) {
              b.each(function () {
                h = "";x(this, d, p, e + b.length, function (b, c, e) {
                  var f = h,
                      d = "";if (null !== b) if (b = v(b, c, e), c = null === b || "" === b ? "" : b.toString(), "tsv" == a.type) b instanceof Date && b.toLocaleString(), d = Q(c, "\t", " ");else if (b instanceof Date) d = a.csvEnclosure + b.toLocaleString() + a.csvEnclosure;else if (d = Q(c, a.csvEnclosure, a.csvEnclosure + a.csvEnclosure), 0 <= d.indexOf(a.csvSeparator) || /[\r\n ]/g.test(d)) d = a.csvEnclosure + d + a.csvEnclosure;h = f + (d + ("tsv" == a.type ? "\t" : a.csvSeparator));
                });h = c.trim(h).substring(0, h.length - 1);0 < h.length && (0 < C.length && (C += "\n"), C += h);p++;
              });return b.length;
            },
                J = J + W(c(t).find("thead").first().find(a.theadSelector), "th,td", J);c(t).find("tbody").each(function () {
              J += W(c(this).find(a.tbodySelector), "td,th", J);
            });a.tfootSelector.length && W(c(t).find("tfoot").first().find(a.tfootSelector), "td,th", J);C += "\n";!0 === a.consoleLog && console.log(C);if ("string" === a.outputMode) return C;if ("base64" === a.outputMode) return D(C);if ("window" === a.outputMode) {
              A(!1, "data:text/" + ("csv" == a.type ? "csv" : "plain") + ";charset=utf-8,", C);return;
            }try {
              var w = new Blob([C], { type: "text/" + ("csv" == a.type ? "csv" : "plain") + ";charset=utf-8" });saveAs(w, a.fileName + "." + a.type, "csv" != a.type || !1 === a.csvUseBOM);
            } catch (b) {
              A(a.fileName + "." + a.type, "data:text/" + ("csv" == a.type ? "csv" : "plain") + ";charset=utf-8," + ("csv" == a.type && a.csvUseBOM ? "\ufeff" : ""), C);
            }
          } else if ("sql" == a.type) {
            var p = 0,
                u = "INSERT INTO `" + a.tableName + "` (",
                q = c(t).find("thead").first().find(a.theadSelector);q.each(function () {
              x(this, "th,td", p, q.length, function (a, c, e) {
                u += "'" + v(a, c, e) + "',";
              });p++;u = c.trim(u);u = c.trim(u).substring(0, u.length - 1);
            });u += ") VALUES ";c(t).find("tbody").each(function () {
              g.push.apply(g, c(this).find(a.tbodySelector));
            });a.tfootSelector.length && g.push.apply(g, c(t).find("tfoot").find(a.tfootSelector));c(g).each(function () {
              h = "";x(this, "td,th", p, q.length + g.length, function (a, c, e) {
                h += "'" + v(a, c, e) + "',";
              });3 < h.length && (u += "(" + h, u = c.trim(u).substring(0, u.length - 1), u += "),");p++;
            });u = c.trim(u).substring(0, u.length - 1);u += ";";!0 === a.consoleLog && console.log(u);if ("string" === a.outputMode) return u;if ("base64" === a.outputMode) return D(u);
            try {
              w = new Blob([u], { type: "text/plain;charset=utf-8" }), saveAs(w, a.fileName + ".sql");
            } catch (b) {
              A(a.fileName + ".sql", "data:application/sql;charset=utf-8,", u);
            }
          } else if ("json" == a.type) {
            var K = [],
                q = c(t).find("thead").first().find(a.theadSelector);q.each(function () {
              var a = [];x(this, "th,td", p, q.length, function (b, c, f) {
                a.push(v(b, c, f));
              });K.push(a);
            });var X = [];c(t).find("tbody").each(function () {
              g.push.apply(g, c(this).find(a.tbodySelector));
            });a.tfootSelector.length && g.push.apply(g, c(t).find("tfoot").find(a.tfootSelector));
            c(g).each(function () {
              var a = {},
                  d = 0;x(this, "td,th", p, q.length + g.length, function (b, c, g) {
                K.length ? a[K[K.length - 1][d]] = v(b, c, g) : a[d] = v(b, c, g);d++;
              });!1 === c.isEmptyObject(a) && X.push(a);p++;
            });n = "";n = "head" == a.jsonScope ? JSON.stringify(K) : "data" == a.jsonScope ? JSON.stringify(X) : JSON.stringify({ header: K, data: X });!0 === a.consoleLog && console.log(n);if ("string" === a.outputMode) return n;if ("base64" === a.outputMode) return D(n);try {
              w = new Blob([n], { type: "application/json;charset=utf-8" }), saveAs(w, a.fileName + ".json");
            } catch (b) {
              A(a.fileName + ".json", "data:application/json;charset=utf-8;base64,", n);
            }
          } else if ("xml" === a.type) {
            p = 0;var B = '<?xml version="1.0" encoding="utf-8"?>';B += "<tabledata><fields>";q = c(t).find("thead").first().find(a.theadSelector);q.each(function () {
              x(this, "th,td", p, q.length, function (a, c, e) {
                B += "<field>" + v(a, c, e) + "</field>";
              });p++;
            });B += "</fields><data>";var ha = 1;c(t).find("tbody").each(function () {
              g.push.apply(g, c(this).find(a.tbodySelector));
            });a.tfootSelector.length && g.push.apply(g, c(t).find("tfoot").find(a.tfootSelector));
            c(g).each(function () {
              var a = 1;h = "";x(this, "td,th", p, q.length + g.length, function (b, c, f) {
                h += "<column-" + a + ">" + v(b, c, f) + "</column-" + a + ">";a++;
              });0 < h.length && "<column-1></column-1>" != h && (B += '<row id="' + ha + '">' + h + "</row>", ha++);p++;
            });B += "</data></tabledata>";!0 === a.consoleLog && console.log(B);if ("string" === a.outputMode) return B;if ("base64" === a.outputMode) return D(B);try {
              w = new Blob([B], { type: "application/xml;charset=utf-8" }), saveAs(w, a.fileName + ".xml");
            } catch (b) {
              A(a.fileName + ".xml", "data:application/xml;charset=utf-8;base64,", B);
            }
          } else if ("excel" === a.type && "xmlss" === a.excelFileFormat) {
            var k = c(t).filter(function () {
              return "none" != c(this).data("tableexport-display") && (c(this).is(":visible") || "always" == c(this).data("tableexport-display"));
            });var Y = [];k.each(function () {
              var b = c(this),
                  d = "";p = 0;I = N(this);q = b.find("thead").first().find(a.theadSelector);var d = d + "<Table>",
                  e = 0;q.each(function () {
                h = "";x(this, "th,td", p, q.length, function (a, b, c) {
                  null !== a && (h += '<Cell><Data ss:Type="String">' + v(a, b, c) + "</Data></Cell>", e++);
                });0 < h.length && (d += "<Row>" + h + "</Row>");p++;
              });g = [];b.find("tbody").each(function () {
                g.push.apply(g, c(this).find(a.tbodySelector));
              });c(g).each(function () {
                c(this);h = "";x(this, "td,th", p, q.length + g.length, function (a, b, c) {
                  if (null !== a) {
                    var d = "String",
                        e = "";a = v(a, b, c);!1 !== jQuery.isNumeric(a) ? d = "Number" : (b = a, -1 < b.indexOf("%") ? (b = U(b.replace(/%/g, "")), !1 !== b && (b /= 100)) : b = !1, number = b, !1 !== number && (a = number, d = "Number", e = ' ss:StyleID="pct1"'));"Number" !== d && (a = a.replace(/\n/g, "<br>"));h += "<Cell" + e + '><Data ss:Type="' + d + '">' + a + "</Data></Cell>";
                  }
                });
                0 < h.length && (d += "<Row>" + h + "</Row>");p++;
              });d += "</Table>";Y.push(d);!0 === a.consoleLog && console.log(d);
            });k = '<?xml version="1.0" encoding="UTF-8"?><?mso-application progid="Excel.Sheet"?> <Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40"> <DocumentProperties xmlns="urn:schemas-microsoft-com:office:office"> <Created>' + new Date().toISOString() + '</Created> </DocumentProperties> <OfficeDocumentSettings xmlns="urn:schemas-microsoft-com:office:office"> <AllowPNG/> </OfficeDocumentSettings> <ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"> <WindowHeight>9000</WindowHeight> <WindowWidth>13860</WindowWidth> <WindowTopX>0</WindowTopX> <WindowTopY>0</WindowTopY> <ProtectStructure>False</ProtectStructure> <ProtectWindows>False</ProtectWindows> </ExcelWorkbook> <Styles> <Style ss:ID="Default" ss:Name="Default"> <Alignment ss:Vertical="Center"/> <Borders/> <Font/> <Interior/> <NumberFormat/> <Protection/> </Style> <Style ss:ID="Normal" ss:Name="Normal"/> <Style ss:ID="pct1">   <NumberFormat ss:Format="Percent"/> </Style> </Styles>';
            for (n = 0; n < Y.length; n++) k += '<Worksheet ss:Name="' + ("string" === typeof a.worksheetName ? a.worksheetName + " " + (n + 1) : "undefined" !== typeof a.worksheetName[n] ? a.worksheetName[n] : "Table " + (n + 1)) + '">' + Y[n] + "<WorksheetOptions/> </Worksheet>";k += "</Workbook>";!0 === a.consoleLog && console.log(k);if ("string" === a.outputMode) return k;if ("base64" === a.outputMode) return D(k);try {
              w = new Blob([k], { type: "application/xml;charset=utf-8" }), saveAs(w, a.fileName + ".xml");
            } catch (b) {
              A(a.fileName + ".xml", "data:application/xml;charset=utf-8;base64,", B);
            }
          } else if ("excel" == a.type || "xls" == a.type || "word" == a.type || "doc" == a.type) {
            n = "excel" == a.type || "xls" == a.type ? "excel" : "word";var G = "excel" == n ? "xls" : "doc",
                S = 'xmlns:x="urn:schemas-microsoft-com:office:' + n + '"';k = c(t).filter(function () {
              return "none" != c(this).data("tableexport-display") && (c(this).is(":visible") || "always" == c(this).data("tableexport-display"));
            });var H = "";k.each(function () {
              var b = c(this);p = 0;I = N(this);H += "<table><thead>";q = b.find("thead").first().find(a.theadSelector);q.each(function () {
                h = "";
                x(this, "th,td", p, q.length, function (b, d, f) {
                  if (null !== b) {
                    var e = "";h += "<th";for (var g in a.excelstyles) if (a.excelstyles.hasOwnProperty(g)) {
                      var l = c(b).css(a.excelstyles[g]);"" !== l && "0px none rgb(0, 0, 0)" != l && "rgba(0, 0, 0, 0)" != l && (e += "" === e ? 'style="' : ";", e += a.excelstyles[g] + ":" + l);
                    }"" !== e && (h += " " + e + '"');c(b).is("[colspan]") && (h += ' colspan="' + c(b).attr("colspan") + '"');c(b).is("[rowspan]") && (h += ' rowspan="' + c(b).attr("rowspan") + '"');h += ">" + v(b, d, f) + "</th>";
                  }
                });0 < h.length && (H += "<tr>" + h + "</tr>");p++;
              });H += "</thead><tbody>";b.find("tbody").each(function () {
                g.push.apply(g, c(this).find(a.tbodySelector));
              });a.tfootSelector.length && g.push.apply(g, b.find("tfoot").find(a.tfootSelector));c(g).each(function () {
                var b = c(this);h = "";x(this, "td,th", p, q.length + g.length, function (d, f, g) {
                  if (null !== d) {
                    var e = "",
                        l = c(d).data("tableexport-msonumberformat");"undefined" == typeof l && "function" === typeof a.onMsoNumberFormat && (l = a.onMsoNumberFormat(d, f, g));"undefined" != typeof l && "" !== l && (e = "style=\"mso-number-format:'" + l + "'");for (var m in a.excelstyles) a.excelstyles.hasOwnProperty(m) && (l = c(d).css(a.excelstyles[m]), "" === l && (l = b.css(a.excelstyles[m])), "" !== l && "0px none rgb(0, 0, 0)" != l && "rgba(0, 0, 0, 0)" != l && (e += "" === e ? 'style="' : ";", e += a.excelstyles[m] + ":" + l));h += "<td";"" !== e && (h += " " + e + '"');c(d).is("[colspan]") && (h += ' colspan="' + c(d).attr("colspan") + '"');c(d).is("[rowspan]") && (h += ' rowspan="' + c(d).attr("rowspan") + '"');h += ">" + v(d, f, g).replace(/\n/g, "<br>") + "</td>";
                  }
                });0 < h.length && (H += "<tr>" + h + "</tr>");p++;
              });a.displayTableName && (H += "<tr><td></td></tr><tr><td></td></tr><tr><td>" + v(c("<p>" + a.tableName + "</p>")) + "</td></tr>");H += "</tbody></table>";!0 === a.consoleLog && console.log(H);
            });k = '<html xmlns:o="urn:schemas-microsoft-com:office:office" ' + S + ' xmlns="http://www.w3.org/TR/REC-html40">' + ('<meta http-equiv="content-type" content="application/vnd.ms-' + n + '; charset=UTF-8">') + "<head>";"excel" === n && (k += "\x3c!--[if gte mso 9]>", k += "<xml>", k += "<x:ExcelWorkbook>", k += "<x:ExcelWorksheets>", k += "<x:ExcelWorksheet>", k += "<x:Name>", k += a.worksheetName, k += "</x:Name>", k += "<x:WorksheetOptions>", k += "<x:DisplayGridlines/>", k += "</x:WorksheetOptions>", k += "</x:ExcelWorksheet>", k += "</x:ExcelWorksheets>", k += "</x:ExcelWorkbook>", k += "</xml>", k += "<![endif]--\x3e");k += "<style>br {mso-data-placement:same-cell;}</style>";k += "</head>";k += "<body>";k += H;k += "</body>";k += "</html>";!0 === a.consoleLog && console.log(k);if ("string" === a.outputMode) return k;if ("base64" === a.outputMode) return D(k);try {
              w = new Blob([k], { type: "application/vnd.ms-" + a.type }), saveAs(w, a.fileName + "." + G);
            } catch (b) {
              A(a.fileName + "." + G, "data:application/vnd.ms-" + n + ";base64,", k);
            }
          } else if ("xlsx" == a.type) {
            var ia = [],
                Z = [],
                p = 0,
                g = c(t).find("thead").first().find(a.theadSelector);c(t).find("tbody").each(function () {
              g.push.apply(g, c(this).find(a.tbodySelector));
            });a.tfootSelector.length && g.push.apply(g, c(t).find("tfoot").find(a.tfootSelector));c(g).each(function () {
              var a = [];x(this, "th,td", p, g.length, function (b, c, d) {
                if ("undefined" !== typeof b && null !== b) {
                  var e = parseInt(b.getAttribute("colspan")),
                      f = parseInt(b.getAttribute("rowspan"));b = v(b, c, d);"" !== b && b == +b && (b = +b);Z.forEach(function (b) {
                    if (p >= b.s.r && p <= b.e.r && a.length >= b.s.c && a.length <= b.e.c) for (var c = 0; c <= b.e.c - b.s.c; ++c) a.push(null);
                  });if (f || e) e = e || 1, Z.push({ s: { r: p, c: a.length }, e: { r: p + (f || 1) - 1, c: a.length + e - 1 } });a.push("" !== b ? b : null);if (e) for (f = 0; f < e - 1; ++f) a.push(null);
                }
              });ia.push(a);p++;
            });n = new V();G = pa(ia);G["!merges"] = Z;n.SheetNames.push(a.worksheetName);n.Sheets[a.worksheetName] = G;n = XLSX.write(n, { bookType: a.type, bookSST: !1, type: "binary" });try {
              w = new Blob([oa(n)], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8" }), saveAs(w, a.fileName + "." + a.type);
            } catch (b) {
              A(a.fileName + "." + a.type, "data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8,", w);
            }
          } else if ("png" == a.type) html2canvas(c(t)[0]).then(function (b) {
            b = b.toDataURL();for (var c = atob(b.substring(22)), d = new ArrayBuffer(c.length), f = new Uint8Array(d), g = 0; g < c.length; g++) f[g] = c.charCodeAt(g);!0 === a.consoleLog && console.log(c);if ("string" === a.outputMode) return c;if ("base64" === a.outputMode) return D(b);if ("window" === a.outputMode) window.open(b);else try {
              w = new Blob([d], { type: "image/png" }), saveAs(w, a.fileName + ".png");
            } catch (F) {
              A(a.fileName + ".png", "data:image/png,", w);
            }
          });else if ("pdf" == a.type) if (!0 === a.pdfmake.enabled) {
            n = [];var ja = [],
                p = 0,
                G = function (a, d, e) {
              var b = 0;c(a).each(function () {
                var a = [];x(this, d, p, e, function (b, c, d) {
                  if ("undefined" !== typeof b && null !== b) {
                    var e = parseInt(b.getAttribute("colspan")),
                        f = parseInt(b.getAttribute("rowspan"));b = v(b, c, d) || " ";1 < e || 1 < f ? a.push({ colSpan: e || 1, rowSpan: f || 1, text: b }) : a.push(b);
                  } else a.push(" ");
                });a.length && ja.push(a);b < a.length && (b = a.length);p++;
              });return b;
            },
                q = c(this).find("thead").first().find(a.theadSelector);k = G(q, "th,td", q.length);for (S = n.length; S < k; S++) n.push("*");c(this).find("tbody").each(function () {
              g.push.apply(g, c(this).find(a.tbodySelector));
            });a.tfootSelector.length && g.push.apply(g, c(this).find("tfoot").find(a.tfootSelector));G(g, "th,td", q.length + g.length);n = { content: [{ table: { headerRows: q.length, widths: n, body: ja } }] };c.extend(!0, n, a.pdfmake.docDefinition);pdfMake.fonts = { Roboto: { normal: "Roboto-Regular.ttf",
                bold: "Roboto-Medium.ttf", italics: "Roboto-Italic.ttf", bolditalics: "Roboto-MediumItalic.ttf" } };c.extend(!0, pdfMake.fonts, a.pdfmake.fonts);pdfMake.createPdf(n).getBuffer(function (b) {
              try {
                var c = new Blob([b], { type: "application/pdf" });saveAs(c, a.fileName + ".pdf");
              } catch (e) {
                A(a.fileName + ".pdf", "data:application/pdf;base64,", b);
              }
            });
          } else if (!1 === a.jspdf.autotable) {
            n = { dim: { w: P(c(t).first().get(0), "width", "mm"), h: P(c(t).first().get(0), "height", "mm") }, pagesplit: !1 };var ka = new jsPDF(a.jspdf.orientation, a.jspdf.unit, a.jspdf.format);ka.addHTML(c(t).first(), a.jspdf.margins.left, a.jspdf.margins.top, n, function () {
              aa(ka, !1);
            });
          } else {
            var d = a.jspdf.autotable.tableExport;if ("string" === typeof a.jspdf.format && "bestfit" === a.jspdf.format.toLowerCase()) {
              var L = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89] },
                  T = "",
                  M = "",
                  la = 0;c(t).filter(":visible").each(function () {
                if ("none" != c(this).css("display")) {
                  var a = P(c(this).get(0), "width", "pt");if (a > la) {
                    a > L.a0[0] && (T = "a0", M = "l");for (var d in L) L.hasOwnProperty(d) && L[d][1] > a && (T = d, M = "l", L[d][0] > a && (M = "p"));la = a;
                  }
                }
              });a.jspdf.format = "" === T ? "a4" : T;a.jspdf.orientation = "" === M ? "w" : M;
            }d.doc = new jsPDF(a.jspdf.orientation, a.jspdf.unit, a.jspdf.format);!0 === d.outputImages && (d.images = {});"undefined" != typeof d.images && (c(t).filter(function () {
              return "none" != c(this).data("tableexport-display") && (c(this).is(":visible") || "always" == c(this).data("tableexport-display"));
            }).each(function () {
              var b = 0;q = c(this).find("thead").find(a.theadSelector);c(this).find("tbody").each(function () {
                g.push.apply(g, c(this).find(a.tbodySelector));
              });a.tfootSelector.length && g.push.apply(g, c(this).find("tfoot").find(a.tfootSelector));c(g).each(function () {
                x(this, "td,th", q.length + b, q.length + g.length, function (a, b, f) {
                  "undefined" !== typeof a && null !== a && (b = c(a).children(), "undefined" != typeof b && 0 < b.length && ca(a, b, d));
                });b++;
              });
            }), q = [], g = []);ma(d, function (b) {
              c(t).filter(function () {
                return "none" != c(this).data("tableexport-display") && (c(this).is(":visible") || "always" == c(this).data("tableexport-display"));
              }).each(function () {
                var b,
                    e = 0;I = N(this);d.columns = [];d.rows = [];d.rowoptions = {};if ("function" === typeof d.onTable && !1 === d.onTable(c(this), a)) return !0;a.jspdf.autotable.tableExport = null;var f = c.extend(!0, {}, a.jspdf.autotable);a.jspdf.autotable.tableExport = d;f.margin = {};c.extend(!0, f.margin, a.jspdf.margins);f.tableExport = d;"function" !== typeof f.beforePageContent && (f.beforePageContent = function (a) {
                  1 == a.pageCount && a.table.rows.concat(a.table.headerRow).forEach(function (b) {
                    0 < b.height && (b.height += (2 - 1.15) / 2 * b.styles.fontSize, a.table.height += (2 - 1.15) / 2 * b.styles.fontSize);
                  });
                });"function" !== typeof f.createdHeaderCell && (f.createdHeaderCell = function (a, b) {
                  a.styles = c.extend({}, b.row.styles);if ("undefined" != typeof d.columns[b.column.dataKey]) {
                    var e = d.columns[b.column.dataKey];if ("undefined" != typeof e.rect) {
                      a.contentWidth = e.rect.width;if ("undefined" == typeof d.heightRatio || 0 === d.heightRatio) {
                        var g = b.row.raw[b.column.dataKey].rowspan ? b.row.raw[b.column.dataKey].rect.height / b.row.raw[b.column.dataKey].rowspan : b.row.raw[b.column.dataKey].rect.height;
                        d.heightRatio = a.styles.rowHeight / g;
                      }g = b.row.raw[b.column.dataKey].rect.height * d.heightRatio;g > a.styles.rowHeight && (a.styles.rowHeight = g);
                    }"undefined" != typeof e.style && !0 !== e.style.hidden && (a.styles.halign = e.style.align, "inherit" === f.styles.fillColor && (a.styles.fillColor = e.style.bcolor), "inherit" === f.styles.textColor && (a.styles.textColor = e.style.color), "inherit" === f.styles.fontStyle && (a.styles.fontStyle = e.style.fstyle));
                  }
                });"function" !== typeof f.createdCell && (f.createdCell = function (a, b) {
                  var c = d.rowoptions[b.row.index + ":" + b.column.dataKey];"undefined" != typeof c && "undefined" != typeof c.style && !0 !== c.style.hidden && (a.styles.halign = c.style.align, "inherit" === f.styles.fillColor && (a.styles.fillColor = c.style.bcolor), "inherit" === f.styles.textColor && (a.styles.textColor = c.style.color), "inherit" === f.styles.fontStyle && (a.styles.fontStyle = c.style.fstyle));
                });"function" !== typeof f.drawHeaderCell && (f.drawHeaderCell = function (a, b) {
                  var c = d.columns[b.column.dataKey];return (!0 !== c.style.hasOwnProperty("hidden") || !0 !== c.style.hidden) && 0 <= c.rowIndex ? ba(a, b, c) : !1;
                });"function" !== typeof f.drawCell && (f.drawCell = function (a, b) {
                  var c = d.rowoptions[b.row.index + ":" + b.column.dataKey];if (ba(a, b, c)) if (d.doc.rect(a.x, a.y, a.width, a.height, a.styles.fillStyle), "undefined" != typeof c && "undefined" != typeof c.kids && 0 < c.kids.length) {
                    var e = a.height / c.rect.height;if (e > d.dh || "undefined" == typeof d.dh) d.dh = e;d.dw = a.width / c.rect.width;e = a.textPos.y;ea(a, c.kids, d);a.textPos.y = e;fa(a, c.kids, d);
                  } else fa(a, {}, d);return !1;
                });d.headerrows = [];q = c(this).find("thead").find(a.theadSelector);
                q.each(function () {
                  b = 0;d.headerrows[e] = [];x(this, "th,td", e, q.length, function (a, c, f) {
                    var g = ga(a);g.title = v(a, c, f);g.key = b++;g.rowIndex = e;d.headerrows[e].push(g);
                  });e++;
                });if (0 < e) for (var h = e - 1; 0 <= h;) c.each(d.headerrows[h], function () {
                  var a = this;0 < h && null === this.rect && (a = d.headerrows[h - 1][this.key]);null !== a && 0 <= a.rowIndex && (!0 !== a.style.hasOwnProperty("hidden") || !0 !== a.style.hidden) && d.columns.push(a);
                }), h = 0 < d.columns.length ? -1 : h - 1;var k = 0;g = [];c(this).find("tbody").each(function () {
                  g.push.apply(g, c(this).find(a.tbodySelector));
                });
                a.tfootSelector.length && g.push.apply(g, c(this).find("tfoot").find(a.tfootSelector));c(g).each(function () {
                  var a = [];b = 0;x(this, "td,th", e, q.length + g.length, function (e, f, g) {
                    if ("undefined" === typeof d.columns[b]) {
                      var h = { title: "", key: b, style: { hidden: !0 } };d.columns.push(h);
                    }"undefined" !== typeof e && null !== e ? (h = ga(e), h.kids = c(e).children()) : (h = c.extend(!0, {}, d.rowoptions[k + ":" + (b - 1)]), h.colspan = -1);d.rowoptions[k + ":" + b++] = h;a.push(v(e, f, g));
                  });a.length && (d.rows.push(a), k++);e++;
                });if ("function" === typeof d.onBeforeAutotable) d.onBeforeAutotable(c(this), d.columns, d.rows, f);d.doc.autoTable(d.columns, d.rows, f);if ("function" === typeof d.onAfterAutotable) d.onAfterAutotable(c(this), f);a.jspdf.autotable.startY = d.doc.autoTableEndPosY() + f.margin.top;
              });aa(d.doc, "undefined" != typeof d.images && !1 === jQuery.isEmptyObject(d.images));"undefined" != typeof d.headerrows && (d.headerrows.length = 0);"undefined" != typeof d.columns && (d.columns.length = 0);"undefined" != typeof d.rows && (d.rows.length = 0);delete d.doc;d.doc = null;
            });
          }return this;
        } });
    })(jQuery);
  })(this);

  return _retrieveGlobal();
});
System.registerDynamic('npm:bootstrap-table@1.11.2/src/extensions/editable/bootstrap-table-editable.js', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = System.registry.get("@@global-helpers").prepareGlobal($__module.id, null, {});

    (function ($__global) {
        /**
         * @author zhixin wen <wenzhixin2010@gmail.com>
         * extensions: https://github.com/vitalets/x-editable
         */

        (function ($) {

            'use strict';

            $.extend($.fn.bootstrapTable.defaults, {
                editable: true,
                onEditableInit: function () {
                    return false;
                },
                onEditableSave: function (field, row, oldValue, $el) {
                    return false;
                },
                onEditableShown: function (field, row, $el, editable) {
                    return false;
                },
                onEditableHidden: function (field, row, $el, reason) {
                    return false;
                }
            });

            $.extend($.fn.bootstrapTable.Constructor.EVENTS, {
                'editable-init.bs.table': 'onEditableInit',
                'editable-save.bs.table': 'onEditableSave',
                'editable-shown.bs.table': 'onEditableShown',
                'editable-hidden.bs.table': 'onEditableHidden'
            });

            var BootstrapTable = $.fn.bootstrapTable.Constructor,
                _initTable = BootstrapTable.prototype.initTable,
                _initBody = BootstrapTable.prototype.initBody;

            BootstrapTable.prototype.initTable = function () {
                var that = this;
                _initTable.apply(this, Array.prototype.slice.apply(arguments));

                if (!this.options.editable) {
                    return;
                }

                $.each(this.columns, function (i, column) {
                    if (!column.editable) {
                        return;
                    }

                    var editableOptions = {},
                        editableDataMarkup = [],
                        editableDataPrefix = 'editable-';

                    var processDataOptions = function (key, value) {
                        // Replace camel case with dashes.
                        var dashKey = key.replace(/([A-Z])/g, function ($1) {
                            return "-" + $1.toLowerCase();
                        });
                        if (dashKey.slice(0, editableDataPrefix.length) == editableDataPrefix) {
                            var dataKey = dashKey.replace(editableDataPrefix, 'data-');
                            editableOptions[dataKey] = value;
                        }
                    };

                    $.each(that.options, processDataOptions);

                    column.formatter = column.formatter || function (value, row, index) {
                        return value;
                    };
                    column._formatter = column._formatter ? column._formatter : column.formatter;
                    column.formatter = function (value, row, index) {
                        var result = column._formatter ? column._formatter(value, row, index) : value;

                        $.each(column, processDataOptions);

                        $.each(editableOptions, function (key, value) {
                            editableDataMarkup.push(' ' + key + '="' + value + '"');
                        });

                        var _dont_edit_formatter = false;
                        if (column.editable.hasOwnProperty('noeditFormatter')) {
                            _dont_edit_formatter = column.editable.noeditFormatter(value, row, index);
                        }

                        if (_dont_edit_formatter === false) {
                            return ['<a href="javascript:void(0)"', ' data-name="' + column.field + '"', ' data-pk="' + row[that.options.idField] + '"', ' data-value="' + result + '"', editableDataMarkup.join(''), '>' + '</a>'].join('');
                        } else {
                            return _dont_edit_formatter;
                        }
                    };
                });
            };

            BootstrapTable.prototype.initBody = function () {
                var that = this;
                _initBody.apply(this, Array.prototype.slice.apply(arguments));

                if (!this.options.editable) {
                    return;
                }

                $.each(this.columns, function (i, column) {
                    if (!column.editable) {
                        return;
                    }

                    that.$body.find('a[data-name="' + column.field + '"]').editable(column.editable).off('save').on('save', function (e, params) {
                        var data = that.getData(),
                            index = $(this).parents('tr[data-index]').data('index'),
                            row = data[index],
                            oldValue = row[column.field];

                        $(this).data('value', params.submitValue);
                        row[column.field] = params.submitValue;
                        that.trigger('editable-save', column.field, row, oldValue, $(this));
                        that.resetFooter();
                    });
                    that.$body.find('a[data-name="' + column.field + '"]').editable(column.editable).off('shown').on('shown', function (e, editable) {
                        var data = that.getData(),
                            index = $(this).parents('tr[data-index]').data('index'),
                            row = data[index];

                        that.trigger('editable-shown', column.field, row, $(this), editable);
                    });
                    that.$body.find('a[data-name="' + column.field + '"]').editable(column.editable).off('hidden').on('hidden', function (e, reason) {
                        var data = that.getData(),
                            index = $(this).parents('tr[data-index]').data('index'),
                            row = data[index];

                        that.trigger('editable-hidden', column.field, row, $(this), reason);
                    });
                });
                this.trigger('editable-init');
            };
        })(jQuery);
    })(this);

    return _retrieveGlobal();
});
System.registerDynamic("npm:bootstrap-table@1.11.2.json", [], true, function() {
  return {
    "main": "dist/bootstrap-table.js",
    "format": "global",
    "meta": {
      "*.json": {
        "format": "json"
      },
      ".travis.yml": {
        "globals": {
          "process": null
        }
      },
      "Gruntfile.js": {
        "globals": {
          "process": null
        }
      },
      "LICENSE": {
        "globals": {
          "process": null
        }
      },
      "_config.yml": {
        "globals": {
          "process": null
        }
      },
      "dist/*": {
        "globals": {
          "process": null
        }
      },
      "docs/LICENSE": {
        "globals": {
          "process": null
        }
      },
      "docs/_i18n/*": {
        "globals": {
          "process": null
        }
      },
      "docs/_includes/*": {
        "globals": {
          "process": null
        }
      },
      "docs/_layouts/*": {
        "globals": {
          "process": null
        }
      },
      "docs/_plugins/*": {
        "globals": {
          "process": null
        }
      },
      "docs/apple-touch-icon.png": {
        "globals": {
          "process": null
        }
      },
      "docs/assets/*": {
        "globals": {
          "process": null
        }
      },
      "docs/dist/*": {
        "globals": {
          "process": null
        }
      },
      "docs/favicon.ico": {
        "globals": {
          "process": null
        }
      },
      "docs/robots.txt": {
        "globals": {
          "process": null
        }
      },
      "docs/sitemap.xml": {
        "globals": {
          "process": null
        }
      },
      "src/bootstrap-table.css": {
        "globals": {
          "process": null
        }
      },
      "src/bootstrap-table.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/accent-neutralise/bootstrap-table-accent-neutralise.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/angular/*": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/auto-refresh/bootstrap-table-auto-refresh.css": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/auto-refresh/bootstrap-table-auto-refresh.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/click-edit-row/*": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/cookie/bootstrap-table-cookie.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/copy-rows/bootstrap-table-copy-rows.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/editable/bootstrap-table-editable.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/export/bootstrap-table-export.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/filter-control/bootstrap-table-filter-control.css": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/filter-control/bootstrap-table-filter-control.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/filter/bootstrap-table-filter.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/flat-json/bootstrap-table-flat-json.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/group-by-v2/bootstrap-table-group-by.css": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/group-by-v2/bootstrap-table-group-by.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/group-by/bootstrap-table-group-by.css": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/group-by/bootstrap-table-group-by.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/i18n-enhance/bootstrap-table-i18n-enhance.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/key-events/bootstrap-table-key-events.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/mobile/bootstrap-table-mobile.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/multi-column-toggle/bootstrap-table-multi-toggle.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/multiple-search/bootstrap-table-multiple-search.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.css": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/multiple-sort/bootstrap-table-multiple-sort.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/natural-sorting/bootstrap-table-natural-sorting.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/print/*": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/reorder-columns/bootstrap-table-reorder-columns.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/reorder-rows/bootstrap-table-reorder-rows.css": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/reorder-rows/bootstrap-table-reorder-rows.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/resizable/bootstrap-table-resizable.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/select2-filter/bootstrap-table-select2-filter.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/sticky-header/bootstrap-table-sticky-header.css": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/sticky-header/bootstrap-table-sticky-header.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/toolbar/bootstrap-table-toolbar.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/tree-column/bootstrap-table-tree-column.css": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/tree-column/bootstrap-table-tree-column.js": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/tree-column/bootstrap-table-tree-column.less": {
        "globals": {
          "process": null
        }
      },
      "src/extensions/tree-column/icon.png": {
        "globals": {
          "process": null
        }
      },
      "src/locale/*": {
        "globals": {
          "process": null
        }
      }
    }
  };
});

System.registerDynamic('npm:bootstrap-table@1.11.2/src/extensions/export/bootstrap-table-export.js', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = System.registry.get("@@global-helpers").prepareGlobal($__module.id, null, {});

    (function ($__global) {
        /**
         * @author zhixin wen <wenzhixin2010@gmail.com>
         * extensions: https://github.com/kayalshri/tableExport.jquery.plugin
         */

        (function ($) {
            'use strict';

            var sprintf = $.fn.bootstrapTable.utils.sprintf;

            var TYPE_NAME = {
                json: 'JSON',
                xml: 'XML',
                png: 'PNG',
                csv: 'CSV',
                txt: 'TXT',
                sql: 'SQL',
                doc: 'MS-Word',
                excel: 'MS-Excel',
                xlsx: 'MS-Excel (OpenXML)',
                powerpoint: 'MS-Powerpoint',
                pdf: 'PDF'
            };

            $.extend($.fn.bootstrapTable.defaults, {
                showExport: false,
                exportDataType: 'basic', // basic, all, selected
                // 'json', 'xml', 'png', 'csv', 'txt', 'sql', 'doc', 'excel', 'powerpoint', 'pdf'
                exportTypes: ['json', 'xml', 'csv', 'txt', 'sql', 'excel'],
                exportOptions: {}
            });

            $.extend($.fn.bootstrapTable.defaults.icons, {
                export: 'glyphicon-export icon-share'
            });

            $.extend($.fn.bootstrapTable.locales, {
                formatExport: function () {
                    return 'Export data';
                }
            });
            $.extend($.fn.bootstrapTable.defaults, $.fn.bootstrapTable.locales);

            var BootstrapTable = $.fn.bootstrapTable.Constructor,
                _initToolbar = BootstrapTable.prototype.initToolbar;

            BootstrapTable.prototype.initToolbar = function () {
                this.showToolbar = this.options.showExport;

                _initToolbar.apply(this, Array.prototype.slice.apply(arguments));

                if (this.options.showExport) {
                    var that = this,
                        $btnGroup = this.$toolbar.find('>.btn-group'),
                        $export = $btnGroup.find('div.export');

                    if (!$export.length) {
                        $export = $(['<div class="export btn-group">', '<button class="btn' + sprintf(' btn-%s', this.options.buttonsClass) + sprintf(' btn-%s', this.options.iconSize) + ' dropdown-toggle" aria-label="export type" ' + 'title="' + this.options.formatExport() + '" ' + 'data-toggle="dropdown" type="button">', sprintf('<i class="%s %s"></i> ', this.options.iconsPrefix, this.options.icons.export), '<span class="caret"></span>', '</button>', '<ul class="dropdown-menu" role="menu">', '</ul>', '</div>'].join('')).appendTo($btnGroup);

                        var $menu = $export.find('.dropdown-menu'),
                            exportTypes = this.options.exportTypes;

                        if (typeof this.options.exportTypes === 'string') {
                            var types = this.options.exportTypes.slice(1, -1).replace(/ /g, '').split(',');

                            exportTypes = [];
                            $.each(types, function (i, value) {
                                exportTypes.push(value.slice(1, -1));
                            });
                        }
                        $.each(exportTypes, function (i, type) {
                            if (TYPE_NAME.hasOwnProperty(type)) {
                                $menu.append(['<li role="menuitem" data-type="' + type + '">', '<a href="javascript:void(0)">', TYPE_NAME[type], '</a>', '</li>'].join(''));
                            }
                        });

                        $menu.find('li').click(function () {
                            var type = $(this).data('type'),
                                doExport = function () {
                                that.$el.tableExport($.extend({}, that.options.exportOptions, {
                                    type: type,
                                    escape: false
                                }));
                            };

                            if (that.options.exportDataType === 'all' && that.options.pagination) {
                                that.$el.one(that.options.sidePagination === 'server' ? 'post-body.bs.table' : 'page-change.bs.table', function () {
                                    doExport();
                                    that.togglePagination();
                                });
                                that.togglePagination();
                            } else if (that.options.exportDataType === 'selected') {
                                var data = that.getData(),
                                    selectedData = that.getAllSelections();

                                // Quick fix #2220
                                if (that.options.sidePagination === 'server') {
                                    data = { total: that.options.totalRows };
                                    data[that.options.dataField] = that.getData();

                                    selectedData = { total: that.options.totalRows };
                                    selectedData[that.options.dataField] = that.getAllSelections();
                                }

                                that.load(selectedData);
                                doExport();
                                that.load(data);
                            } else {
                                doExport();
                            }
                        });
                    }
                }
            };
        })(jQuery);
    })(this);

    return _retrieveGlobal();
});
/*!
 * @version: 1.1.2
 * @name: Adapted editor plugin
 *
 * @author: https://themeforest.net/user/flexlayers
 */
/**
 * Super simple wysiwyg editor v0.8.6
 * http://summernote.org/
 *
 * summernote.js
 * Copyright 2013- Alan Hong. and other contributors
 * summernote may be freely distributed under the MIT license./
 *
 * Date: 2017-07-16T16:33Z
 */
(function (factory) {
    /* global define */
    if ('function' === 'function' && true) {
        // AMD. Register as an anonymous module.
        System.registerDynamic('reactiveadmintemplate/scripts/modules/form/editor/summernote.js', ['jquery'], false, function ($__require, $__exports, $__module) {
            if (typeof factory === 'function') {
                return factory.call(this, $__require('jquery'));
            } else {
                return factory;
            }
        });
    } else if (typeof module === 'object' && module.exports) {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory(window.jQuery);
    }
})(function ($) {
    'use strict';

    /**
     * @class core.func
     *
     * func utils (for high-order func's arg)
     *
     * @singleton
     * @alternateClassName func
     */

    var func = function () {
        var eq = function (itemA) {
            return function (itemB) {
                return itemA === itemB;
            };
        };

        var eq2 = function (itemA, itemB) {
            return itemA === itemB;
        };

        var peq2 = function (propName) {
            return function (itemA, itemB) {
                return itemA[propName] === itemB[propName];
            };
        };

        var ok = function () {
            return true;
        };

        var fail = function () {
            return false;
        };

        var not = function (f) {
            return function () {
                return !f.apply(f, arguments);
            };
        };

        var and = function (fA, fB) {
            return function (item) {
                return fA(item) && fB(item);
            };
        };

        var self = function (a) {
            return a;
        };

        var invoke = function (obj, method) {
            return function () {
                return obj[method].apply(obj, arguments);
            };
        };

        var idCounter = 0;

        /**
         * generate a globally-unique id
         *
         * @param {String} [prefix]
         */
        var uniqueId = function (prefix) {
            var id = ++idCounter + '';
            return prefix ? prefix + id : id;
        };

        /**
         * returns bnd (bounds) from rect
         *
         * - IE Compatibility Issue: http://goo.gl/sRLOAo
         * - Scroll Issue: http://goo.gl/sNjUc
         *
         * @param {Rect} rect
         * @return {Object} bounds
         * @return {Number} bounds.top
         * @return {Number} bounds.left
         * @return {Number} bounds.width
         * @return {Number} bounds.height
         */
        var rect2bnd = function (rect) {
            var $document = $(document);
            return {
                top: rect.top + $document.scrollTop(),
                left: rect.left + $document.scrollLeft(),
                width: rect.right - rect.left,
                height: rect.bottom - rect.top
            };
        };

        /**
         * returns a copy of the object where the keys have become the values and the values the keys.
         * @param {Object} obj
         * @return {Object}
         */
        var invertObject = function (obj) {
            var inverted = {};
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    inverted[obj[key]] = key;
                }
            }
            return inverted;
        };

        /**
         * @param {String} namespace
         * @param {String} [prefix]
         * @return {String}
         */
        var namespaceToCamel = function (namespace, prefix) {
            prefix = prefix || '';
            return prefix + namespace.split('.').map(function (name) {
                return name.substring(0, 1).toUpperCase() + name.substring(1);
            }).join('');
        };

        /**
         * Returns a function, that, as long as it continues to be invoked, will not
         * be triggered. The function will be called after it stops being called for
         * N milliseconds. If `immediate` is passed, trigger the function on the
         * leading edge, instead of the trailing.
         * @param {Function} func
         * @param {Number} wait
         * @param {Boolean} immediate
         * @return {Function}
         */
        var debounce = function (func, wait, immediate) {
            var timeout;
            return function () {
                var context = this,
                    args = arguments;
                var later = function () {
                    timeout = null;
                    if (!immediate) {
                        func.apply(context, args);
                    }
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) {
                    func.apply(context, args);
                }
            };
        };

        return {
            eq: eq,
            eq2: eq2,
            peq2: peq2,
            ok: ok,
            fail: fail,
            self: self,
            not: not,
            and: and,
            invoke: invoke,
            uniqueId: uniqueId,
            rect2bnd: rect2bnd,
            invertObject: invertObject,
            namespaceToCamel: namespaceToCamel,
            debounce: debounce
        };
    }();

    /**
     * @class core.list
     *
     * list utils
     *
     * @singleton
     * @alternateClassName list
     */
    var list = function () {
        /**
         * returns the first item of an array.
         *
         * @param {Array} array
         */
        var head = function (array) {
            return array[0];
        };

        /**
         * returns the last item of an array.
         *
         * @param {Array} array
         */
        var last = function (array) {
            return array[array.length - 1];
        };

        /**
         * returns everything but the last entry of the array.
         *
         * @param {Array} array
         */
        var initial = function (array) {
            return array.slice(0, array.length - 1);
        };

        /**
         * returns the rest of the items in an array.
         *
         * @param {Array} array
         */
        var tail = function (array) {
            return array.slice(1);
        };

        /**
         * returns item of array
         */
        var find = function (array, pred) {
            for (var idx = 0, len = array.length; idx < len; idx++) {
                var item = array[idx];
                if (pred(item)) {
                    return item;
                }
            }
        };

        /**
         * returns true if all of the values in the array pass the predicate truth test.
         */
        var all = function (array, pred) {
            for (var idx = 0, len = array.length; idx < len; idx++) {
                if (!pred(array[idx])) {
                    return false;
                }
            }
            return true;
        };

        /**
         * returns index of item
         */
        var indexOf = function (array, item) {
            return $.inArray(item, array);
        };

        /**
         * returns true if the value is present in the list.
         */
        var contains = function (array, item) {
            return indexOf(array, item) !== -1;
        };

        /**
         * get sum from a list
         *
         * @param {Array} array - array
         * @param {Function} fn - iterator
         */
        var sum = function (array, fn) {
            fn = fn || func.self;
            return array.reduce(function (memo, v) {
                return memo + fn(v);
            }, 0);
        };

        /**
         * returns a copy of the collection with array type.
         * @param {Collection} collection - collection eg) node.childNodes, ...
         */
        var from = function (collection) {
            var result = [],
                idx = -1,
                length = collection.length;
            while (++idx < length) {
                result[idx] = collection[idx];
            }
            return result;
        };

        /**
         * returns whether list is empty or not
         */
        var isEmpty = function (array) {
            return !array || !array.length;
        };

        /**
         * cluster elements by predicate function.
         *
         * @param {Array} array - array
         * @param {Function} fn - predicate function for cluster rule
         * @param {Array[]}
         */
        var clusterBy = function (array, fn) {
            if (!array.length) {
                return [];
            }
            var aTail = tail(array);
            return aTail.reduce(function (memo, v) {
                var aLast = last(memo);
                if (fn(last(aLast), v)) {
                    aLast[aLast.length] = v;
                } else {
                    memo[memo.length] = [v];
                }
                return memo;
            }, [[head(array)]]);
        };

        /**
         * returns a copy of the array with all false values removed
         *
         * @param {Array} array - array
         * @param {Function} fn - predicate function for cluster rule
         */
        var compact = function (array) {
            var aResult = [];
            for (var idx = 0, len = array.length; idx < len; idx++) {
                if (array[idx]) {
                    aResult.push(array[idx]);
                }
            }
            return aResult;
        };

        /**
         * produces a duplicate-free version of the array
         *
         * @param {Array} array
         */
        var unique = function (array) {
            var results = [];

            for (var idx = 0, len = array.length; idx < len; idx++) {
                if (!contains(results, array[idx])) {
                    results.push(array[idx]);
                }
            }

            return results;
        };

        /**
         * returns next item.
         * @param {Array} array
         */
        var next = function (array, item) {
            var idx = indexOf(array, item);
            if (idx === -1) {
                return null;
            }

            return array[idx + 1];
        };

        /**
         * returns prev item.
         * @param {Array} array
         */
        var prev = function (array, item) {
            var idx = indexOf(array, item);
            if (idx === -1) {
                return null;
            }

            return array[idx - 1];
        };

        return {
            head: head, last: last, initial: initial, tail: tail,
            prev: prev, next: next, find: find, contains: contains,
            all: all, sum: sum, from: from, isEmpty: isEmpty,
            clusterBy: clusterBy, compact: compact, unique: unique
        };
    }();

    var isSupportAmd = 'function' === 'function' && true;

    /**
     * returns whether font is installed or not.
     *
     * @param {String} fontName
     * @return {Boolean}
     */
    var isFontInstalled = function (fontName) {
        var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';
        var $tester = $('<div>').css({
            position: 'absolute',
            left: '-9999px',
            top: '-9999px',
            fontSize: '200px'
        }).text('mmmmmmmmmwwwwwww').appendTo(document.body);

        var originalWidth = $tester.css('fontFamily', testFontName).width();
        var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();

        $tester.remove();

        return originalWidth !== width;
    };

    var userAgent = navigator.userAgent;
    var isMSIE = /MSIE|Trident/i.test(userAgent);
    var browserVersion;
    if (isMSIE) {
        var matches = /MSIE (\d+[.]\d+)/.exec(userAgent);
        if (matches) {
            browserVersion = parseFloat(matches[1]);
        }
        matches = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(userAgent);
        if (matches) {
            browserVersion = parseFloat(matches[1]);
        }
    }

    var isEdge = /Edge\/\d+/.test(userAgent);

    var hasCodeMirror = !!window.CodeMirror;
    if (!hasCodeMirror && isSupportAmd && typeof require !== 'undefined') {
        if (typeof require.resolve !== 'undefined') {
            try {
                // If CodeMirror can't be resolved, `require.resolve` will throw an
                // exception and `hasCodeMirror` won't be set to `true`.
                require.resolve('codemirror');
                hasCodeMirror = true;
            } catch (e) {
                // Do nothing.
            }
        } else if (typeof eval('require').specified !== 'undefined') {
            hasCodeMirror = eval('require').specified('codemirror');
        }
    }

    /**
     * @class core.agent
     *
     * Object which check platform and agent
     *
     * @singleton
     * @alternateClassName agent
     */
    var agent = {
        isMac: navigator.appVersion.indexOf('Mac') > -1,
        isMSIE: isMSIE,
        isEdge: isEdge,
        isFF: !isEdge && /firefox/i.test(userAgent),
        isPhantom: /PhantomJS/i.test(userAgent),
        isWebkit: !isEdge && /webkit/i.test(userAgent),
        isChrome: !isEdge && /chrome/i.test(userAgent),
        isSafari: !isEdge && /safari/i.test(userAgent),
        browserVersion: browserVersion,
        jqueryVersion: parseFloat($.fn.jquery),
        isSupportAmd: isSupportAmd,
        hasCodeMirror: hasCodeMirror,
        isFontInstalled: isFontInstalled,
        isW3CRangeSupport: !!document.createRange
    };

    var NBSP_CHAR = String.fromCharCode(160);
    var ZERO_WIDTH_NBSP_CHAR = '\ufeff';

    /**
     * @class core.dom
     *
     * Dom functions
     *
     * @singleton
     * @alternateClassName dom
     */
    var dom = function () {
        /**
         * @method isEditable
         *
         * returns whether node is `note-editable` or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */
        var isEditable = function (node) {
            return node && $(node).hasClass('note-editable');
        };

        /**
         * @method isControlSizing
         *
         * returns whether node is `note-control-sizing` or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */
        var isControlSizing = function (node) {
            return node && $(node).hasClass('note-control-sizing');
        };

        /**
         * @method makePredByNodeName
         *
         * returns predicate which judge whether nodeName is same
         *
         * @param {String} nodeName
         * @return {Function}
         */
        var makePredByNodeName = function (nodeName) {
            nodeName = nodeName.toUpperCase();
            return function (node) {
                return node && node.nodeName.toUpperCase() === nodeName;
            };
        };

        /**
         * @method isText
         *
         *
         *
         * @param {Node} node
         * @return {Boolean} true if node's type is text(3)
         */
        var isText = function (node) {
            return node && node.nodeType === 3;
        };

        /**
         * @method isElement
         *
         *
         *
         * @param {Node} node
         * @return {Boolean} true if node's type is element(1)
         */
        var isElement = function (node) {
            return node && node.nodeType === 1;
        };

        /**
         * ex) br, col, embed, hr, img, input, ...
         * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
         */
        var isVoid = function (node) {
            return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());
        };

        var isPara = function (node) {
            if (isEditable(node)) {
                return false;
            }

            // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph
            return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());
        };

        var isHeading = function (node) {
            return node && /^H[1-7]/.test(node.nodeName.toUpperCase());
        };

        var isPre = makePredByNodeName('PRE');

        var isLi = makePredByNodeName('LI');

        var isPurePara = function (node) {
            return isPara(node) && !isLi(node);
        };

        var isTable = makePredByNodeName('TABLE');

        var isData = makePredByNodeName('DATA');

        var isInline = function (node) {
            return !isBodyContainer(node) && !isList(node) && !isHr(node) && !isPara(node) && !isTable(node) && !isBlockquote(node) && !isData(node);
        };

        var isList = function (node) {
            return node && /^UL|^OL/.test(node.nodeName.toUpperCase());
        };

        var isHr = makePredByNodeName('HR');

        var isCell = function (node) {
            return node && /^TD|^TH/.test(node.nodeName.toUpperCase());
        };

        var isBlockquote = makePredByNodeName('BLOCKQUOTE');

        var isBodyContainer = function (node) {
            return isCell(node) || isBlockquote(node) || isEditable(node);
        };

        var isAnchor = makePredByNodeName('A');

        var isParaInline = function (node) {
            return isInline(node) && !!ancestor(node, isPara);
        };

        var isBodyInline = function (node) {
            return isInline(node) && !ancestor(node, isPara);
        };

        var isBody = makePredByNodeName('BODY');

        /**
         * returns whether nodeB is closest sibling of nodeA
         *
         * @param {Node} nodeA
         * @param {Node} nodeB
         * @return {Boolean}
         */
        var isClosestSibling = function (nodeA, nodeB) {
            return nodeA.nextSibling === nodeB || nodeA.previousSibling === nodeB;
        };

        /**
         * returns array of closest siblings with node
         *
         * @param {Node} node
         * @param {function} [pred] - predicate function
         * @return {Node[]}
         */
        var withClosestSiblings = function (node, pred) {
            pred = pred || func.ok;

            var siblings = [];
            if (node.previousSibling && pred(node.previousSibling)) {
                siblings.push(node.previousSibling);
            }
            siblings.push(node);
            if (node.nextSibling && pred(node.nextSibling)) {
                siblings.push(node.nextSibling);
            }
            return siblings;
        };

        /**
         * blank HTML for cursor position
         * - [workaround] old IE only works with &nbsp;
         * - [workaround] IE11 and other browser works with bogus br
         */
        var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';

        /**
         * @method nodeLength
         *
         * returns #text's text size or element's childNodes size
         *
         * @param {Node} node
         */
        var nodeLength = function (node) {
            if (isText(node)) {
                return node.nodeValue.length;
            }

            if (node) {
                return node.childNodes.length;
            }

            return 0;
        };

        /**
         * returns whether node is empty or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */
        var isEmpty = function (node) {
            var len = nodeLength(node);

            if (len === 0) {
                return true;
            } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {
                // ex) <p><br></p>, <span><br></span>
                return true;
            } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {
                // ex) <p></p>, <span></span>
                return true;
            }

            return false;
        };

        /**
         * padding blankHTML if node is empty (for cursor position)
         */
        var paddingBlankHTML = function (node) {
            if (!isVoid(node) && !nodeLength(node)) {
                node.innerHTML = blankHTML;
            }
        };

        /**
         * find nearest ancestor predicate hit
         *
         * @param {Node} node
         * @param {Function} pred - predicate function
         */
        var ancestor = function (node, pred) {
            while (node) {
                if (pred(node)) {
                    return node;
                }
                if (isEditable(node)) {
                    break;
                }

                node = node.parentNode;
            }
            return null;
        };

        /**
         * find nearest ancestor only single child blood line and predicate hit
         *
         * @param {Node} node
         * @param {Function} pred - predicate function
         */
        var singleChildAncestor = function (node, pred) {
            node = node.parentNode;

            while (node) {
                if (nodeLength(node) !== 1) {
                    break;
                }
                if (pred(node)) {
                    return node;
                }
                if (isEditable(node)) {
                    break;
                }

                node = node.parentNode;
            }
            return null;
        };

        /**
         * returns new array of ancestor nodes (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [optional] pred - predicate function
         */
        var listAncestor = function (node, pred) {
            pred = pred || func.fail;

            var ancestors = [];
            ancestor(node, function (el) {
                if (!isEditable(el)) {
                    ancestors.push(el);
                }

                return pred(el);
            });
            return ancestors;
        };

        /**
         * find farthest ancestor predicate hit
         */
        var lastAncestor = function (node, pred) {
            var ancestors = listAncestor(node);
            return list.last(ancestors.filter(pred));
        };

        /**
         * returns common ancestor node between two nodes.
         *
         * @param {Node} nodeA
         * @param {Node} nodeB
         */
        var commonAncestor = function (nodeA, nodeB) {
            var ancestors = listAncestor(nodeA);
            for (var n = nodeB; n; n = n.parentNode) {
                if ($.inArray(n, ancestors) > -1) {
                    return n;
                }
            }
            return null; // difference document area
        };

        /**
         * listing all previous siblings (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [optional] pred - predicate function
         */
        var listPrev = function (node, pred) {
            pred = pred || func.fail;

            var nodes = [];
            while (node) {
                if (pred(node)) {
                    break;
                }
                nodes.push(node);
                node = node.previousSibling;
            }
            return nodes;
        };

        /**
         * listing next siblings (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [pred] - predicate function
         */
        var listNext = function (node, pred) {
            pred = pred || func.fail;

            var nodes = [];
            while (node) {
                if (pred(node)) {
                    break;
                }
                nodes.push(node);
                node = node.nextSibling;
            }
            return nodes;
        };

        /**
         * listing descendant nodes
         *
         * @param {Node} node
         * @param {Function} [pred] - predicate function
         */
        var listDescendant = function (node, pred) {
            var descendants = [];
            pred = pred || func.ok;

            // start DFS(depth first search) with node
            (function fnWalk(current) {
                if (node !== current && pred(current)) {
                    descendants.push(current);
                }
                for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {
                    fnWalk(current.childNodes[idx]);
                }
            })(node);

            return descendants;
        };

        /**
         * wrap node with new tag.
         *
         * @param {Node} node
         * @param {Node} tagName of wrapper
         * @return {Node} - wrapper
         */
        var wrap = function (node, wrapperName) {
            var parent = node.parentNode;
            var wrapper = $('<' + wrapperName + '>')[0];

            parent.insertBefore(wrapper, node);
            wrapper.appendChild(node);

            return wrapper;
        };

        /**
         * insert node after preceding
         *
         * @param {Node} node
         * @param {Node} preceding - predicate function
         */
        var insertAfter = function (node, preceding) {
            var next = preceding.nextSibling,
                parent = preceding.parentNode;
            if (next) {
                parent.insertBefore(node, next);
            } else {
                parent.appendChild(node);
            }
            return node;
        };

        /**
         * append elements.
         *
         * @param {Node} node
         * @param {Collection} aChild
         */
        var appendChildNodes = function (node, aChild) {
            $.each(aChild, function (idx, child) {
                node.appendChild(child);
            });
            return node;
        };

        /**
         * returns whether boundaryPoint is left edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        var isLeftEdgePoint = function (point) {
            return point.offset === 0;
        };

        /**
         * returns whether boundaryPoint is right edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        var isRightEdgePoint = function (point) {
            return point.offset === nodeLength(point.node);
        };

        /**
         * returns whether boundaryPoint is edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        var isEdgePoint = function (point) {
            return isLeftEdgePoint(point) || isRightEdgePoint(point);
        };

        /**
         * returns whether node is left edge of ancestor or not.
         *
         * @param {Node} node
         * @param {Node} ancestor
         * @return {Boolean}
         */
        var isLeftEdgeOf = function (node, ancestor) {
            while (node && node !== ancestor) {
                if (position(node) !== 0) {
                    return false;
                }
                node = node.parentNode;
            }

            return true;
        };

        /**
         * returns whether node is right edge of ancestor or not.
         *
         * @param {Node} node
         * @param {Node} ancestor
         * @return {Boolean}
         */
        var isRightEdgeOf = function (node, ancestor) {
            if (!ancestor) {
                return false;
            }
            while (node && node !== ancestor) {
                if (position(node) !== nodeLength(node.parentNode) - 1) {
                    return false;
                }
                node = node.parentNode;
            }

            return true;
        };

        /**
         * returns whether point is left edge of ancestor or not.
         * @param {BoundaryPoint} point
         * @param {Node} ancestor
         * @return {Boolean}
         */
        var isLeftEdgePointOf = function (point, ancestor) {
            return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);
        };

        /**
         * returns whether point is right edge of ancestor or not.
         * @param {BoundaryPoint} point
         * @param {Node} ancestor
         * @return {Boolean}
         */
        var isRightEdgePointOf = function (point, ancestor) {
            return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);
        };

        /**
         * returns offset from parent.
         *
         * @param {Node} node
         */
        var position = function (node) {
            var offset = 0;
            while (node = node.previousSibling) {
                offset += 1;
            }
            return offset;
        };

        var hasChildren = function (node) {
            return !!(node && node.childNodes && node.childNodes.length);
        };

        /**
         * returns previous boundaryPoint
         *
         * @param {BoundaryPoint} point
         * @param {Boolean} isSkipInnerOffset
         * @return {BoundaryPoint}
         */
        var prevPoint = function (point, isSkipInnerOffset) {
            var node, offset;

            if (point.offset === 0) {
                if (isEditable(point.node)) {
                    return null;
                }

                node = point.node.parentNode;
                offset = position(point.node);
            } else if (hasChildren(point.node)) {
                node = point.node.childNodes[point.offset - 1];
                offset = nodeLength(node);
            } else {
                node = point.node;
                offset = isSkipInnerOffset ? 0 : point.offset - 1;
            }

            return {
                node: node,
                offset: offset
            };
        };

        /**
         * returns next boundaryPoint
         *
         * @param {BoundaryPoint} point
         * @param {Boolean} isSkipInnerOffset
         * @return {BoundaryPoint}
         */
        var nextPoint = function (point, isSkipInnerOffset) {
            var node, offset;

            if (nodeLength(point.node) === point.offset) {
                if (isEditable(point.node)) {
                    return null;
                }

                node = point.node.parentNode;
                offset = position(point.node) + 1;
            } else if (hasChildren(point.node)) {
                node = point.node.childNodes[point.offset];
                offset = 0;
            } else {
                node = point.node;
                offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;
            }

            return {
                node: node,
                offset: offset
            };
        };

        /**
         * returns whether pointA and pointB is same or not.
         *
         * @param {BoundaryPoint} pointA
         * @param {BoundaryPoint} pointB
         * @return {Boolean}
         */
        var isSamePoint = function (pointA, pointB) {
            return pointA.node === pointB.node && pointA.offset === pointB.offset;
        };

        /**
         * returns whether point is visible (can set cursor) or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        var isVisiblePoint = function (point) {
            if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {
                return true;
            }

            var leftNode = point.node.childNodes[point.offset - 1];
            var rightNode = point.node.childNodes[point.offset];
            if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {
                return true;
            }

            return false;
        };

        /**
         * @method prevPointUtil
         *
         * @param {BoundaryPoint} point
         * @param {Function} pred
         * @return {BoundaryPoint}
         */
        var prevPointUntil = function (point, pred) {
            while (point) {
                if (pred(point)) {
                    return point;
                }

                point = prevPoint(point);
            }

            return null;
        };

        /**
         * @method nextPointUntil
         *
         * @param {BoundaryPoint} point
         * @param {Function} pred
         * @return {BoundaryPoint}
         */
        var nextPointUntil = function (point, pred) {
            while (point) {
                if (pred(point)) {
                    return point;
                }

                point = nextPoint(point);
            }

            return null;
        };

        /**
         * returns whether point has character or not.
         *
         * @param {Point} point
         * @return {Boolean}
         */
        var isCharPoint = function (point) {
            if (!isText(point.node)) {
                return false;
            }

            var ch = point.node.nodeValue.charAt(point.offset - 1);
            return ch && ch !== ' ' && ch !== NBSP_CHAR;
        };

        /**
         * @method walkPoint
         *
         * @param {BoundaryPoint} startPoint
         * @param {BoundaryPoint} endPoint
         * @param {Function} handler
         * @param {Boolean} isSkipInnerOffset
         */
        var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {
            var point = startPoint;

            while (point) {
                handler(point);

                if (isSamePoint(point, endPoint)) {
                    break;
                }

                var isSkipOffset = isSkipInnerOffset && startPoint.node !== point.node && endPoint.node !== point.node;
                point = nextPoint(point, isSkipOffset);
            }
        };

        /**
         * @method makeOffsetPath
         *
         * return offsetPath(array of offset) from ancestor
         *
         * @param {Node} ancestor - ancestor node
         * @param {Node} node
         */
        var makeOffsetPath = function (ancestor, node) {
            var ancestors = listAncestor(node, func.eq(ancestor));
            return ancestors.map(position).reverse();
        };

        /**
         * @method fromOffsetPath
         *
         * return element from offsetPath(array of offset)
         *
         * @param {Node} ancestor - ancestor node
         * @param {array} offsets - offsetPath
         */
        var fromOffsetPath = function (ancestor, offsets) {
            var current = ancestor;
            for (var i = 0, len = offsets.length; i < len; i++) {
                if (current.childNodes.length <= offsets[i]) {
                    current = current.childNodes[current.childNodes.length - 1];
                } else {
                    current = current.childNodes[offsets[i]];
                }
            }
            return current;
        };

        /**
         * @method splitNode
         *
         * split element or #text
         *
         * @param {BoundaryPoint} point
         * @param {Object} [options]
         * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
         * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
         * @return {Node} right node of boundaryPoint
         */
        var splitNode = function (point, options) {
            var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;
            var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;

            // edge case
            if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {
                if (isLeftEdgePoint(point)) {
                    return point.node;
                } else if (isRightEdgePoint(point)) {
                    return point.node.nextSibling;
                }
            }

            // split #text
            if (isText(point.node)) {
                return point.node.splitText(point.offset);
            } else {
                var childNode = point.node.childNodes[point.offset];
                var clone = insertAfter(point.node.cloneNode(false), point.node);
                appendChildNodes(clone, listNext(childNode));

                if (!isSkipPaddingBlankHTML) {
                    paddingBlankHTML(point.node);
                    paddingBlankHTML(clone);
                }

                return clone;
            }
        };

        /**
         * @method splitTree
         *
         * split tree by point
         *
         * @param {Node} root - split root
         * @param {BoundaryPoint} point
         * @param {Object} [options]
         * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
         * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
         * @return {Node} right node of boundaryPoint
         */
        var splitTree = function (root, point, options) {
            // ex) [#text, <span>, <p>]
            var ancestors = listAncestor(point.node, func.eq(root));

            if (!ancestors.length) {
                return null;
            } else if (ancestors.length === 1) {
                return splitNode(point, options);
            }

            return ancestors.reduce(function (node, parent) {
                if (node === point.node) {
                    node = splitNode(point, options);
                }

                return splitNode({
                    node: parent,
                    offset: node ? dom.position(node) : nodeLength(parent)
                }, options);
            });
        };

        /**
         * split point
         *
         * @param {Point} point
         * @param {Boolean} isInline
         * @return {Object}
         */
        var splitPoint = function (point, isInline) {
            // find splitRoot, container
            //  - inline: splitRoot is a child of paragraph
            //  - block: splitRoot is a child of bodyContainer
            var pred = isInline ? isPara : isBodyContainer;
            var ancestors = listAncestor(point.node, pred);
            var topAncestor = list.last(ancestors) || point.node;

            var splitRoot, container;
            if (pred(topAncestor)) {
                splitRoot = ancestors[ancestors.length - 2];
                container = topAncestor;
            } else {
                splitRoot = topAncestor;
                container = splitRoot.parentNode;
            }

            // if splitRoot is exists, split with splitTree
            var pivot = splitRoot && splitTree(splitRoot, point, {
                isSkipPaddingBlankHTML: isInline,
                isNotSplitEdgePoint: isInline
            });

            // if container is point.node, find pivot with point.offset
            if (!pivot && container === point.node) {
                pivot = point.node.childNodes[point.offset];
            }

            return {
                rightNode: pivot,
                container: container
            };
        };

        var create = function (nodeName) {
            return document.createElement(nodeName);
        };

        var createText = function (text) {
            return document.createTextNode(text);
        };

        /**
         * @method remove
         *
         * remove node, (isRemoveChild: remove child or not)
         *
         * @param {Node} node
         * @param {Boolean} isRemoveChild
         */
        var remove = function (node, isRemoveChild) {
            if (!node || !node.parentNode) {
                return;
            }
            if (node.removeNode) {
                return node.removeNode(isRemoveChild);
            }

            var parent = node.parentNode;
            if (!isRemoveChild) {
                var nodes = [];
                var i, len;
                for (i = 0, len = node.childNodes.length; i < len; i++) {
                    nodes.push(node.childNodes[i]);
                }

                for (i = 0, len = nodes.length; i < len; i++) {
                    parent.insertBefore(nodes[i], node);
                }
            }

            parent.removeChild(node);
        };

        /**
         * @method removeWhile
         *
         * @param {Node} node
         * @param {Function} pred
         */
        var removeWhile = function (node, pred) {
            while (node) {
                if (isEditable(node) || !pred(node)) {
                    break;
                }

                var parent = node.parentNode;
                remove(node);
                node = parent;
            }
        };

        /**
         * @method replace
         *
         * replace node with provided nodeName
         *
         * @param {Node} node
         * @param {String} nodeName
         * @return {Node} - new node
         */
        var replace = function (node, nodeName) {
            if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {
                return node;
            }

            var newNode = create(nodeName);

            if (node.style.cssText) {
                newNode.style.cssText = node.style.cssText;
            }

            appendChildNodes(newNode, list.from(node.childNodes));
            insertAfter(newNode, node);
            remove(node);

            return newNode;
        };

        var isTextarea = makePredByNodeName('TEXTAREA');

        /**
         * @param {jQuery} $node
         * @param {Boolean} [stripLinebreaks] - default: false
         */
        var value = function ($node, stripLinebreaks) {
            var val = isTextarea($node[0]) ? $node.val() : $node.html();
            if (stripLinebreaks) {
                return val.replace(/[\n\r]/g, '');
            }
            return val;
        };

        /**
         * @method html
         *
         * get the HTML contents of node
         *
         * @param {jQuery} $node
         * @param {Boolean} [isNewlineOnBlock]
         */
        var html = function ($node, isNewlineOnBlock) {
            var markup = value($node);

            if (isNewlineOnBlock) {
                var regexTag = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
                markup = markup.replace(regexTag, function (match, endSlash, name) {
                    name = name.toUpperCase();
                    var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) && !!endSlash;
                    var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);

                    return match + (isEndOfInlineContainer || isBlockNode ? '\n' : '');
                });
                markup = $.trim(markup);
            }

            return markup;
        };

        var posFromPlaceholder = function (placeholder) {
            var $placeholder = $(placeholder);
            var pos = $placeholder.offset();
            var height = $placeholder.outerHeight(true); // include margin

            return {
                left: pos.left,
                top: pos.top + height
            };
        };

        var attachEvents = function ($node, events) {
            Object.keys(events).forEach(function (key) {
                $node.on(key, events[key]);
            });
        };

        var detachEvents = function ($node, events) {
            Object.keys(events).forEach(function (key) {
                $node.off(key, events[key]);
            });
        };

        return {
            /** @property {String} NBSP_CHAR */
            NBSP_CHAR: NBSP_CHAR,
            /** @property {String} ZERO_WIDTH_NBSP_CHAR */
            ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,
            /** @property {String} blank */
            blank: blankHTML,
            /** @property {String} emptyPara */
            emptyPara: '<p>' + blankHTML + '</p>',
            makePredByNodeName: makePredByNodeName,
            isEditable: isEditable,
            isControlSizing: isControlSizing,
            isText: isText,
            isElement: isElement,
            isVoid: isVoid,
            isPara: isPara,
            isPurePara: isPurePara,
            isHeading: isHeading,
            isInline: isInline,
            isBlock: func.not(isInline),
            isBodyInline: isBodyInline,
            isBody: isBody,
            isParaInline: isParaInline,
            isPre: isPre,
            isList: isList,
            isTable: isTable,
            isData: isData,
            isCell: isCell,
            isBlockquote: isBlockquote,
            isBodyContainer: isBodyContainer,
            isAnchor: isAnchor,
            isDiv: makePredByNodeName('DIV'),
            isLi: isLi,
            isBR: makePredByNodeName('BR'),
            isSpan: makePredByNodeName('SPAN'),
            isB: makePredByNodeName('B'),
            isU: makePredByNodeName('U'),
            isS: makePredByNodeName('S'),
            isI: makePredByNodeName('I'),
            isImg: makePredByNodeName('IMG'),
            isTextarea: isTextarea,
            isEmpty: isEmpty,
            isEmptyAnchor: func.and(isAnchor, isEmpty),
            isClosestSibling: isClosestSibling,
            withClosestSiblings: withClosestSiblings,
            nodeLength: nodeLength,
            isLeftEdgePoint: isLeftEdgePoint,
            isRightEdgePoint: isRightEdgePoint,
            isEdgePoint: isEdgePoint,
            isLeftEdgeOf: isLeftEdgeOf,
            isRightEdgeOf: isRightEdgeOf,
            isLeftEdgePointOf: isLeftEdgePointOf,
            isRightEdgePointOf: isRightEdgePointOf,
            prevPoint: prevPoint,
            nextPoint: nextPoint,
            isSamePoint: isSamePoint,
            isVisiblePoint: isVisiblePoint,
            prevPointUntil: prevPointUntil,
            nextPointUntil: nextPointUntil,
            isCharPoint: isCharPoint,
            walkPoint: walkPoint,
            ancestor: ancestor,
            singleChildAncestor: singleChildAncestor,
            listAncestor: listAncestor,
            lastAncestor: lastAncestor,
            listNext: listNext,
            listPrev: listPrev,
            listDescendant: listDescendant,
            commonAncestor: commonAncestor,
            wrap: wrap,
            insertAfter: insertAfter,
            appendChildNodes: appendChildNodes,
            position: position,
            hasChildren: hasChildren,
            makeOffsetPath: makeOffsetPath,
            fromOffsetPath: fromOffsetPath,
            splitTree: splitTree,
            splitPoint: splitPoint,
            create: create,
            createText: createText,
            remove: remove,
            removeWhile: removeWhile,
            replace: replace,
            html: html,
            value: value,
            posFromPlaceholder: posFromPlaceholder,
            attachEvents: attachEvents,
            detachEvents: detachEvents
        };
    }();

    /**
     * @param {jQuery} $note
     * @param {Object} options
     * @return {Context}
     */
    var Context = function ($note, options) {
        var self = this;

        var ui = $.summernote.ui;
        this.memos = {};
        this.modules = {};
        this.layoutInfo = {};
        this.options = options;

        /**
         * create layout and initialize modules and other resources
         */
        this.initialize = function () {
            this.layoutInfo = ui.createLayout($note, options);
            this._initialize();
            $note.hide();
            return this;
        };

        /**
         * destroy modules and other resources and remove layout
         */
        this.destroy = function () {
            this._destroy();
            $note.removeData('summernote');
            ui.removeLayout($note, this.layoutInfo);
        };

        /**
         * destory modules and other resources and initialize it again
         */
        this.reset = function () {
            var disabled = self.isDisabled();
            this.code(dom.emptyPara);
            this._destroy();
            this._initialize();

            if (disabled) {
                self.disable();
            }
        };

        this._initialize = function () {
            // add optional buttons
            var buttons = $.extend({}, this.options.buttons);
            Object.keys(buttons).forEach(function (key) {
                self.memo('button.' + key, buttons[key]);
            });

            var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});

            // add and initialize modules
            Object.keys(modules).forEach(function (key) {
                self.module(key, modules[key], true);
            });

            Object.keys(this.modules).forEach(function (key) {
                self.initializeModule(key);
            });
        };

        this._destroy = function () {
            // destroy modules with reversed order
            Object.keys(this.modules).reverse().forEach(function (key) {
                self.removeModule(key);
            });

            Object.keys(this.memos).forEach(function (key) {
                self.removeMemo(key);
            });
        };

        this.code = function (html) {
            var isActivated = this.invoke('codeview.isActivated');

            if (html === undefined) {
                this.invoke('codeview.sync');
                return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
            } else {
                if (isActivated) {
                    this.layoutInfo.codable.val(html);
                } else {
                    this.layoutInfo.editable.html(html);
                }
                $note.val(html);
                this.triggerEvent('change', html);
            }
        };

        this.isDisabled = function () {
            return this.layoutInfo.editable.attr('contenteditable') === 'false';
        };

        this.enable = function () {
            this.layoutInfo.editable.attr('contenteditable', true);
            this.invoke('toolbar.activate', true);
        };

        this.disable = function () {
            // close codeview if codeview is opend
            if (this.invoke('codeview.isActivated')) {
                this.invoke('codeview.deactivate');
            }
            this.layoutInfo.editable.attr('contenteditable', false);
            this.invoke('toolbar.deactivate', true);
        };

        this.triggerEvent = function () {
            var namespace = list.head(arguments);
            var args = list.tail(list.from(arguments));

            var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];
            if (callback) {
                callback.apply($note[0], args);
            }
            $note.trigger('summernote.' + namespace, args);
        };

        this.initializeModule = function (key) {
            var module = this.modules[key];
            module.shouldInitialize = module.shouldInitialize || func.ok;
            if (!module.shouldInitialize()) {
                return;
            }

            // initialize module
            if (module.initialize) {
                module.initialize();
            }

            // attach events
            if (module.events) {
                dom.attachEvents($note, module.events);
            }
        };

        this.module = function (key, ModuleClass, withoutIntialize) {
            if (arguments.length === 1) {
                return this.modules[key];
            }

            this.modules[key] = new ModuleClass(this);

            if (!withoutIntialize) {
                this.initializeModule(key);
            }
        };

        this.removeModule = function (key) {
            var module = this.modules[key];
            if (module.shouldInitialize()) {
                if (module.events) {
                    dom.detachEvents($note, module.events);
                }

                if (module.destroy) {
                    module.destroy();
                }
            }

            delete this.modules[key];
        };

        this.memo = function (key, obj) {
            if (arguments.length === 1) {
                return this.memos[key];
            }
            this.memos[key] = obj;
        };

        this.removeMemo = function (key) {
            if (this.memos[key] && this.memos[key].destroy) {
                this.memos[key].destroy();
            }

            delete this.memos[key];
        };

        this.createInvokeHandler = function (namespace, value) {
            return function (event) {
                event.preventDefault();
                self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));
            };
        };

        this.invoke = function () {
            var namespace = list.head(arguments);
            var args = list.tail(list.from(arguments));

            var splits = namespace.split('.');
            var hasSeparator = splits.length > 1;
            var moduleName = hasSeparator && list.head(splits);
            var methodName = hasSeparator ? list.last(splits) : list.head(splits);

            var module = this.modules[moduleName || 'editor'];
            if (!moduleName && this[methodName]) {
                return this[methodName].apply(this, args);
            } else if (module && module[methodName] && module.shouldInitialize()) {
                return module[methodName].apply(module, args);
            }
        };

        return this.initialize();
    };

    $.fn.extend({
        /**
         * Summernote API
         *
         * @param {Object|String}
         * @return {this}
         */
        summernote: function () {
            var type = $.type(list.head(arguments));
            var isExternalAPICalled = type === 'string';
            var hasInitOptions = type === 'object';

            var options = hasInitOptions ? list.head(arguments) : {};

            options = $.extend({}, $.summernote.options, options);
            options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);
            options.icons = $.extend(true, {}, $.summernote.options.icons, options.icons);

            this.each(function (idx, note) {
                var $note = $(note);
                if (!$note.data('summernote')) {
                    var context = new Context($note, options);
                    $note.data('summernote', context);
                    $note.data('summernote').triggerEvent('init', context.layoutInfo);
                }
            });

            var $note = this.first();
            if ($note.length) {
                var context = $note.data('summernote');
                if (isExternalAPICalled) {
                    return context.invoke.apply(context, list.from(arguments));
                } else if (options.focus) {
                    context.invoke('editor.focus');
                }
            }

            return this;
        }
    });

    var Renderer = function (markup, children, options, callback) {
        this.render = function ($parent) {
            var $node = $(markup);

            if (options && options.contents) {
                $node.html(options.contents);
            }

            if (options && options.className) {
                $node.addClass(options.className);
            }

            if (options && options.data) {
                $.each(options.data, function (k, v) {
                    $node.attr('data-' + k, v);
                });
            }

            if (options && options.click) {
                $node.on('click', options.click);
            }

            if (children) {
                var $container = $node.find('.note-children-container');
                children.forEach(function (child) {
                    child.render($container.length ? $container : $node);
                });
            }

            if (callback) {
                callback($node, options);
            }

            if (options && options.callback) {
                options.callback($node);
            }

            if ($parent) {
                $parent.append($node);
            }

            return $node;
        };
    };

    var renderer = {
        create: function (markup, callback) {
            return function () {
                var children = $.isArray(arguments[0]) ? arguments[0] : [];
                var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];
                if (options && options.children) {
                    children = options.children;
                }
                return new Renderer(markup, children, options, callback);
            };
        }
    };

    var editor = renderer.create('<div class="note-editor note-frame panel panel-default"/>');
    var toolbar = renderer.create('<div class="note-toolbar panel-heading"/>');
    var editingArea = renderer.create('<div class="note-editing-area"/>');
    var codable = renderer.create('<textarea class="note-codable"/>');
    var editable = renderer.create('<div class="note-editable panel-body form-control" contentEditable="true"/>');
    var statusbar = renderer.create(['<div class="note-statusbar">', '  <div class="note-resizebar">', '    <div class="note-icon-bar"/>', '    <div class="note-icon-bar"/>', '    <div class="note-icon-bar"/>', '  </div>', '</div>'].join(''));

    var airEditor = renderer.create('<div class="note-editor"/>');
    var airEditable = renderer.create('<div class="note-editable" contentEditable="true"/>');

    var buttonGroup = renderer.create('<div class="note-btn-group btn-group">');
    var button = renderer.create('<button type="button" class="note-btn btn btn-default btn-sm" tabindex="-1">', function ($node, options) {
        if (options && options.tooltip) {
            $node.attr({
                title: options.tooltip
            }).tooltip({
                container: 'body',
                trigger: 'hover',
                placement: 'bottom'
            });
        }
    });

    var dropdown = renderer.create('<div class="dropdown-menu">', function ($node, options) {
        var markup = $.isArray(options.items) ? options.items.map(function (item) {
            var value = typeof item === 'string' ? item : item.value || '';
            var content = options.template ? options.template(item) : item;
            return '<li class="dropdown-item"><a href="#" data-value="' + value + '">' + content + '</a></li>';
        }).join('') : options.items;

        $node.html(markup);
    });

    var dropdownCheck = renderer.create('<div class="dropdown-menu note-check">', function ($node, options) {
        var markup = $.isArray(options.items) ? options.items.map(function (item) {
            var value = typeof item === 'string' ? item : item.value || '';
            var content = options.template ? options.template(item) : item;
            return '<li class="dropdown-item"><a href="#" data-value="' + value + '">' + icon(options.checkClassName) + ' ' + content + '</a></li>';
        }).join('') : options.items;
        $node.html(markup);
    });

    var palette = renderer.create('<div class="note-color-palette"/>', function ($node, options) {
        var contents = [];
        for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {
            var eventName = options.eventName;
            var colors = options.colors[row];
            var buttons = [];
            for (var col = 0, colSize = colors.length; col < colSize; col++) {
                var color = colors[col];
                buttons.push(['<button type="button" class="note-color-btn"', 'style="background-color:', color, '" ', 'data-event="', eventName, '" ', 'data-value="', color, '" ', 'title="', color, '" ', 'data-toggle="button" tabindex="-1"></button>'].join(''));
            }
            contents.push('<div class="note-color-row">' + buttons.join('') + '</div>');
        }
        $node.html(contents.join(''));

        $node.find('.note-color-btn').tooltip({
            container: 'body',
            trigger: 'hover',
            placement: 'bottom'
        });
    });

    var dialog = renderer.create('<div class="modal" aria-hidden="false" tabindex="-1"/>', function ($node, options) {
        if (options.fade) {
            $node.addClass('fade');
        }
        $node.html(['<div class="modal-dialog">', '  <div class="modal-content">', options.title ? '    <div class="modal-header">' + '      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>' + '      <h4 class="modal-title">' + options.title + '</h4>' + '    </div>' : '', '    <div class="modal-body">' + options.body + '</div>', options.footer ? '    <div class="modal-footer">' + options.footer + '</div>' : '', '  </div>', '</div>'].join(''));
    });

    var popover = renderer.create(['<div class="note-popover popover in">', '  <div class="arrow"/>', '  <div class="popover-content note-children-container"/>', '</div>'].join(''), function ($node, options) {
        var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';

        $node.addClass(direction);
        $node.hide();
        if (options.hideArrow) {
            $node.find('.arrow').hide();
        }
    });

    var icon = function (iconClassName, tagName) {
        tagName = tagName || 'i';
        return '<' + tagName + ' class="' + iconClassName + '"/>';
    };

    var ui = {
        editor: editor,
        toolbar: toolbar,
        editingArea: editingArea,
        codable: codable,
        editable: editable,
        statusbar: statusbar,
        airEditor: airEditor,
        airEditable: airEditable,
        buttonGroup: buttonGroup,
        button: button,
        dropdown: dropdown,
        dropdownCheck: dropdownCheck,
        palette: palette,
        dialog: dialog,
        popover: popover,
        icon: icon,

        toggleBtn: function ($btn, isEnable) {
            $btn.toggleClass('disabled', !isEnable);
            $btn.attr('disabled', !isEnable);
        },

        toggleBtnActive: function ($btn, isActive) {
            $btn.toggleClass('active', isActive);
        },

        onDialogShown: function ($dialog, handler) {
            $dialog.one('shown.bs.modal', handler);
        },

        onDialogHidden: function ($dialog, handler) {
            $dialog.one('hidden.bs.modal', handler);
        },

        showDialog: function ($dialog) {
            $dialog.modal('show');
        },

        hideDialog: function ($dialog) {
            $dialog.modal('hide');
        },

        createLayout: function ($note, options) {
            var $editor = (options.airMode ? ui.airEditor([ui.editingArea([ui.airEditable()])]) : ui.editor([ui.toolbar(), ui.editingArea([ui.codable(), ui.editable()]), ui.statusbar()])).render();

            $editor.insertAfter($note);

            return {
                note: $note,
                editor: $editor,
                toolbar: $editor.find('.note-toolbar'),
                editingArea: $editor.find('.note-editing-area'),
                editable: $editor.find('.note-editable'),
                codable: $editor.find('.note-codable'),
                statusbar: $editor.find('.note-statusbar')
            };
        },

        removeLayout: function ($note, layoutInfo) {
            $note.html(layoutInfo.editable.html());
            layoutInfo.editor.remove();
            $note.show();
        }
    };

    $.summernote = $.summernote || {
        lang: {}
    };

    $.extend($.summernote.lang, {
        'en-US': {
            font: {
                bold: 'Bold',
                italic: 'Italic',
                underline: 'Underline',
                clear: 'Remove Font Style',
                height: 'Line Height',
                name: 'Font Family',
                strikethrough: 'Strikethrough',
                subscript: 'Subscript',
                superscript: 'Superscript',
                size: 'Font Size'
            },
            image: {
                image: 'Picture',
                insert: 'Insert Image',
                resizeFull: 'Resize Full',
                resizeHalf: 'Resize Half',
                resizeQuarter: 'Resize Quarter',
                floatLeft: 'Float Left',
                floatRight: 'Float Right',
                floatNone: 'Float None',
                shapeRounded: 'Shape: Rounded',
                shapeCircle: 'Shape: Circle',
                shapeThumbnail: 'Shape: Thumbnail',
                shapeNone: 'Shape: None',
                dragImageHere: 'Drag image or text here',
                dropImage: 'Drop image or Text',
                selectFromFiles: 'Select from files',
                maximumFileSize: 'Maximum file size',
                maximumFileSizeError: 'Maximum file size exceeded.',
                url: 'Image URL',
                remove: 'Remove Image'
            },
            video: {
                video: 'Video',
                videoLink: 'Video Link',
                insert: 'Insert Video',
                url: 'Video URL?',
                providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'
            },
            link: {
                link: 'Link',
                insert: 'Insert Link',
                unlink: 'Unlink',
                edit: 'Edit',
                textToDisplay: 'Text to display',
                url: 'To what URL should this link go?',
                openInNewWindow: 'Open in new window'
            },
            table: {
                table: 'Table'
            },
            hr: {
                insert: 'Insert Horizontal Rule'
            },
            style: {
                style: 'Style',
                normal: 'Normal',
                blockquote: 'Quote',
                pre: 'Code',
                h1: 'Header 1',
                h2: 'Header 2',
                h3: 'Header 3',
                h4: 'Header 4',
                h5: 'Header 5',
                h6: 'Header 6'
            },
            lists: {
                unordered: 'Unordered list',
                ordered: 'Ordered list'
            },
            options: {
                help: 'Help',
                fullscreen: 'Full Screen',
                codeview: 'Code View'
            },
            paragraph: {
                paragraph: 'Paragraph',
                outdent: 'Outdent',
                indent: 'Indent',
                left: 'Align left',
                center: 'Align center',
                right: 'Align right',
                justify: 'Justify full'
            },
            color: {
                recent: 'Recent Color',
                more: 'More Color',
                background: 'Background Color',
                foreground: 'Foreground Color',
                transparent: 'Transparent',
                setTransparent: 'Set transparent',
                reset: 'Reset',
                resetToDefault: 'Reset to default'
            },
            shortcut: {
                shortcuts: 'Keyboard shortcuts',
                close: 'Close',
                textFormatting: 'Text formatting',
                action: 'Action',
                paragraphFormatting: 'Paragraph formatting',
                documentStyle: 'Document Style',
                extraKeys: 'Extra keys'
            },
            help: {
                'insertParagraph': 'Insert Paragraph',
                'undo': 'Undoes the last command',
                'redo': 'Redoes the last command',
                'tab': 'Tab',
                'untab': 'Untab',
                'bold': 'Set a bold style',
                'italic': 'Set a italic style',
                'underline': 'Set a underline style',
                'strikethrough': 'Set a strikethrough style',
                'removeFormat': 'Clean a style',
                'justifyLeft': 'Set left align',
                'justifyCenter': 'Set center align',
                'justifyRight': 'Set right align',
                'justifyFull': 'Set full align',
                'insertUnorderedList': 'Toggle unordered list',
                'insertOrderedList': 'Toggle ordered list',
                'outdent': 'Outdent on current paragraph',
                'indent': 'Indent on current paragraph',
                'formatPara': 'Change current block\'s format as a paragraph(P tag)',
                'formatH1': 'Change current block\'s format as H1',
                'formatH2': 'Change current block\'s format as H2',
                'formatH3': 'Change current block\'s format as H3',
                'formatH4': 'Change current block\'s format as H4',
                'formatH5': 'Change current block\'s format as H5',
                'formatH6': 'Change current block\'s format as H6',
                'insertHorizontalRule': 'Insert horizontal rule',
                'linkDialog.show': 'Show Link Dialog'
            },
            history: {
                undo: 'Undo',
                redo: 'Redo'
            },
            specialChar: {
                specialChar: 'SPECIAL CHARACTERS',
                select: 'Select Special characters'
            }
        }
    });

    /**
     * @class core.key
     *
     * Object for keycodes.
     *
     * @singleton
     * @alternateClassName key
     */
    var key = function () {
        var keyMap = {
            'BACKSPACE': 8,
            'TAB': 9,
            'ENTER': 13,
            'SPACE': 32,

            // Arrow
            'LEFT': 37,
            'UP': 38,
            'RIGHT': 39,
            'DOWN': 40,

            // Number: 0-9
            'NUM0': 48,
            'NUM1': 49,
            'NUM2': 50,
            'NUM3': 51,
            'NUM4': 52,
            'NUM5': 53,
            'NUM6': 54,
            'NUM7': 55,
            'NUM8': 56,

            // Alphabet: a-z
            'B': 66,
            'E': 69,
            'I': 73,
            'J': 74,
            'K': 75,
            'L': 76,
            'R': 82,
            'S': 83,
            'U': 85,
            'V': 86,
            'Y': 89,
            'Z': 90,

            'SLASH': 191,
            'LEFTBRACKET': 219,
            'BACKSLASH': 220,
            'RIGHTBRACKET': 221
        };

        return {
            /**
             * @method isEdit
             *
             * @param {Number} keyCode
             * @return {Boolean}
             */
            isEdit: function (keyCode) {
                return list.contains([keyMap.BACKSPACE, keyMap.TAB, keyMap.ENTER, keyMap.SPACE], keyCode);
            },
            /**
             * @method isMove
             *
             * @param {Number} keyCode
             * @return {Boolean}
             */
            isMove: function (keyCode) {
                return list.contains([keyMap.LEFT, keyMap.UP, keyMap.RIGHT, keyMap.DOWN], keyCode);
            },
            /**
             * @property {Object} nameFromCode
             * @property {String} nameFromCode.8 "BACKSPACE"
             */
            nameFromCode: func.invertObject(keyMap),
            code: keyMap
        };
    }();

    var range = function () {

        /**
         * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js
         *
         * @param {TextRange} textRange
         * @param {Boolean} isStart
         * @return {BoundaryPoint}
         *
         * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx
         */
        var textRangeToPoint = function (textRange, isStart) {
            var container = textRange.parentElement(),
                offset;

            var tester = document.body.createTextRange(),
                prevContainer;
            var childNodes = list.from(container.childNodes);
            for (offset = 0; offset < childNodes.length; offset++) {
                if (dom.isText(childNodes[offset])) {
                    continue;
                }
                tester.moveToElementText(childNodes[offset]);
                if (tester.compareEndPoints('StartToStart', textRange) >= 0) {
                    break;
                }
                prevContainer = childNodes[offset];
            }

            if (offset !== 0 && dom.isText(childNodes[offset - 1])) {
                var textRangeStart = document.body.createTextRange(),
                    curTextNode = null;
                textRangeStart.moveToElementText(prevContainer || container);
                textRangeStart.collapse(!prevContainer);
                curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;

                var pointTester = textRange.duplicate();
                pointTester.setEndPoint('StartToStart', textRangeStart);
                var textCount = pointTester.text.replace(/[\r\n]/g, '').length;

                while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {
                    textCount -= curTextNode.nodeValue.length;
                    curTextNode = curTextNode.nextSibling;
                }

                /* jshint ignore:start */
                var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack
                /* jshint ignore:end */

                if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) && textCount === curTextNode.nodeValue.length) {
                    textCount -= curTextNode.nodeValue.length;
                    curTextNode = curTextNode.nextSibling;
                }

                container = curTextNode;
                offset = textCount;
            }

            return {
                cont: container,
                offset: offset
            };
        };

        /**
         * return TextRange from boundary point (inspired by google closure-library)
         * @param {BoundaryPoint} point
         * @return {TextRange}
         */
        var pointToTextRange = function (point) {
            var textRangeInfo = function (container, offset) {
                var node, isCollapseToStart;

                if (dom.isText(container)) {
                    var prevTextNodes = dom.listPrev(container, func.not(dom.isText));
                    var prevContainer = list.last(prevTextNodes).previousSibling;
                    node = prevContainer || container.parentNode;
                    offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);
                    isCollapseToStart = !prevContainer;
                } else {
                    node = container.childNodes[offset] || container;
                    if (dom.isText(node)) {
                        return textRangeInfo(node, 0);
                    }

                    offset = 0;
                    isCollapseToStart = false;
                }

                return {
                    node: node,
                    collapseToStart: isCollapseToStart,
                    offset: offset
                };
            };

            var textRange = document.body.createTextRange();
            var info = textRangeInfo(point.node, point.offset);

            textRange.moveToElementText(info.node);
            textRange.collapse(info.collapseToStart);
            textRange.moveStart('character', info.offset);
            return textRange;
        };

        /**
         * Wrapped Range
         *
         * @constructor
         * @param {Node} sc - start container
         * @param {Number} so - start offset
         * @param {Node} ec - end container
         * @param {Number} eo - end offset
         */
        var WrappedRange = function (sc, so, ec, eo) {
            this.sc = sc;
            this.so = so;
            this.ec = ec;
            this.eo = eo;

            // nativeRange: get nativeRange from sc, so, ec, eo
            var nativeRange = function () {
                if (agent.isW3CRangeSupport) {
                    var w3cRange = document.createRange();
                    w3cRange.setStart(sc, so);
                    w3cRange.setEnd(ec, eo);

                    return w3cRange;
                } else {
                    var textRange = pointToTextRange({
                        node: sc,
                        offset: so
                    });

                    textRange.setEndPoint('EndToEnd', pointToTextRange({
                        node: ec,
                        offset: eo
                    }));

                    return textRange;
                }
            };

            this.getPoints = function () {
                return {
                    sc: sc,
                    so: so,
                    ec: ec,
                    eo: eo
                };
            };

            this.getStartPoint = function () {
                return {
                    node: sc,
                    offset: so
                };
            };

            this.getEndPoint = function () {
                return {
                    node: ec,
                    offset: eo
                };
            };

            /**
             * select update visible range
             */
            this.select = function () {
                var nativeRng = nativeRange();
                if (agent.isW3CRangeSupport) {
                    var selection = document.getSelection();
                    if (selection.rangeCount > 0) {
                        selection.removeAllRanges();
                    }
                    selection.addRange(nativeRng);
                } else {
                    nativeRng.select();
                }

                return this;
            };

            /**
             * Moves the scrollbar to start container(sc) of current range
             *
             * @return {WrappedRange}
             */
            this.scrollIntoView = function (container) {
                var height = $(container).height();
                if (container.scrollTop + height < this.sc.offsetTop) {
                    container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);
                }

                return this;
            };

            /**
             * @return {WrappedRange}
             */
            this.normalize = function () {

                /**
                 * @param {BoundaryPoint} point
                 * @param {Boolean} isLeftToRight
                 * @return {BoundaryPoint}
                 */
                var getVisiblePoint = function (point, isLeftToRight) {
                    if (dom.isVisiblePoint(point) && !dom.isEdgePoint(point) || dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight || dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight || dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node)) {
                        return point;
                    }

                    // point on block's edge
                    var block = dom.ancestor(point.node, dom.isBlock);
                    if ((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight || (dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight) {

                        // returns point already on visible point
                        if (dom.isVisiblePoint(point)) {
                            return point;
                        }
                        // reverse direction
                        isLeftToRight = !isLeftToRight;
                    }

                    var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) : dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);
                    return nextPoint || point;
                };

                var endPoint = getVisiblePoint(this.getEndPoint(), false);
                var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);

                return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            };

            /**
             * returns matched nodes on range
             *
             * @param {Function} [pred] - predicate function
             * @param {Object} [options]
             * @param {Boolean} [options.includeAncestor]
             * @param {Boolean} [options.fullyContains]
             * @return {Node[]}
             */
            this.nodes = function (pred, options) {
                pred = pred || func.ok;

                var includeAncestor = options && options.includeAncestor;
                var fullyContains = options && options.fullyContains;

                // TODO compare points and sort
                var startPoint = this.getStartPoint();
                var endPoint = this.getEndPoint();

                var nodes = [];
                var leftEdgeNodes = [];

                dom.walkPoint(startPoint, endPoint, function (point) {
                    if (dom.isEditable(point.node)) {
                        return;
                    }

                    var node;
                    if (fullyContains) {
                        if (dom.isLeftEdgePoint(point)) {
                            leftEdgeNodes.push(point.node);
                        }
                        if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {
                            node = point.node;
                        }
                    } else if (includeAncestor) {
                        node = dom.ancestor(point.node, pred);
                    } else {
                        node = point.node;
                    }

                    if (node && pred(node)) {
                        nodes.push(node);
                    }
                }, true);

                return list.unique(nodes);
            };

            /**
             * returns commonAncestor of range
             * @return {Element} - commonAncestor
             */
            this.commonAncestor = function () {
                return dom.commonAncestor(sc, ec);
            };

            /**
             * returns expanded range by pred
             *
             * @param {Function} pred - predicate function
             * @return {WrappedRange}
             */
            this.expand = function (pred) {
                var startAncestor = dom.ancestor(sc, pred);
                var endAncestor = dom.ancestor(ec, pred);

                if (!startAncestor && !endAncestor) {
                    return new WrappedRange(sc, so, ec, eo);
                }

                var boundaryPoints = this.getPoints();

                if (startAncestor) {
                    boundaryPoints.sc = startAncestor;
                    boundaryPoints.so = 0;
                }

                if (endAncestor) {
                    boundaryPoints.ec = endAncestor;
                    boundaryPoints.eo = dom.nodeLength(endAncestor);
                }

                return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
            };

            /**
             * @param {Boolean} isCollapseToStart
             * @return {WrappedRange}
             */
            this.collapse = function (isCollapseToStart) {
                if (isCollapseToStart) {
                    return new WrappedRange(sc, so, sc, so);
                } else {
                    return new WrappedRange(ec, eo, ec, eo);
                }
            };

            /**
             * splitText on range
             */
            this.splitText = function () {
                var isSameContainer = sc === ec;
                var boundaryPoints = this.getPoints();

                if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {
                    ec.splitText(eo);
                }

                if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {
                    boundaryPoints.sc = sc.splitText(so);
                    boundaryPoints.so = 0;

                    if (isSameContainer) {
                        boundaryPoints.ec = boundaryPoints.sc;
                        boundaryPoints.eo = eo - so;
                    }
                }

                return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
            };

            /**
             * delete contents on range
             * @return {WrappedRange}
             */
            this.deleteContents = function () {
                if (this.isCollapsed()) {
                    return this;
                }

                var rng = this.splitText();
                var nodes = rng.nodes(null, {
                    fullyContains: true
                });

                // find new cursor point
                var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {
                    return !list.contains(nodes, point.node);
                });

                var emptyParents = [];
                $.each(nodes, function (idx, node) {
                    // find empty parents
                    var parent = node.parentNode;
                    if (point.node !== parent && dom.nodeLength(parent) === 1) {
                        emptyParents.push(parent);
                    }
                    dom.remove(node, false);
                });

                // remove empty parents
                $.each(emptyParents, function (idx, node) {
                    dom.remove(node, false);
                });

                return new WrappedRange(point.node, point.offset, point.node, point.offset).normalize();
            };

            /**
             * makeIsOn: return isOn(pred) function
             */
            var makeIsOn = function (pred) {
                return function () {
                    var ancestor = dom.ancestor(sc, pred);
                    return !!ancestor && ancestor === dom.ancestor(ec, pred);
                };
            };

            // isOnEditable: judge whether range is on editable or not
            this.isOnEditable = makeIsOn(dom.isEditable);
            // isOnList: judge whether range is on list node or not
            this.isOnList = makeIsOn(dom.isList);
            // isOnAnchor: judge whether range is on anchor node or not
            this.isOnAnchor = makeIsOn(dom.isAnchor);
            // isOnCell: judge whether range is on cell node or not
            this.isOnCell = makeIsOn(dom.isCell);
            // isOnData: judge whether range is on data node or not
            this.isOnData = makeIsOn(dom.isData);

            /**
             * @param {Function} pred
             * @return {Boolean}
             */
            this.isLeftEdgeOf = function (pred) {
                if (!dom.isLeftEdgePoint(this.getStartPoint())) {
                    return false;
                }

                var node = dom.ancestor(this.sc, pred);
                return node && dom.isLeftEdgeOf(this.sc, node);
            };

            /**
             * returns whether range was collapsed or not
             */
            this.isCollapsed = function () {
                return sc === ec && so === eo;
            };

            /**
             * wrap inline nodes which children of body with paragraph
             *
             * @return {WrappedRange}
             */
            this.wrapBodyInlineWithPara = function () {
                if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {
                    sc.innerHTML = dom.emptyPara;
                    return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);
                }

                /**
                 * [workaround] firefox often create range on not visible point. so normalize here.
                 *  - firefox: |<p>text</p>|
                 *  - chrome: <p>|text|</p>
                 */
                var rng = this.normalize();
                if (dom.isParaInline(sc) || dom.isPara(sc)) {
                    return rng;
                }

                // find inline top ancestor
                var topAncestor;
                if (dom.isInline(rng.sc)) {
                    var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));
                    topAncestor = list.last(ancestors);
                    if (!dom.isInline(topAncestor)) {
                        topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];
                    }
                } else {
                    topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];
                }

                // siblings not in paragraph
                var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();
                inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));

                // wrap with paragraph
                if (inlineSiblings.length) {
                    var para = dom.wrap(list.head(inlineSiblings), 'p');
                    dom.appendChildNodes(para, list.tail(inlineSiblings));
                }

                return this.normalize();
            };

            /**
             * insert node at current cursor
             *
             * @param {Node} node
             * @return {Node}
             */
            this.insertNode = function (node) {
                var rng = this.wrapBodyInlineWithPara().deleteContents();
                var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));

                if (info.rightNode) {
                    info.rightNode.parentNode.insertBefore(node, info.rightNode);
                } else {
                    info.container.appendChild(node);
                }

                return node;
            };

            /**
             * insert html at current cursor
             */
            this.pasteHTML = function (markup) {
                var contentsContainer = $('<div></div>').html(markup)[0];
                var childNodes = list.from(contentsContainer.childNodes);

                var rng = this.wrapBodyInlineWithPara().deleteContents();

                return childNodes.reverse().map(function (childNode) {
                    return rng.insertNode(childNode);
                }).reverse();
            };

            /**
             * returns text in range
             *
             * @return {String}
             */
            this.toString = function () {
                var nativeRng = nativeRange();
                return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;
            };

            /**
             * returns range for word before cursor
             *
             * @param {Boolean} [findAfter] - find after cursor, default: false
             * @return {WrappedRange}
             */
            this.getWordRange = function (findAfter) {
                var endPoint = this.getEndPoint();

                if (!dom.isCharPoint(endPoint)) {
                    return this;
                }

                var startPoint = dom.prevPointUntil(endPoint, function (point) {
                    return !dom.isCharPoint(point);
                });

                if (findAfter) {
                    endPoint = dom.nextPointUntil(endPoint, function (point) {
                        return !dom.isCharPoint(point);
                    });
                }

                return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            };

            /**
             * create offsetPath bookmark
             *
             * @param {Node} editable
             */
            this.bookmark = function (editable) {
                return {
                    s: {
                        path: dom.makeOffsetPath(editable, sc),
                        offset: so
                    },
                    e: {
                        path: dom.makeOffsetPath(editable, ec),
                        offset: eo
                    }
                };
            };

            /**
             * create offsetPath bookmark base on paragraph
             *
             * @param {Node[]} paras
             */
            this.paraBookmark = function (paras) {
                return {
                    s: {
                        path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),
                        offset: so
                    },
                    e: {
                        path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),
                        offset: eo
                    }
                };
            };

            /**
             * getClientRects
             * @return {Rect[]}
             */
            this.getClientRects = function () {
                var nativeRng = nativeRange();
                return nativeRng.getClientRects();
            };
        };

        /**
         * @class core.range
         *
         * Data structure
         *  * BoundaryPoint: a point of dom tree
         *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range
         *
         * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position
         *
         * @singleton
         * @alternateClassName range
         */
        return {
            /**
             * create Range Object From arguments or Browser Selection
             *
             * @param {Node} sc - start container
             * @param {Number} so - start offset
             * @param {Node} ec - end container
             * @param {Number} eo - end offset
             * @return {WrappedRange}
             */
            create: function (sc, so, ec, eo) {
                if (arguments.length === 4) {
                    return new WrappedRange(sc, so, ec, eo);
                } else if (arguments.length === 2) {
                    //collapsed
                    ec = sc;
                    eo = so;
                    return new WrappedRange(sc, so, ec, eo);
                } else {
                    var wrappedRange = this.createFromSelection();
                    if (!wrappedRange && arguments.length === 1) {
                        wrappedRange = this.createFromNode(arguments[0]);
                        return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);
                    }
                    return wrappedRange;
                }
            },

            createFromSelection: function () {
                var sc, so, ec, eo;
                if (agent.isW3CRangeSupport) {
                    var selection = document.getSelection();
                    if (!selection || selection.rangeCount === 0) {
                        return null;
                    } else if (dom.isBody(selection.anchorNode)) {
                        // Firefox: returns entire body as range on initialization.
                        // We won't never need it.
                        return null;
                    }

                    var nativeRng = selection.getRangeAt(0);
                    sc = nativeRng.startContainer;
                    so = nativeRng.startOffset;
                    ec = nativeRng.endContainer;
                    eo = nativeRng.endOffset;
                } else {
                    // IE8: TextRange
                    var textRange = document.selection.createRange();
                    var textRangeEnd = textRange.duplicate();
                    textRangeEnd.collapse(false);
                    var textRangeStart = textRange;
                    textRangeStart.collapse(true);

                    var startPoint = textRangeToPoint(textRangeStart, true),
                        endPoint = textRangeToPoint(textRangeEnd, false);

                    // same visible point case: range was collapsed.
                    if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) && dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) && endPoint.node.nextSibling === startPoint.node) {
                        startPoint = endPoint;
                    }

                    sc = startPoint.cont;
                    so = startPoint.offset;
                    ec = endPoint.cont;
                    eo = endPoint.offset;
                }

                return new WrappedRange(sc, so, ec, eo);
            },

            /**
             * @method
             *
             * create WrappedRange from node
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNode: function (node) {
                var sc = node;
                var so = 0;
                var ec = node;
                var eo = dom.nodeLength(ec);

                // browsers can't target a picture or void node
                if (dom.isVoid(sc)) {
                    so = dom.listPrev(sc).length - 1;
                    sc = sc.parentNode;
                }
                if (dom.isBR(ec)) {
                    eo = dom.listPrev(ec).length - 1;
                    ec = ec.parentNode;
                } else if (dom.isVoid(ec)) {
                    eo = dom.listPrev(ec).length;
                    ec = ec.parentNode;
                }

                return this.create(sc, so, ec, eo);
            },

            /**
             * create WrappedRange from node after position
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNodeBefore: function (node) {
                return this.createFromNode(node).collapse(true);
            },

            /**
             * create WrappedRange from node after position
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNodeAfter: function (node) {
                return this.createFromNode(node).collapse();
            },

            /**
             * @method
             *
             * create WrappedRange from bookmark
             *
             * @param {Node} editable
             * @param {Object} bookmark
             * @return {WrappedRange}
             */
            createFromBookmark: function (editable, bookmark) {
                var sc = dom.fromOffsetPath(editable, bookmark.s.path);
                var so = bookmark.s.offset;
                var ec = dom.fromOffsetPath(editable, bookmark.e.path);
                var eo = bookmark.e.offset;
                return new WrappedRange(sc, so, ec, eo);
            },

            /**
             * @method
             *
             * create WrappedRange from paraBookmark
             *
             * @param {Object} bookmark
             * @param {Node[]} paras
             * @return {WrappedRange}
             */
            createFromParaBookmark: function (bookmark, paras) {
                var so = bookmark.s.offset;
                var eo = bookmark.e.offset;
                var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);
                var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);

                return new WrappedRange(sc, so, ec, eo);
            }
        };
    }();

    /**
     * @class core.async
     *
     * Async functions which returns `Promise`
     *
     * @singleton
     * @alternateClassName async
     */
    var async = function () {
        /**
         * @method readFileAsDataURL
         *
         * read contents of file as representing URL
         *
         * @param {File} file
         * @return {Promise} - then: dataUrl
         */
        var readFileAsDataURL = function (file) {
            return $.Deferred(function (deferred) {
                $.extend(new FileReader(), {
                    onload: function (e) {
                        var dataURL = e.target.result;
                        deferred.resolve(dataURL);
                    },
                    onerror: function () {
                        deferred.reject(this);
                    }
                }).readAsDataURL(file);
            }).promise();
        };

        /**
         * @method createImage
         *
         * create `<image>` from url string
         *
         * @param {String} url
         * @return {Promise} - then: $image
         */
        var createImage = function (url) {
            return $.Deferred(function (deferred) {
                var $img = $('<img>');

                $img.one('load', function () {
                    $img.off('error abort');
                    deferred.resolve($img);
                }).one('error abort', function () {
                    $img.off('load').detach();
                    deferred.reject($img);
                }).css({
                    display: 'none'
                }).appendTo(document.body).attr('src', url);
            }).promise();
        };

        return {
            readFileAsDataURL: readFileAsDataURL,
            createImage: createImage
        };
    }();

    /**
     * @class editing.History
     *
     * Editor History
     *
     */
    var History = function ($editable) {
        var stack = [],
            stackOffset = -1;
        var editable = $editable[0];

        var makeSnapshot = function () {
            var rng = range.create(editable);
            var emptyBookmark = { s: { path: [], offset: 0 }, e: { path: [], offset: 0 } };

            return {
                contents: $editable.html(),
                bookmark: rng ? rng.bookmark(editable) : emptyBookmark
            };
        };

        var applySnapshot = function (snapshot) {
            if (snapshot.contents !== null) {
                $editable.html(snapshot.contents);
            }
            if (snapshot.bookmark !== null) {
                range.createFromBookmark(editable, snapshot.bookmark).select();
            }
        };

        /**
         * @method rewind
         * Rewinds the history stack back to the first snapshot taken.
         * Leaves the stack intact, so that "Redo" can still be used.
         */
        this.rewind = function () {
            // Create snap shot if not yet recorded
            if ($editable.html() !== stack[stackOffset].contents) {
                this.recordUndo();
            }

            // Return to the first available snapshot.
            stackOffset = 0;

            // Apply that snapshot.
            applySnapshot(stack[stackOffset]);
        };

        /**
         * @method reset
         * Resets the history stack completely; reverting to an empty editor.
         */
        this.reset = function () {
            // Clear the stack.
            stack = [];

            // Restore stackOffset to its original value.
            stackOffset = -1;

            // Clear the editable area.
            $editable.html('');

            // Record our first snapshot (of nothing).
            this.recordUndo();
        };

        /**
         * undo
         */
        this.undo = function () {
            // Create snap shot if not yet recorded
            if ($editable.html() !== stack[stackOffset].contents) {
                this.recordUndo();
            }

            if (0 < stackOffset) {
                stackOffset--;
                applySnapshot(stack[stackOffset]);
            }
        };

        /**
         * redo
         */
        this.redo = function () {
            if (stack.length - 1 > stackOffset) {
                stackOffset++;
                applySnapshot(stack[stackOffset]);
            }
        };

        /**
         * recorded undo
         */
        this.recordUndo = function () {
            stackOffset++;

            // Wash out stack after stackOffset
            if (stack.length > stackOffset) {
                stack = stack.slice(0, stackOffset);
            }

            // Create new snapshot and push it to the end
            stack.push(makeSnapshot());
        };
    };

    /**
     * @class editing.Style
     *
     * Style
     *
     */
    var Style = function () {
        /**
         * @method jQueryCSS
         *
         * [workaround] for old jQuery
         * passing an array of style properties to .css()
         * will result in an object of property-value pairs.
         * (compability with version < 1.9)
         *
         * @private
         * @param  {jQuery} $obj
         * @param  {Array} propertyNames - An array of one or more CSS properties.
         * @return {Object}
         */
        var jQueryCSS = function ($obj, propertyNames) {
            if (agent.jqueryVersion < 1.9) {
                var result = {};
                $.each(propertyNames, function (idx, propertyName) {
                    result[propertyName] = $obj.css(propertyName);
                });
                return result;
            }
            return $obj.css.call($obj, propertyNames);
        };

        /**
         * returns style object from node
         *
         * @param {jQuery} $node
         * @return {Object}
         */
        this.fromNode = function ($node) {
            var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];
            var styleInfo = jQueryCSS($node, properties) || {};
            styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);
            return styleInfo;
        };

        /**
         * paragraph level style
         *
         * @param {WrappedRange} rng
         * @param {Object} styleInfo
         */
        this.stylePara = function (rng, styleInfo) {
            $.each(rng.nodes(dom.isPara, {
                includeAncestor: true
            }), function (idx, para) {
                $(para).css(styleInfo);
            });
        };

        /**
         * insert and returns styleNodes on range.
         *
         * @param {WrappedRange} rng
         * @param {Object} [options] - options for styleNodes
         * @param {String} [options.nodeName] - default: `SPAN`
         * @param {Boolean} [options.expandClosestSibling] - default: `false`
         * @param {Boolean} [options.onlyPartialContains] - default: `false`
         * @return {Node[]}
         */
        this.styleNodes = function (rng, options) {
            rng = rng.splitText();

            var nodeName = options && options.nodeName || 'SPAN';
            var expandClosestSibling = !!(options && options.expandClosestSibling);
            var onlyPartialContains = !!(options && options.onlyPartialContains);

            if (rng.isCollapsed()) {
                return [rng.insertNode(dom.create(nodeName))];
            }

            var pred = dom.makePredByNodeName(nodeName);
            var nodes = rng.nodes(dom.isText, {
                fullyContains: true
            }).map(function (text) {
                return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);
            });

            if (expandClosestSibling) {
                if (onlyPartialContains) {
                    var nodesInRange = rng.nodes();
                    // compose with partial contains predication
                    pred = func.and(pred, function (node) {
                        return list.contains(nodesInRange, node);
                    });
                }

                return nodes.map(function (node) {
                    var siblings = dom.withClosestSiblings(node, pred);
                    var head = list.head(siblings);
                    var tails = list.tail(siblings);
                    $.each(tails, function (idx, elem) {
                        dom.appendChildNodes(head, elem.childNodes);
                        dom.remove(elem);
                    });
                    return list.head(siblings);
                });
            } else {
                return nodes;
            }
        };

        /**
         * get current style on cursor
         *
         * @param {WrappedRange} rng
         * @return {Object} - object contains style properties.
         */
        this.current = function (rng) {
            var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);
            var styleInfo = this.fromNode($cont);

            // document.queryCommandState for toggle state
            // [workaround] prevent Firefox nsresult: "0x80004005 (NS_ERROR_FAILURE)"
            try {
                styleInfo = $.extend(styleInfo, {
                    'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',
                    'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',
                    'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',
                    'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',
                    'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',
                    'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'
                });
            } catch (e) {}

            // list-style-type to list-style(unordered, ordered)
            if (!rng.isOnList()) {
                styleInfo['list-style'] = 'none';
            } else {
                var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];
                var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;
                styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';
            }

            var para = dom.ancestor(rng.sc, dom.isPara);
            if (para && para.style['line-height']) {
                styleInfo['line-height'] = para.style.lineHeight;
            } else {
                var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);
                styleInfo['line-height'] = lineHeight.toFixed(1);
            }

            styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);
            styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);
            styleInfo.range = rng;

            return styleInfo;
        };
    };

    /**
     * @class editing.Bullet
     *
     * @alternateClassName Bullet
     */
    var Bullet = function () {
        var self = this;

        /**
         * toggle ordered list
         */
        this.insertOrderedList = function (editable) {
            this.toggleList('OL', editable);
        };

        /**
         * toggle unordered list
         */
        this.insertUnorderedList = function (editable) {
            this.toggleList('UL', editable);
        };

        /**
         * indent
         */
        this.indent = function (editable) {
            var self = this;
            var rng = range.create(editable).wrapBodyInlineWithPara();

            var paras = rng.nodes(dom.isPara, { includeAncestor: true });
            var clustereds = list.clusterBy(paras, func.peq2('parentNode'));

            $.each(clustereds, function (idx, paras) {
                var head = list.head(paras);
                if (dom.isLi(head)) {
                    self.wrapList(paras, head.parentNode.nodeName);
                } else {
                    $.each(paras, function (idx, para) {
                        $(para).css('marginLeft', function (idx, val) {
                            return (parseInt(val, 10) || 0) + 25;
                        });
                    });
                }
            });

            rng.select();
        };

        /**
         * outdent
         */
        this.outdent = function (editable) {
            var self = this;
            var rng = range.create(editable).wrapBodyInlineWithPara();

            var paras = rng.nodes(dom.isPara, { includeAncestor: true });
            var clustereds = list.clusterBy(paras, func.peq2('parentNode'));

            $.each(clustereds, function (idx, paras) {
                var head = list.head(paras);
                if (dom.isLi(head)) {
                    self.releaseList([paras]);
                } else {
                    $.each(paras, function (idx, para) {
                        $(para).css('marginLeft', function (idx, val) {
                            val = parseInt(val, 10) || 0;
                            return val > 25 ? val - 25 : '';
                        });
                    });
                }
            });

            rng.select();
        };

        /**
         * toggle list
         *
         * @param {String} listName - OL or UL
         */
        this.toggleList = function (listName, editable) {
            var rng = range.create(editable).wrapBodyInlineWithPara();

            var paras = rng.nodes(dom.isPara, { includeAncestor: true });
            var bookmark = rng.paraBookmark(paras);
            var clustereds = list.clusterBy(paras, func.peq2('parentNode'));

            // paragraph to list
            if (list.find(paras, dom.isPurePara)) {
                var wrappedParas = [];
                $.each(clustereds, function (idx, paras) {
                    wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));
                });
                paras = wrappedParas;
                // list to paragraph or change list style
            } else {
                var diffLists = rng.nodes(dom.isList, {
                    includeAncestor: true
                }).filter(function (listNode) {
                    return !$.nodeName(listNode, listName);
                });

                if (diffLists.length) {
                    $.each(diffLists, function (idx, listNode) {
                        dom.replace(listNode, listName);
                    });
                } else {
                    paras = this.releaseList(clustereds, true);
                }
            }

            range.createFromParaBookmark(bookmark, paras).select();
        };

        /**
         * @param {Node[]} paras
         * @param {String} listName
         * @return {Node[]}
         */
        this.wrapList = function (paras, listName) {
            var head = list.head(paras);
            var last = list.last(paras);

            var prevList = dom.isList(head.previousSibling) && head.previousSibling;
            var nextList = dom.isList(last.nextSibling) && last.nextSibling;

            var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);

            // P to LI
            paras = paras.map(function (para) {
                return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;
            });

            // append to list(<ul>, <ol>)
            dom.appendChildNodes(listNode, paras);

            if (nextList) {
                dom.appendChildNodes(listNode, list.from(nextList.childNodes));
                dom.remove(nextList);
            }

            return paras;
        };

        /**
         * @method releaseList
         *
         * @param {Array[]} clustereds
         * @param {Boolean} isEscapseToBody
         * @return {Node[]}
         */
        this.releaseList = function (clustereds, isEscapseToBody) {
            var releasedParas = [];

            $.each(clustereds, function (idx, paras) {
                var head = list.head(paras);
                var last = list.last(paras);

                var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) : head.parentNode;
                var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {
                    node: last.parentNode,
                    offset: dom.position(last) + 1
                }, {
                    isSkipPaddingBlankHTML: true
                }) : null;

                var middleList = dom.splitTree(headList, {
                    node: head.parentNode,
                    offset: dom.position(head)
                }, {
                    isSkipPaddingBlankHTML: true
                });

                paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) : list.from(middleList.childNodes).filter(dom.isLi);

                // LI to P
                if (isEscapseToBody || !dom.isList(headList.parentNode)) {
                    paras = paras.map(function (para) {
                        return dom.replace(para, 'P');
                    });
                }

                $.each(list.from(paras).reverse(), function (idx, para) {
                    dom.insertAfter(para, headList);
                });

                // remove empty lists
                var rootLists = list.compact([headList, middleList, lastList]);
                $.each(rootLists, function (idx, rootList) {
                    var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));
                    $.each(listNodes.reverse(), function (idx, listNode) {
                        if (!dom.nodeLength(listNode)) {
                            dom.remove(listNode, true);
                        }
                    });
                });

                releasedParas = releasedParas.concat(paras);
            });

            return releasedParas;
        };
    };

    /**
     * @class editing.Typing
     *
     * Typing
     *
     */
    var Typing = function () {

        // a Bullet instance to toggle lists off
        var bullet = new Bullet();

        /**
         * insert tab
         *
         * @param {WrappedRange} rng
         * @param {Number} tabsize
         */
        this.insertTab = function (rng, tabsize) {
            var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));
            rng = rng.deleteContents();
            rng.insertNode(tab, true);

            rng = range.create(tab, tabsize);
            rng.select();
        };

        /**
         * insert paragraph
         */
        this.insertParagraph = function (editable) {
            var rng = range.create(editable);

            // deleteContents on range.
            rng = rng.deleteContents();

            // Wrap range if it needs to be wrapped by paragraph
            rng = rng.wrapBodyInlineWithPara();

            // finding paragraph
            var splitRoot = dom.ancestor(rng.sc, dom.isPara);

            var nextPara;
            // on paragraph: split paragraph
            if (splitRoot) {
                // if it is an empty line with li
                if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {
                    // toogle UL/OL and escape
                    bullet.toggleList(splitRoot.parentNode.nodeName);
                    return;
                    // if it is an empty line with para on blockquote
                } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {
                    // escape blockquote
                    dom.insertAfter(splitRoot, splitRoot.parentNode);
                    nextPara = splitRoot;
                    // if new line has content (not a line break)
                } else {
                    nextPara = dom.splitTree(splitRoot, rng.getStartPoint());

                    var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);
                    emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));

                    $.each(emptyAnchors, function (idx, anchor) {
                        dom.remove(anchor);
                    });

                    // replace empty heading or pre with P tag
                    if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {
                        nextPara = dom.replace(nextPara, 'p');
                    }
                }
                // no paragraph: insert empty paragraph
            } else {
                var next = rng.sc.childNodes[rng.so];
                nextPara = $(dom.emptyPara)[0];
                if (next) {
                    rng.sc.insertBefore(nextPara, next);
                } else {
                    rng.sc.appendChild(nextPara);
                }
            }

            range.create(nextPara, 0).normalize().select().scrollIntoView(editable);
        };
    };

    /**
     * @class editing.Table
     *
     * Table
     *
     */
    var Table = function () {
        /**
         * handle tab key
         *
         * @param {WrappedRange} rng
         * @param {Boolean} isShift
         */
        this.tab = function (rng, isShift) {
            var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
            var table = dom.ancestor(cell, dom.isTable);
            var cells = dom.listDescendant(table, dom.isCell);

            var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);
            if (nextCell) {
                range.create(nextCell, 0).select();
            }
        };

        /**
         * create empty table element
         *
         * @param {Number} rowCount
         * @param {Number} colCount
         * @return {Node}
         */
        this.createTable = function (colCount, rowCount, options) {
            var tds = [],
                tdHTML;
            for (var idxCol = 0; idxCol < colCount; idxCol++) {
                tds.push('<td>' + dom.blank + '</td>');
            }
            tdHTML = tds.join('');

            var trs = [],
                trHTML;
            for (var idxRow = 0; idxRow < rowCount; idxRow++) {
                trs.push('<tr>' + tdHTML + '</tr>');
            }
            trHTML = trs.join('');
            var $table = $('<table>' + trHTML + '</table>');
            if (options && options.tableClassName) {
                $table.addClass(options.tableClassName);
            }

            return $table[0];
        };
    };

    var KEY_BOGUS = 'bogus';

    /**
     * @class Editor
     */
    var Editor = function (context) {
        var self = this;

        var $note = context.layoutInfo.note;
        var $editor = context.layoutInfo.editor;
        var $editable = context.layoutInfo.editable;
        var options = context.options;
        var lang = options.langInfo;

        var editable = $editable[0];
        var lastRange = null;

        var style = new Style();
        var table = new Table();
        var typing = new Typing();
        var bullet = new Bullet();
        var history = new History($editable);

        this.initialize = function () {
            // bind custom events
            $editable.on('keydown', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    context.triggerEvent('enter', event);
                }
                context.triggerEvent('keydown', event);

                if (!event.isDefaultPrevented()) {
                    if (options.shortcuts) {
                        self.handleKeyMap(event);
                    } else {
                        self.preventDefaultEditableShortCuts(event);
                    }
                }
            }).on('keyup', function (event) {
                context.triggerEvent('keyup', event);
            }).on('focus', function (event) {
                context.triggerEvent('focus', event);
            }).on('blur', function (event) {
                context.triggerEvent('blur', event);
            }).on('mousedown', function (event) {
                context.triggerEvent('mousedown', event);
            }).on('mouseup', function (event) {
                context.triggerEvent('mouseup', event);
            }).on('scroll', function (event) {
                context.triggerEvent('scroll', event);
            }).on('paste', function (event) {
                context.triggerEvent('paste', event);
            });

            // init content before set event
            $editable.html(dom.html($note) || dom.emptyPara);

            // [workaround] IE doesn't have input events for contentEditable
            // - see: https://goo.gl/4bfIvA
            var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';
            $editable.on(changeEventName, func.debounce(function () {
                context.triggerEvent('change', $editable.html());
            }, 250));

            $editor.on('focusin', function (event) {
                context.triggerEvent('focusin', event);
            }).on('focusout', function (event) {
                context.triggerEvent('focusout', event);
            });

            if (!options.airMode) {
                if (options.width) {
                    $editor.outerWidth(options.width);
                }
                if (options.height) {
                    $editable.outerHeight(options.height);
                }
                if (options.maxHeight) {
                    $editable.css('max-height', options.maxHeight);
                }
                if (options.minHeight) {
                    $editable.css('min-height', options.minHeight);
                }
            }

            history.recordUndo();
        };

        this.destroy = function () {
            $editable.off();
        };

        this.handleKeyMap = function (event) {
            var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];
            var keys = [];

            if (event.metaKey) {
                keys.push('CMD');
            }
            if (event.ctrlKey && !event.altKey) {
                keys.push('CTRL');
            }
            if (event.shiftKey) {
                keys.push('SHIFT');
            }

            var keyName = key.nameFromCode[event.keyCode];
            if (keyName) {
                keys.push(keyName);
            }

            var eventName = keyMap[keys.join('+')];
            if (eventName) {
                event.preventDefault();
                context.invoke(eventName);
            } else if (key.isEdit(event.keyCode)) {
                this.afterCommand();
            }
        };

        this.preventDefaultEditableShortCuts = function (event) {
            // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)
            if ((event.ctrlKey || event.metaKey) && list.contains([66, 73, 85], event.keyCode)) {
                event.preventDefault();
            }
        };

        /**
         * create range
         * @return {WrappedRange}
         */
        this.createRange = function () {
            this.focus();
            return range.create(editable);
        };

        /**
         * saveRange
         *
         * save current range
         *
         * @param {Boolean} [thenCollapse=false]
         */
        this.saveRange = function (thenCollapse) {
            lastRange = this.createRange();
            if (thenCollapse) {
                lastRange.collapse().select();
            }
        };

        /**
         * restoreRange
         *
         * restore lately range
         */
        this.restoreRange = function () {
            if (lastRange) {
                lastRange.select();
                this.focus();
            }
        };

        this.saveTarget = function (node) {
            $editable.data('target', node);
        };

        this.clearTarget = function () {
            $editable.removeData('target');
        };

        this.restoreTarget = function () {
            return $editable.data('target');
        };

        /**
         * currentStyle
         *
         * current style
         * @return {Object|Boolean} unfocus
         */
        this.currentStyle = function () {
            var rng = range.create();
            if (rng) {
                rng = rng.normalize();
            }
            return rng ? style.current(rng) : style.fromNode($editable);
        };

        /**
         * style from node
         *
         * @param {jQuery} $node
         * @return {Object}
         */
        this.styleFromNode = function ($node) {
            return style.fromNode($node);
        };

        /**
         * undo
         */
        this.undo = function () {
            context.triggerEvent('before.command', $editable.html());
            history.undo();
            context.triggerEvent('change', $editable.html());
        };
        context.memo('help.undo', lang.help.undo);

        /**
         * redo
         */
        this.redo = function () {
            context.triggerEvent('before.command', $editable.html());
            history.redo();
            context.triggerEvent('change', $editable.html());
        };
        context.memo('help.redo', lang.help.redo);

        /**
         * before command
         */
        var beforeCommand = this.beforeCommand = function () {
            context.triggerEvent('before.command', $editable.html());
            // keep focus on editable before command execution
            self.focus();
        };

        /**
         * after command
         * @param {Boolean} isPreventTrigger
         */
        var afterCommand = this.afterCommand = function (isPreventTrigger) {
            history.recordUndo();
            if (!isPreventTrigger) {
                context.triggerEvent('change', $editable.html());
            }
        };

        /* jshint ignore:start */
        // native commands(with execCommand), generate function for execCommand
        var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull', 'formatBlock', 'removeFormat', 'backColor', 'foreColor', 'fontName'];

        for (var idx = 0, len = commands.length; idx < len; idx++) {
            this[commands[idx]] = function (sCmd) {
                return function (value) {
                    beforeCommand();
                    document.execCommand(sCmd, false, value);
                    afterCommand(true);
                };
            }(commands[idx]);
            context.memo('help.' + commands[idx], lang.help[commands[idx]]);
        }
        /* jshint ignore:end */

        /**
         * handle tab key
         */
        this.tab = function () {
            var rng = this.createRange();
            if (rng.isCollapsed() && rng.isOnCell()) {
                table.tab(rng);
            } else {
                beforeCommand();
                typing.insertTab(rng, options.tabSize);
                afterCommand();
            }
        };
        context.memo('help.tab', lang.help.tab);

        /**
         * handle shift+tab key
         */
        this.untab = function () {
            var rng = this.createRange();
            if (rng.isCollapsed() && rng.isOnCell()) {
                table.tab(rng, true);
            }
        };
        context.memo('help.untab', lang.help.untab);

        /**
         * run given function between beforeCommand and afterCommand
         */
        this.wrapCommand = function (fn) {
            return function () {
                beforeCommand();
                fn.apply(self, arguments);
                afterCommand();
            };
        };

        /**
         * insert paragraph
         */
        this.insertParagraph = this.wrapCommand(function () {
            typing.insertParagraph(editable);
        });
        context.memo('help.insertParagraph', lang.help.insertParagraph);

        this.insertOrderedList = this.wrapCommand(function () {
            bullet.insertOrderedList(editable);
        });
        context.memo('help.insertOrderedList', lang.help.insertOrderedList);

        this.insertUnorderedList = this.wrapCommand(function () {
            bullet.insertUnorderedList(editable);
        });
        context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);

        this.indent = this.wrapCommand(function () {
            bullet.indent(editable);
        });
        context.memo('help.indent', lang.help.indent);

        this.outdent = this.wrapCommand(function () {
            bullet.outdent(editable);
        });
        context.memo('help.outdent', lang.help.outdent);

        /**
         * insert image
         *
         * @param {String} src
         * @param {String|Function} param
         * @return {Promise}
         */
        this.insertImage = function (src, param) {
            return async.createImage(src, param).then(function ($image) {
                beforeCommand();

                if (typeof param === 'function') {
                    param($image);
                } else {
                    if (typeof param === 'string') {
                        $image.attr('data-filename', param);
                    }
                    $image.css('width', Math.min($editable.width(), $image.width()));
                }

                $image.show();
                range.create(editable).insertNode($image[0]);
                range.createFromNodeAfter($image[0]).select();
                afterCommand();
            }).fail(function (e) {
                context.triggerEvent('image.upload.error', e);
            });
        };

        /**
         * insertImages
         * @param {File[]} files
         */
        this.insertImages = function (files) {
            $.each(files, function (idx, file) {
                var filename = file.name;
                if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {
                    context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);
                } else {
                    async.readFileAsDataURL(file).then(function (dataURL) {
                        return self.insertImage(dataURL, filename);
                    }).fail(function () {
                        context.triggerEvent('image.upload.error');
                    });
                }
            });
        };

        /**
         * insertImagesOrCallback
         * @param {File[]} files
         */
        this.insertImagesOrCallback = function (files) {
            var callbacks = options.callbacks;

            // If onImageUpload options setted
            if (callbacks.onImageUpload) {
                context.triggerEvent('image.upload', files);
                // else insert Image as dataURL
            } else {
                this.insertImages(files);
            }
        };

        /**
         * insertNode
         * insert node
         * @param {Node} node
         */
        this.insertNode = this.wrapCommand(function (node) {
            var rng = this.createRange();
            rng.insertNode(node);
            range.createFromNodeAfter(node).select();
        });

        /**
         * insert text
         * @param {String} text
         */
        this.insertText = this.wrapCommand(function (text) {
            var rng = this.createRange();
            var textNode = rng.insertNode(dom.createText(text));
            range.create(textNode, dom.nodeLength(textNode)).select();
        });

        /**
         * return selected plain text
         * @return {String} text
         */
        this.getSelectedText = function () {
            var rng = this.createRange();

            // if range on anchor, expand range with anchor
            if (rng.isOnAnchor()) {
                rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));
            }

            return rng.toString();
        };

        /**
         * paste HTML
         * @param {String} markup
         */
        this.pasteHTML = this.wrapCommand(function (markup) {
            var contents = this.createRange().pasteHTML(markup);
            range.createFromNodeAfter(list.last(contents)).select();
        });

        /**
         * formatBlock
         *
         * @param {String} tagName
         */
        this.formatBlock = this.wrapCommand(function (tagName) {
            // [workaround] for MSIE, IE need `<`
            tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;
            document.execCommand('FormatBlock', false, tagName);
        });

        this.formatPara = function () {
            this.formatBlock('P');
        };
        context.memo('help.formatPara', lang.help.formatPara);

        /* jshint ignore:start */
        for (var idx = 1; idx <= 6; idx++) {
            this['formatH' + idx] = function (idx) {
                return function () {
                    this.formatBlock('H' + idx);
                };
            }(idx);
            context.memo('help.formatH' + idx, lang.help['formatH' + idx]);
        }
        /* jshint ignore:end */

        /**
         * fontSize
         *
         * @param {String} value - px
         */
        this.fontSize = function (value) {
            var rng = this.createRange();

            if (rng && rng.isCollapsed()) {
                var spans = style.styleNodes(rng);
                var firstSpan = list.head(spans);

                $(spans).css({
                    'font-size': value + 'px'
                });

                // [workaround] added styled bogus span for style
                //  - also bogus character needed for cursor position
                if (firstSpan && !dom.nodeLength(firstSpan)) {
                    firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;
                    range.createFromNodeAfter(firstSpan.firstChild).select();
                    $editable.data(KEY_BOGUS, firstSpan);
                }
            } else {
                beforeCommand();
                $(style.styleNodes(rng)).css({
                    'font-size': value + 'px'
                });
                afterCommand();
            }
        };

        /**
         * insert horizontal rule
         */
        this.insertHorizontalRule = this.wrapCommand(function () {
            var hrNode = this.createRange().insertNode(dom.create('HR'));
            if (hrNode.nextSibling) {
                range.create(hrNode.nextSibling, 0).normalize().select();
            }
        });
        context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);

        /**
         * remove bogus node and character
         */
        this.removeBogus = function () {
            var bogusNode = $editable.data(KEY_BOGUS);
            if (!bogusNode) {
                return;
            }

            var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);

            var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);
            if (bogusCharIdx !== -1) {
                textNode.deleteData(bogusCharIdx, 1);
            }

            if (dom.isEmpty(bogusNode)) {
                dom.remove(bogusNode);
            }

            $editable.removeData(KEY_BOGUS);
        };

        /**
         * lineHeight
         * @param {String} value
         */
        this.lineHeight = this.wrapCommand(function (value) {
            style.stylePara(this.createRange(), {
                lineHeight: value
            });
        });

        /**
         * unlink
         *
         * @type command
         */
        this.unlink = function () {
            var rng = this.createRange();
            if (rng.isOnAnchor()) {
                var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                rng = range.createFromNode(anchor);
                rng.select();

                beforeCommand();
                document.execCommand('unlink');
                afterCommand();
            }
        };

        /**
         * create link (command)
         *
         * @param {Object} linkInfo
         */
        this.createLink = this.wrapCommand(function (linkInfo) {
            var linkUrl = linkInfo.url;
            var linkText = linkInfo.text;
            var isNewWindow = linkInfo.isNewWindow;
            var rng = linkInfo.range || this.createRange();
            var isTextChanged = rng.toString() !== linkText;

            // handle spaced urls from input
            if (typeof linkUrl === 'string') {
                linkUrl = linkUrl.trim();
            }

            if (options.onCreateLink) {
                linkUrl = options.onCreateLink(linkUrl);
            }

            var anchors = [];
            if (isTextChanged) {
                rng = rng.deleteContents();
                var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);
                anchors.push(anchor);
            } else {
                anchors = style.styleNodes(rng, {
                    nodeName: 'A',
                    expandClosestSibling: true,
                    onlyPartialContains: true
                });
            }

            $.each(anchors, function (idx, anchor) {
                // if url doesn't match an URL schema, set http:// as default
                linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?/.test(linkUrl) ? linkUrl : 'http://' + linkUrl;

                $(anchor).attr('href', linkUrl);
                if (isNewWindow) {
                    $(anchor).attr('target', '_blank');
                } else {
                    $(anchor).removeAttr('target');
                }
            });

            var startRange = range.createFromNodeBefore(list.head(anchors));
            var startPoint = startRange.getStartPoint();
            var endRange = range.createFromNodeAfter(list.last(anchors));
            var endPoint = endRange.getEndPoint();

            range.create(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset).select();
        });

        /**
         * returns link info
         *
         * @return {Object}
         * @return {WrappedRange} return.range
         * @return {String} return.text
         * @return {Boolean} [return.isNewWindow=true]
         * @return {String} [return.url=""]
         */
        this.getLinkInfo = function () {
            var rng = this.createRange().expand(dom.isAnchor);

            // Get the first anchor on range(for edit).
            var $anchor = $(list.head(rng.nodes(dom.isAnchor)));

            return {
                range: rng,
                text: rng.toString(),
                isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,
                url: $anchor.length ? $anchor.attr('href') : ''
            };
        };

        /**
         * setting color
         *
         * @param {Object} sObjColor  color code
         * @param {String} sObjColor.foreColor foreground color
         * @param {String} sObjColor.backColor background color
         */
        this.color = this.wrapCommand(function (colorInfo) {
            var foreColor = colorInfo.foreColor;
            var backColor = colorInfo.backColor;

            if (foreColor) {
                document.execCommand('foreColor', false, foreColor);
            }
            if (backColor) {
                document.execCommand('backColor', false, backColor);
            }
        });

        /**
         * insert Table
         *
         * @param {String} dimension of table (ex : "5x5")
         */
        this.insertTable = this.wrapCommand(function (dim) {
            var dimension = dim.split('x');

            var rng = this.createRange().deleteContents();
            rng.insertNode(table.createTable(dimension[0], dimension[1], options));
        });

        /**
         * float me
         *
         * @param {String} value
         */
        this.floatMe = this.wrapCommand(function (value) {
            var $target = $(this.restoreTarget());
            $target.css('float', value);
        });

        /**
         * resize overlay element
         * @param {String} value
         */
        this.resize = this.wrapCommand(function (value) {
            var $target = $(this.restoreTarget());
            $target.css({
                width: value * 100 + '%',
                height: ''
            });
        });

        /**
         * @param {Position} pos
         * @param {jQuery} $target - target element
         * @param {Boolean} [bKeepRatio] - keep ratio
         */
        this.resizeTo = function (pos, $target, bKeepRatio) {
            var imageSize;
            if (bKeepRatio) {
                var newRatio = pos.y / pos.x;
                var ratio = $target.data('ratio');
                imageSize = {
                    width: ratio > newRatio ? pos.x : pos.y / ratio,
                    height: ratio > newRatio ? pos.x * ratio : pos.y
                };
            } else {
                imageSize = {
                    width: pos.x,
                    height: pos.y
                };
            }

            $target.css(imageSize);
        };

        /**
         * remove media object
         */
        this.removeMedia = this.wrapCommand(function () {
            var $target = $(this.restoreTarget()).detach();
            context.triggerEvent('media.delete', $target, $editable);
        });

        /**
         * returns whether editable area has focus or not.
         */
        this.hasFocus = function () {
            return $editable.is(':focus');
        };

        /**
         * set focus
         */
        this.focus = function () {
            // [workaround] Screen will move when page is scolled in IE.
            //  - do focus when not focused
            if (!this.hasFocus()) {
                $editable.focus();
            }
        };

        /**
         * returns whether contents is empty or not.
         * @return {Boolean}
         */
        this.isEmpty = function () {
            return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();
        };

        /**
         * Removes all contents and restores the editable instance to an _emptyPara_.
         */
        this.empty = function () {
            context.invoke('code', dom.emptyPara);
        };
    };

    var Clipboard = function (context) {
        var self = this;

        var $editable = context.layoutInfo.editable;

        this.events = {
            'summernote.keydown': function (we, e) {
                if (self.needKeydownHook()) {
                    if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {
                        context.invoke('editor.saveRange');
                        self.$paste.focus();

                        setTimeout(function () {
                            self.pasteByHook();
                        }, 0);
                    }
                }
            }
        };

        this.needKeydownHook = function () {
            return agent.isMSIE && agent.browserVersion > 10 || agent.isFF;
        };

        this.initialize = function () {
            // [workaround] getting image from clipboard
            //  - IE11 and Firefox: CTRL+v hook
            //  - Webkit: event.clipboardData
            if (this.needKeydownHook()) {
                this.$paste = $('<div tabindex="-1" />').attr('contenteditable', true).css({
                    position: 'absolute',
                    left: -100000,
                    opacity: 0
                });
                $editable.before(this.$paste);

                this.$paste.on('paste', function (event) {
                    context.triggerEvent('paste', event);
                });
            } else {
                $editable.on('paste', this.pasteByEvent);
            }
        };

        this.destroy = function () {
            if (this.needKeydownHook()) {
                this.$paste.remove();
                this.$paste = null;
            }
        };

        this.pasteByHook = function () {
            var node = this.$paste[0].firstChild;

            if (dom.isImg(node)) {
                var dataURI = node.src;
                var decodedData = atob(dataURI.split(',')[1]);
                var array = new Uint8Array(decodedData.length);
                for (var i = 0; i < decodedData.length; i++) {
                    array[i] = decodedData.charCodeAt(i);
                }

                var blob = new Blob([array], { type: 'image/png' });
                blob.name = 'clipboard.png';

                context.invoke('editor.restoreRange');
                context.invoke('editor.focus');
                context.invoke('editor.insertImagesOrCallback', [blob]);
            } else {
                var pasteContent = $('<div />').html(this.$paste.html()).html();
                context.invoke('editor.restoreRange');
                context.invoke('editor.focus');

                if (pasteContent) {
                    context.invoke('editor.pasteHTML', pasteContent);
                }
            }

            this.$paste.empty();
        };

        /**
         * paste by clipboard event
         *
         * @param {Event} event
         */
        this.pasteByEvent = function (event) {
            var clipboardData = event.originalEvent.clipboardData;
            if (clipboardData && clipboardData.items && clipboardData.items.length) {
                var item = list.head(clipboardData.items);
                if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {
                    context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);
                }
                context.invoke('editor.afterCommand');
            }
        };
    };

    var Dropzone = function (context) {
        var $document = $(document);
        var $editor = context.layoutInfo.editor;
        var $editable = context.layoutInfo.editable;
        var options = context.options;
        var lang = options.langInfo;
        var documentEventHandlers = {};

        var $dropzone = $(['<div class="note-dropzone">', '  <div class="note-dropzone-message"/>', '</div>'].join('')).prependTo($editor);

        var detachDocumentEvent = function () {
            Object.keys(documentEventHandlers).forEach(function (key) {
                $document.off(key.substr(2).toLowerCase(), documentEventHandlers[key]);
            });
            documentEventHandlers = {};
        };

        /**
         * attach Drag and Drop Events
         */
        this.initialize = function () {
            if (options.disableDragAndDrop) {
                // prevent default drop event
                documentEventHandlers.onDrop = function (e) {
                    e.preventDefault();
                };
                $document.on('drop', documentEventHandlers.onDrop);
            } else {
                this.attachDragAndDropEvent();
            }
        };

        /**
         * attach Drag and Drop Events
         */
        this.attachDragAndDropEvent = function () {
            var collection = $(),
                $dropzoneMessage = $dropzone.find('.note-dropzone-message');

            documentEventHandlers.onDragenter = function (e) {
                var isCodeview = context.invoke('codeview.isActivated');
                var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;
                if (!isCodeview && !collection.length && hasEditorSize) {
                    $editor.addClass('dragover');
                    $dropzone.width($editor.width());
                    $dropzone.height($editor.height());
                    $dropzoneMessage.text(lang.image.dragImageHere);
                }
                collection = collection.add(e.target);
            };

            documentEventHandlers.onDragleave = function (e) {
                collection = collection.not(e.target);
                if (!collection.length) {
                    $editor.removeClass('dragover');
                }
            };

            documentEventHandlers.onDrop = function () {
                collection = $();
                $editor.removeClass('dragover');
            };

            // show dropzone on dragenter when dragging a object to document
            // -but only if the editor is visible, i.e. has a positive width and height
            $document.on('dragenter', documentEventHandlers.onDragenter).on('dragleave', documentEventHandlers.onDragleave).on('drop', documentEventHandlers.onDrop);

            // change dropzone's message on hover.
            $dropzone.on('dragenter', function () {
                $dropzone.addClass('hover');
                $dropzoneMessage.text(lang.image.dropImage);
            }).on('dragleave', function () {
                $dropzone.removeClass('hover');
                $dropzoneMessage.text(lang.image.dragImageHere);
            });

            // attach dropImage
            $dropzone.on('drop', function (event) {
                var dataTransfer = event.originalEvent.dataTransfer;

                if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                    event.preventDefault();
                    $editable.focus();
                    context.invoke('editor.insertImagesOrCallback', dataTransfer.files);
                } else {
                    $.each(dataTransfer.types, function (idx, type) {
                        var content = dataTransfer.getData(type);

                        if (type.toLowerCase().indexOf('text') > -1) {
                            context.invoke('editor.pasteHTML', content);
                        } else {
                            $(content).each(function () {
                                context.invoke('editor.insertNode', this);
                            });
                        }
                    });
                }
            }).on('dragover', false); // prevent default dragover event
        };

        this.destroy = function () {
            detachDocumentEvent();
        };
    };

    var CodeMirror;
    if (agent.hasCodeMirror) {
        if (agent.isSupportAmd) {
            require(['codemirror'], function (cm) {
                CodeMirror = cm;
            });
        } else {
            CodeMirror = window.CodeMirror;
        }
    }

    /**
     * @class Codeview
     */
    var Codeview = function (context) {
        var $editor = context.layoutInfo.editor;
        var $editable = context.layoutInfo.editable;
        var $codable = context.layoutInfo.codable;
        var options = context.options;

        this.sync = function () {
            var isCodeview = this.isActivated();
            if (isCodeview && agent.hasCodeMirror) {
                $codable.data('cmEditor').save();
            }
        };

        /**
         * @return {Boolean}
         */
        this.isActivated = function () {
            return $editor.hasClass('codeview');
        };

        /**
         * toggle codeview
         */
        this.toggle = function () {
            if (this.isActivated()) {
                this.deactivate();
            } else {
                this.activate();
            }
            context.triggerEvent('codeview.toggled');
        };

        /**
         * activate code view
         */
        this.activate = function () {
            $codable.val(dom.html($editable, options.prettifyHtml));
            $codable.height($editable.height());

            context.invoke('toolbar.updateCodeview', true);
            $editor.addClass('codeview');
            $codable.focus();

            // activate CodeMirror as codable
            if (agent.hasCodeMirror) {
                var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);

                // CodeMirror TernServer
                if (options.codemirror.tern) {
                    var server = new CodeMirror.TernServer(options.codemirror.tern);
                    cmEditor.ternServer = server;
                    cmEditor.on('cursorActivity', function (cm) {
                        server.updateArgHints(cm);
                    });
                }

                // CodeMirror hasn't Padding.
                cmEditor.setSize(null, $editable.outerHeight());
                $codable.data('cmEditor', cmEditor);
            }
        };

        /**
         * deactivate code view
         */
        this.deactivate = function () {
            // deactivate CodeMirror as codable
            if (agent.hasCodeMirror) {
                var cmEditor = $codable.data('cmEditor');
                $codable.val(cmEditor.getValue());
                cmEditor.toTextArea();
            }

            var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;
            var isChange = $editable.html() !== value;

            $editable.html(value);
            $editable.height(options.height ? $codable.height() : 'auto');
            $editor.removeClass('codeview');

            if (isChange) {
                context.triggerEvent('change', $editable.html(), $editable);
            }

            $editable.focus();

            context.invoke('toolbar.updateCodeview', false);
        };

        this.destroy = function () {
            if (this.isActivated()) {
                this.deactivate();
            }
        };
    };

    var EDITABLE_PADDING = 24;

    var Statusbar = function (context) {
        var $document = $(document);
        var $statusbar = context.layoutInfo.statusbar;
        var $editable = context.layoutInfo.editable;
        var options = context.options;

        this.initialize = function () {
            if (options.airMode || options.disableResizeEditor) {
                return;
            }

            $statusbar.on('mousedown', function (event) {
                event.preventDefault();
                event.stopPropagation();

                var editableTop = $editable.offset().top - $document.scrollTop();

                $document.on('mousemove', function (event) {
                    var height = event.clientY - (editableTop + EDITABLE_PADDING);

                    height = options.minheight > 0 ? Math.max(height, options.minheight) : height;
                    height = options.maxHeight > 0 ? Math.min(height, options.maxHeight) : height;

                    $editable.height(height);
                }).one('mouseup', function () {
                    $document.off('mousemove');
                });
            });
        };

        this.destroy = function () {
            $statusbar.off();
            $statusbar.remove();
        };
    };

    var Fullscreen = function (context) {
        var $editor = context.layoutInfo.editor;
        var $toolbar = context.layoutInfo.toolbar;
        var $editable = context.layoutInfo.editable;
        var $codable = context.layoutInfo.codable;

        var $window = $(window);
        var $scrollbar = $('html, body');

        /**
         * toggle fullscreen
         */
        this.toggle = function () {
            var resize = function (size) {
                $editable.css('height', size.h);
                $codable.css('height', size.h);
                if ($codable.data('cmeditor')) {
                    $codable.data('cmeditor').setsize(null, size.h);
                }
            };

            $editor.toggleClass('fullscreen');
            if (this.isFullscreen()) {
                $editable.data('orgHeight', $editable.css('height'));

                $window.on('resize', function () {
                    resize({
                        h: $window.height() - $toolbar.outerHeight()
                    });
                }).trigger('resize');

                $scrollbar.css('overflow', 'hidden');
            } else {
                $window.off('resize');
                resize({
                    h: $editable.data('orgHeight')
                });
                $scrollbar.css('overflow', 'visible');
            }

            context.invoke('toolbar.updateFullscreen', this.isFullscreen());
        };

        this.isFullscreen = function () {
            return $editor.hasClass('fullscreen');
        };
    };

    var Handle = function (context) {
        var self = this;

        var $document = $(document);
        var $editingArea = context.layoutInfo.editingArea;
        var options = context.options;

        this.events = {
            'summernote.mousedown': function (we, e) {
                if (self.update(e.target)) {
                    e.preventDefault();
                }
            },
            'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {
                self.update();
            }
        };

        this.initialize = function () {
            this.$handle = $(['<div class="note-handle">', '<div class="note-control-selection">', '<div class="note-control-selection-bg"></div>', '<div class="note-control-holder note-control-nw"></div>', '<div class="note-control-holder note-control-ne"></div>', '<div class="note-control-holder note-control-sw"></div>', '<div class="', options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing', ' note-control-se"></div>', options.disableResizeImage ? '' : '<div class="note-control-selection-info"></div>', '</div>', '</div>'].join('')).prependTo($editingArea);

            this.$handle.on('mousedown', function (event) {
                if (dom.isControlSizing(event.target)) {
                    event.preventDefault();
                    event.stopPropagation();

                    var $target = self.$handle.find('.note-control-selection').data('target'),
                        posStart = $target.offset(),
                        scrollTop = $document.scrollTop();

                    $document.on('mousemove', function (event) {
                        context.invoke('editor.resizeTo', {
                            x: event.clientX - posStart.left,
                            y: event.clientY - (posStart.top - scrollTop)
                        }, $target, !event.shiftKey);

                        self.update($target[0]);
                    }).one('mouseup', function (e) {
                        e.preventDefault();
                        $document.off('mousemove');
                        context.invoke('editor.afterCommand');
                    });

                    if (!$target.data('ratio')) {
                        // original ratio.
                        $target.data('ratio', $target.height() / $target.width());
                    }
                }
            });
        };

        this.destroy = function () {
            this.$handle.remove();
        };

        this.update = function (target) {
            var isImage = dom.isImg(target);
            var $selection = this.$handle.find('.note-control-selection');

            context.invoke('imagePopover.update', target);

            if (isImage) {
                var $image = $(target);
                var pos = $image.position();

                // include margin
                var imageSize = {
                    w: $image.outerWidth(true),
                    h: $image.outerHeight(true)
                };

                $selection.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top,
                    width: imageSize.w,
                    height: imageSize.h
                }).data('target', $image); // save current image element.

                var sizingText = imageSize.w + 'x' + imageSize.h;
                $selection.find('.note-control-selection-info').text(sizingText);
                context.invoke('editor.saveTarget', target);
            } else {
                this.hide();
            }

            return isImage;
        };

        /**
         * hide
         *
         * @param {jQuery} $handle
         */
        this.hide = function () {
            context.invoke('editor.clearTarget');
            this.$handle.children().hide();
        };
    };

    var AutoLink = function (context) {
        var self = this;
        var defaultScheme = 'http://';
        var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?|mailto:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i;

        this.events = {
            'summernote.keyup': function (we, e) {
                if (!e.isDefaultPrevented()) {
                    self.handleKeyup(e);
                }
            },
            'summernote.keydown': function (we, e) {
                self.handleKeydown(e);
            }
        };

        this.initialize = function () {
            this.lastWordRange = null;
        };

        this.destroy = function () {
            this.lastWordRange = null;
        };

        this.replace = function () {
            if (!this.lastWordRange) {
                return;
            }

            var keyword = this.lastWordRange.toString();
            var match = keyword.match(linkPattern);

            if (match && (match[1] || match[2])) {
                var link = match[1] ? keyword : defaultScheme + keyword;
                var node = $('<a />').html(keyword).attr('href', link)[0];

                this.lastWordRange.insertNode(node);
                this.lastWordRange = null;
                context.invoke('editor.focus');
            }
        };

        this.handleKeydown = function (e) {
            if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
                var wordRange = context.invoke('editor.createRange').getWordRange();
                this.lastWordRange = wordRange;
            }
        };

        this.handleKeyup = function (e) {
            if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
                this.replace();
            }
        };
    };

    /**
     * textarea auto sync.
     */
    var AutoSync = function (context) {
        var $note = context.layoutInfo.note;

        this.events = {
            'summernote.change': function () {
                $note.val(context.invoke('code'));
            }
        };

        this.shouldInitialize = function () {
            return dom.isTextarea($note[0]);
        };
    };

    var Placeholder = function (context) {
        var self = this;
        var $editingArea = context.layoutInfo.editingArea;
        var options = context.options;

        this.events = {
            'summernote.init summernote.change': function () {
                self.update();
            },
            'summernote.codeview.toggled': function () {
                self.update();
            }
        };

        this.shouldInitialize = function () {
            return !!options.placeholder;
        };

        this.initialize = function () {
            this.$placeholder = $('<div class="note-placeholder">');
            this.$placeholder.on('click', function () {
                context.invoke('focus');
            }).text(options.placeholder).prependTo($editingArea);
        };

        this.destroy = function () {
            this.$placeholder.remove();
        };

        this.update = function () {
            var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');
            this.$placeholder.toggle(isShow);
        };
    };

    var Buttons = function (context) {
        var self = this;
        var ui = $.summernote.ui;

        var $toolbar = context.layoutInfo.toolbar;
        var options = context.options;
        var lang = options.langInfo;

        var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);

        var representShortcut = this.representShortcut = function (editorMethod) {
            var shortcut = invertedKeyMap[editorMethod];
            if (!options.shortcuts || !shortcut) {
                return '';
            }

            if (agent.isMac) {
                shortcut = shortcut.replace('CMD', '').replace('SHIFT', '');
            }

            shortcut = shortcut.replace('BACKSLASH', '\\').replace('SLASH', '/').replace('LEFTBRACKET', '[').replace('RIGHTBRACKET', ']');

            return ' (' + shortcut + ')';
        };

        this.initialize = function () {
            this.addToolbarButtons();
            this.addImagePopoverButtons();
            this.addLinkPopoverButtons();
            this.fontInstalledMap = {};
        };

        this.destroy = function () {
            delete this.fontInstalledMap;
        };

        this.isFontInstalled = function (name) {
            if (!self.fontInstalledMap.hasOwnProperty(name)) {
                self.fontInstalledMap[name] = agent.isFontInstalled(name) || list.contains(options.fontNamesIgnoreCheck, name);
            }

            return self.fontInstalledMap[name];
        };

        this.addToolbarButtons = function () {
            context.memo('button.style', function () {
                return ui.buttonGroup([ui.button({
                    className: '',
                    contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),
                    tooltip: lang.style.style,
                    data: {
                        toggle: 'dropdown'
                    }
                }), ui.dropdown({
                    className: 'dropdown-style',
                    items: context.options.styleTags,
                    template: function (item) {

                        if (typeof item === 'string') {
                            item = { tag: item, title: lang.style.hasOwnProperty(item) ? lang.style[item] : item };
                        }

                        var tag = item.tag;
                        var title = item.title;
                        var style = item.style ? ' style="' + item.style + '" ' : '';
                        var className = item.className ? ' class="' + item.className + '"' : '';

                        return '<' + tag + style + className + '>' + title + '</' + tag + '>';
                    },
                    click: context.createInvokeHandler('editor.formatBlock')
                })]).render();
            });

            context.memo('button.bold', function () {
                return ui.button({
                    className: 'note-btn-bold',
                    contents: ui.icon(options.icons.bold),
                    tooltip: lang.font.bold + representShortcut('bold'),
                    click: context.createInvokeHandler('editor.bold')
                }).render();
            });

            context.memo('button.italic', function () {
                return ui.button({
                    className: 'note-btn-italic',
                    contents: ui.icon(options.icons.italic),
                    tooltip: lang.font.italic + representShortcut('italic'),
                    click: context.createInvokeHandler('editor.italic')
                }).render();
            });

            context.memo('button.underline', function () {
                return ui.button({
                    className: 'note-btn-underline',
                    contents: ui.icon(options.icons.underline),
                    tooltip: lang.font.underline + representShortcut('underline'),
                    click: context.createInvokeHandler('editor.underline')
                }).render();
            });

            context.memo('button.clear', function () {
                return ui.button({
                    contents: ui.icon(options.icons.eraser),
                    tooltip: lang.font.clear + representShortcut('removeFormat'),
                    click: context.createInvokeHandler('editor.removeFormat')
                }).render();
            });

            context.memo('button.strikethrough', function () {
                return ui.button({
                    className: 'note-btn-strikethrough',
                    contents: ui.icon(options.icons.strikethrough),
                    tooltip: lang.font.strikethrough + representShortcut('strikethrough'),
                    click: context.createInvokeHandler('editor.strikethrough')
                }).render();
            });

            context.memo('button.superscript', function () {
                return ui.button({
                    className: 'note-btn-superscript',
                    contents: ui.icon(options.icons.superscript),
                    tooltip: lang.font.superscript,
                    click: context.createInvokeHandler('editor.superscript')
                }).render();
            });

            context.memo('button.subscript', function () {
                return ui.button({
                    className: 'note-btn-subscript',
                    contents: ui.icon(options.icons.subscript),
                    tooltip: lang.font.subscript,
                    click: context.createInvokeHandler('editor.subscript')
                }).render();
            });

            context.memo('button.fontname', function () {
                return ui.buttonGroup([ui.button({
                    className: '',
                    contents: '<span class="note-current-fontname"/> ' + ui.icon(options.icons.caret, 'span'),
                    tooltip: lang.font.name,
                    data: {
                        toggle: 'dropdown'
                    }
                }), ui.dropdownCheck({
                    className: 'dropdown-fontname',
                    checkClassName: '',
                    items: options.fontNames.filter(self.isFontInstalled),
                    template: function (item) {
                        return '<span style="font-family:' + item + '">' + item + '</span>';
                    },
                    click: context.createInvokeHandler('editor.fontName')
                })]).render();
            });

            context.memo('button.fontsize', function () {
                return ui.buttonGroup([ui.button({
                    className: '',
                    contents: '<span class="note-current-fontsize"/>' + ui.icon(options.icons.caret, 'span'),
                    tooltip: lang.font.size,
                    data: {
                        toggle: 'dropdown'
                    }
                }), ui.dropdownCheck({
                    className: 'dropdown-fontsize',
                    checkClassName: options.icons.menuCheck,
                    items: options.fontSizes,
                    click: context.createInvokeHandler('editor.fontSize')
                })]).render();
            });

            context.memo('button.color', function () {
                return ui.buttonGroup({
                    className: 'note-color',
                    children: [ui.button({
                        className: 'note-current-color-button',
                        contents: ui.icon(options.icons.font + ' note-recent-color'),
                        tooltip: lang.color.recent,
                        click: function (e) {
                            var $button = $(e.currentTarget);
                            context.invoke('editor.color', {
                                backColor: $button.attr('data-backColor'),
                                foreColor: $button.attr('data-foreColor')
                            });
                        },
                        callback: function ($button) {
                            var $recentColor = $button.find('.note-recent-color');
                            $recentColor.css('background-color', '#FFFF00');
                            $button.attr('data-backColor', '#FFFF00');
                        }
                    }), ui.button({
                        className: '',
                        contents: ui.icon(options.icons.caret, 'span'),
                        tooltip: lang.color.more,
                        data: {
                            toggle: 'dropdown'
                        }
                    }), ui.dropdown({
                        items: ['<li>', '<div class="btn-group">', '  <div class="note-palette-title">' + lang.color.background + '</div>', '  <div>', '    <button type="button" class="note-color-reset btn btn-default" data-event="backColor" data-value="inherit">', lang.color.transparent, '    </button>', '  </div>', '  <div class="note-holder" data-event="backColor"/>', '</div>', '<div class="btn-group">', '  <div class="note-palette-title">' + lang.color.foreground + '</div>', '  <div>', '    <button type="button" class="note-color-reset btn btn-default" data-event="removeFormat" data-value="foreColor">', lang.color.resetToDefault, '    </button>', '  </div>', '  <div class="note-holder" data-event="foreColor"/>', '</div>', '</li>'].join(''),
                        callback: function ($dropdown) {
                            $dropdown.find('.note-holder').each(function () {
                                var $holder = $(this);
                                $holder.append(ui.palette({
                                    colors: options.colors,
                                    eventName: $holder.data('event')
                                }).render());
                            });
                        },
                        click: function (event) {
                            var $button = $(event.target);
                            var eventName = $button.data('event');
                            var value = $button.data('value');

                            if (eventName && value) {
                                var key = eventName === 'backColor' ? 'background-color' : 'color';
                                var $color = $button.closest('.note-color').find('.note-recent-color');
                                var $currentButton = $button.closest('.note-color').find('.note-current-color-button');

                                $color.css(key, value);
                                $currentButton.attr('data-' + eventName, value);
                                context.invoke('editor.' + eventName, value);
                            }
                        }
                    })]
                }).render();
            });

            context.memo('button.ul', function () {
                return ui.button({
                    contents: ui.icon(options.icons.unorderedlist),
                    tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),
                    click: context.createInvokeHandler('editor.insertUnorderedList')
                }).render();
            });

            context.memo('button.ol', function () {
                return ui.button({
                    contents: ui.icon(options.icons.orderedlist),
                    tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),
                    click: context.createInvokeHandler('editor.insertOrderedList')
                }).render();
            });

            var justifyLeft = ui.button({
                contents: ui.icon(options.icons.alignLeft),
                tooltip: lang.paragraph.left + representShortcut('justifyLeft'),
                click: context.createInvokeHandler('editor.justifyLeft')
            });

            var justifyCenter = ui.button({
                contents: ui.icon(options.icons.alignCenter),
                tooltip: lang.paragraph.center + representShortcut('justifyCenter'),
                click: context.createInvokeHandler('editor.justifyCenter')
            });

            var justifyRight = ui.button({
                contents: ui.icon(options.icons.alignRight),
                tooltip: lang.paragraph.right + representShortcut('justifyRight'),
                click: context.createInvokeHandler('editor.justifyRight')
            });

            var justifyFull = ui.button({
                contents: ui.icon(options.icons.alignJustify),
                tooltip: lang.paragraph.justify + representShortcut('justifyFull'),
                click: context.createInvokeHandler('editor.justifyFull')
            });

            var outdent = ui.button({
                contents: ui.icon(options.icons.outdent),
                tooltip: lang.paragraph.outdent + representShortcut('outdent'),
                click: context.createInvokeHandler('editor.outdent')
            });

            var indent = ui.button({
                contents: ui.icon(options.icons.indent),
                tooltip: lang.paragraph.indent + representShortcut('indent'),
                click: context.createInvokeHandler('editor.indent')
            });

            context.memo('button.justifyLeft', justifyLeft.render());
            context.memo('button.justifyCenter', justifyCenter.render());
            context.memo('button.justifyRight', justifyRight.render());
            context.memo('button.justifyFull', justifyFull.render());
            context.memo('button.outdent', outdent.render());
            context.memo('button.indent', indent.render());

            context.memo('button.paragraph', function () {
                return ui.buttonGroup([ui.button({
                    className: '',
                    contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),
                    tooltip: lang.paragraph.paragraph,
                    data: {
                        toggle: 'dropdown'
                    }
                }), ui.dropdown([ui.buttonGroup({
                    className: 'note-align',
                    children: [justifyLeft, justifyCenter, justifyRight, justifyFull]
                }), ui.buttonGroup({
                    className: 'note-list',
                    children: [outdent, indent]
                })])]).render();
            });

            context.memo('button.height', function () {
                return ui.buttonGroup([ui.button({
                    className: '',
                    contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),
                    tooltip: lang.font.height,
                    data: {
                        toggle: 'dropdown'
                    }
                }), ui.dropdownCheck({
                    items: options.lineHeights,
                    checkClassName: options.icons.menuCheck,
                    className: 'dropdown-line-height',
                    click: context.createInvokeHandler('editor.lineHeight')
                })]).render();
            });

            context.memo('button.table', function () {
                return ui.buttonGroup([ui.button({
                    className: '',
                    contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),
                    tooltip: lang.table.table,
                    data: {
                        toggle: 'dropdown'
                    }
                }), ui.dropdown({
                    className: 'note-table',
                    items: ['<div class="note-dimension-picker">', '  <div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"/>', '  <div class="note-dimension-picker-highlighted"/>', '  <div class="note-dimension-picker-unhighlighted"/>', '</div>', '<div class="note-dimension-display">1 x 1</div>'].join('')
                })], {
                    callback: function ($node) {
                        var $catcher = $node.find('.note-dimension-picker-mousecatcher');
                        $catcher.css({
                            width: options.insertTableMaxSize.col + 'em',
                            height: options.insertTableMaxSize.row + 'em'
                        }).mousedown(context.createInvokeHandler('editor.insertTable')).on('mousemove', self.tableMoveHandler);
                    }
                }).render();
            });

            context.memo('button.link', function () {
                return ui.button({
                    contents: ui.icon(options.icons.link),
                    tooltip: lang.link.link + representShortcut('linkDialog.show'),
                    click: context.createInvokeHandler('linkDialog.show')
                }).render();
            });

            context.memo('button.picture', function () {
                return ui.button({
                    contents: ui.icon(options.icons.picture),
                    tooltip: lang.image.image,
                    click: context.createInvokeHandler('imageDialog.show')
                }).render();
            });

            context.memo('button.video', function () {
                return ui.button({
                    contents: ui.icon(options.icons.video),
                    tooltip: lang.video.video,
                    click: context.createInvokeHandler('videoDialog.show')
                }).render();
            });

            context.memo('button.hr', function () {
                return ui.button({
                    contents: ui.icon(options.icons.minus),
                    tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),
                    click: context.createInvokeHandler('editor.insertHorizontalRule')
                }).render();
            });

            context.memo('button.fullscreen', function () {
                return ui.button({
                    className: 'btn-fullscreen',
                    contents: ui.icon(options.icons.arrowsAlt),
                    tooltip: lang.options.fullscreen,
                    click: context.createInvokeHandler('fullscreen.toggle')
                }).render();
            });

            context.memo('button.codeview', function () {
                return ui.button({
                    className: 'btn-codeview',
                    contents: ui.icon(options.icons.code),
                    tooltip: lang.options.codeview,
                    click: context.createInvokeHandler('codeview.toggle')
                }).render();
            });

            context.memo('button.redo', function () {
                return ui.button({
                    contents: ui.icon(options.icons.redo),
                    tooltip: lang.history.redo + representShortcut('redo'),
                    click: context.createInvokeHandler('editor.redo')
                }).render();
            });

            context.memo('button.undo', function () {
                return ui.button({
                    contents: ui.icon(options.icons.undo),
                    tooltip: lang.history.undo + representShortcut('undo'),
                    click: context.createInvokeHandler('editor.undo')
                }).render();
            });

            context.memo('button.help', function () {
                return ui.button({
                    contents: ui.icon(options.icons.question),
                    tooltip: lang.options.help,
                    click: context.createInvokeHandler('helpDialog.show')
                }).render();
            });
        };

        /**
         * image : [
         *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],
         *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],
         *   ['remove', ['removeMedia']]
         * ],
         */
        this.addImagePopoverButtons = function () {
            // Image Size Buttons
            context.memo('button.imageSize100', function () {
                return ui.button({
                    contents: '<span class="note-fontsize-10">100%</span>',
                    tooltip: lang.image.resizeFull,
                    click: context.createInvokeHandler('editor.resize', '1')
                }).render();
            });
            context.memo('button.imageSize50', function () {
                return ui.button({
                    contents: '<span class="note-fontsize-10">50%</span>',
                    tooltip: lang.image.resizeHalf,
                    click: context.createInvokeHandler('editor.resize', '0.5')
                }).render();
            });
            context.memo('button.imageSize25', function () {
                return ui.button({
                    contents: '<span class="note-fontsize-10">25%</span>',
                    tooltip: lang.image.resizeQuarter,
                    click: context.createInvokeHandler('editor.resize', '0.25')
                }).render();
            });

            // Float Buttons
            context.memo('button.floatLeft', function () {
                return ui.button({
                    contents: ui.icon(options.icons.alignLeft),
                    tooltip: lang.image.floatLeft,
                    click: context.createInvokeHandler('editor.floatMe', 'left')
                }).render();
            });

            context.memo('button.floatRight', function () {
                return ui.button({
                    contents: ui.icon(options.icons.alignRight),
                    tooltip: lang.image.floatRight,
                    click: context.createInvokeHandler('editor.floatMe', 'right')
                }).render();
            });

            context.memo('button.floatNone', function () {
                return ui.button({
                    contents: ui.icon(options.icons.alignJustify),
                    tooltip: lang.image.floatNone,
                    click: context.createInvokeHandler('editor.floatMe', 'none')
                }).render();
            });

            // Remove Buttons
            context.memo('button.removeMedia', function () {
                return ui.button({
                    contents: ui.icon(options.icons.trash),
                    tooltip: lang.image.remove,
                    click: context.createInvokeHandler('editor.removeMedia')
                }).render();
            });
        };

        this.addLinkPopoverButtons = function () {
            context.memo('button.linkDialogShow', function () {
                return ui.button({
                    contents: ui.icon(options.icons.link),
                    tooltip: lang.link.edit,
                    click: context.createInvokeHandler('linkDialog.show')
                }).render();
            });

            context.memo('button.unlink', function () {
                return ui.button({
                    contents: ui.icon(options.icons.unlink),
                    tooltip: lang.link.unlink,
                    click: context.createInvokeHandler('editor.unlink')
                }).render();
            });
        };

        this.build = function ($container, groups) {
            for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {
                var group = groups[groupIdx];
                var groupName = group[0];
                var buttons = group[1];

                var $group = ui.buttonGroup({
                    className: 'note-' + groupName
                }).render();

                for (var idx = 0, len = buttons.length; idx < len; idx++) {
                    var button = context.memo('button.' + buttons[idx]);
                    if (button) {
                        $group.append(typeof button === 'function' ? button(context) : button);
                    }
                }
                $group.appendTo($container);
            }
        };

        this.updateCurrentStyle = function () {
            var styleInfo = context.invoke('editor.currentStyle');
            this.updateBtnStates({
                '.note-btn-bold': function () {
                    return styleInfo['font-bold'] === 'bold';
                },
                '.note-btn-italic': function () {
                    return styleInfo['font-italic'] === 'italic';
                },
                '.note-btn-underline': function () {
                    return styleInfo['font-underline'] === 'underline';
                },
                '.note-btn-subscript': function () {
                    return styleInfo['font-subscript'] === 'subscript';
                },
                '.note-btn-superscript': function () {
                    return styleInfo['font-superscript'] === 'superscript';
                },
                '.note-btn-strikethrough': function () {
                    return styleInfo['font-strikethrough'] === 'strikethrough';
                }
            });

            if (styleInfo['font-family']) {
                var fontNames = styleInfo['font-family'].split(',').map(function (name) {
                    return name.replace(/[\'\"]/g, '').replace(/\s+$/, '').replace(/^\s+/, '');
                });
                var fontName = list.find(fontNames, self.isFontInstalled);

                $toolbar.find('.dropdown-fontname li a').each(function () {
                    // always compare string to avoid creating another func.
                    var isChecked = $(this).data('value') + '' === fontName + '';
                    this.className = isChecked ? 'checked' : '';
                });
                $toolbar.find('.note-current-fontname').text(fontName);
            }

            if (styleInfo['font-size']) {
                var fontSize = styleInfo['font-size'];
                $toolbar.find('.dropdown-fontsize li a').each(function () {
                    // always compare with string to avoid creating another func.
                    var isChecked = $(this).data('value') + '' === fontSize + '';
                    this.className = isChecked ? 'checked' : '';
                });
                $toolbar.find('.note-current-fontsize').text(fontSize);
            }

            if (styleInfo['line-height']) {
                var lineHeight = styleInfo['line-height'];
                $toolbar.find('.dropdown-line-height li a').each(function () {
                    // always compare with string to avoid creating another func.
                    var isChecked = $(this).data('value') + '' === lineHeight + '';
                    this.className = isChecked ? 'checked' : '';
                });
            }
        };

        this.updateBtnStates = function (infos) {
            $.each(infos, function (selector, pred) {
                ui.toggleBtnActive($toolbar.find(selector), pred());
            });
        };

        this.tableMoveHandler = function (event) {
            var PX_PER_EM = 18;
            var $picker = $(event.target.parentNode); // target is mousecatcher
            var $dimensionDisplay = $picker.next();
            var $catcher = $picker.find('.note-dimension-picker-mousecatcher');
            var $highlighted = $picker.find('.note-dimension-picker-highlighted');
            var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');

            var posOffset;
            // HTML5 with jQuery - e.offsetX is undefined in Firefox
            if (event.offsetX === undefined) {
                var posCatcher = $(event.target).offset();
                posOffset = {
                    x: event.pageX - posCatcher.left,
                    y: event.pageY - posCatcher.top
                };
            } else {
                posOffset = {
                    x: event.offsetX,
                    y: event.offsetY
                };
            }

            var dim = {
                c: Math.ceil(posOffset.x / PX_PER_EM) || 1,
                r: Math.ceil(posOffset.y / PX_PER_EM) || 1
            };

            $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });
            $catcher.data('value', dim.c + 'x' + dim.r);

            if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {
                $unhighlighted.css({ width: dim.c + 1 + 'em' });
            }

            if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {
                $unhighlighted.css({ height: dim.r + 1 + 'em' });
            }

            $dimensionDisplay.html(dim.c + ' x ' + dim.r);
        };
    };

    var Toolbar = function (context) {
        var ui = $.summernote.ui;

        var $note = context.layoutInfo.note;
        var $toolbar = context.layoutInfo.toolbar;
        var options = context.options;

        this.shouldInitialize = function () {
            return !options.airMode;
        };

        this.initialize = function () {
            options.toolbar = options.toolbar || [];

            if (!options.toolbar.length) {
                $toolbar.hide();
            } else {
                context.invoke('buttons.build', $toolbar, options.toolbar);
            }

            if (options.toolbarContainer) {
                $toolbar.appendTo(options.toolbarContainer);
            }

            $note.on('summernote.keyup summernote.mouseup summernote.change', function () {
                context.invoke('buttons.updateCurrentStyle');
            });

            context.invoke('buttons.updateCurrentStyle');
        };

        this.destroy = function () {
            $toolbar.children().remove();
        };

        this.updateFullscreen = function (isFullscreen) {
            ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);
        };

        this.updateCodeview = function (isCodeview) {
            ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);
            if (isCodeview) {
                this.deactivate();
            } else {
                this.activate();
            }
        };

        this.activate = function (isIncludeCodeview) {
            var $btn = $toolbar.find('button');
            if (!isIncludeCodeview) {
                $btn = $btn.not('.btn-codeview');
            }
            ui.toggleBtn($btn, true);
        };

        this.deactivate = function (isIncludeCodeview) {
            var $btn = $toolbar.find('button');
            if (!isIncludeCodeview) {
                $btn = $btn.not('.btn-codeview');
            }
            ui.toggleBtn($btn, false);
        };
    };

    var LinkDialog = function (context) {
        var self = this;
        var ui = $.summernote.ui;

        var $editor = context.layoutInfo.editor;
        var options = context.options;
        var lang = options.langInfo;

        this.initialize = function () {
            var $container = options.dialogsInBody ? $(document.body) : $editor;

            var body = '<div class="form-group">' + '<label>' + lang.link.textToDisplay + '</label>' + '<input class="note-link-text form-control" type="text" />' + '</div>' + '<div class="form-group">' + '<label>' + lang.link.url + '</label>' + '<input class="note-link-url form-control" type="text" value="http://" />' + '</div>' + (!options.disableLinkTarget ? '<div class="checkbox">' + '<label>' + '<input type="checkbox" checked> ' + lang.link.openInNewWindow + '</label>' + '</div>' : '');
            var footer = '<button href="#" class="btn btn-primary note-link-btn disabled" disabled>' + lang.link.insert + '</button>';

            this.$dialog = ui.dialog({
                className: 'link-dialog',
                title: lang.link.insert,
                fade: options.dialogsFade,
                body: body,
                footer: footer
            }).render().appendTo($container);
        };

        this.destroy = function () {
            ui.hideDialog(this.$dialog);
            this.$dialog.remove();
        };

        this.bindEnterKey = function ($input, $btn) {
            $input.on('keypress', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    $btn.trigger('click');
                }
            });
        };

        /**
         * toggle update button
         */
        this.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {
            ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
        };

        /**
         * Show link dialog and set event handlers on dialog controls.
         *
         * @param {Object} linkInfo
         * @return {Promise}
         */
        this.showLinkDialog = function (linkInfo) {
            return $.Deferred(function (deferred) {
                var $linkText = self.$dialog.find('.note-link-text'),
                    $linkUrl = self.$dialog.find('.note-link-url'),
                    $linkBtn = self.$dialog.find('.note-link-btn'),
                    $openInNewWindow = self.$dialog.find('input[type=checkbox]');

                ui.onDialogShown(self.$dialog, function () {
                    context.triggerEvent('dialog.shown');

                    // if no url was given, copy text to url
                    if (!linkInfo.url) {
                        linkInfo.url = linkInfo.text;
                    }

                    $linkText.val(linkInfo.text);

                    var handleLinkTextUpdate = function () {
                        self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                        // if linktext was modified by keyup,
                        // stop cloning text from linkUrl
                        linkInfo.text = $linkText.val();
                    };

                    $linkText.on('input', handleLinkTextUpdate).on('paste', function () {
                        setTimeout(handleLinkTextUpdate, 0);
                    });

                    var handleLinkUrlUpdate = function () {
                        self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                        // display same link on `Text to display` input
                        // when create a new link
                        if (!linkInfo.text) {
                            $linkText.val($linkUrl.val());
                        }
                    };

                    $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {
                        setTimeout(handleLinkUrlUpdate, 0);
                    }).val(linkInfo.url).trigger('focus');

                    self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                    self.bindEnterKey($linkUrl, $linkBtn);
                    self.bindEnterKey($linkText, $linkBtn);

                    $openInNewWindow.prop('checked', linkInfo.isNewWindow);

                    $linkBtn.one('click', function (event) {
                        event.preventDefault();

                        deferred.resolve({
                            range: linkInfo.range,
                            url: $linkUrl.val(),
                            text: $linkText.val(),
                            isNewWindow: $openInNewWindow.is(':checked')
                        });
                        self.$dialog.modal('hide');
                    });
                });

                ui.onDialogHidden(self.$dialog, function () {
                    // detach events
                    $linkText.off('input paste keypress');
                    $linkUrl.off('input paste keypress');
                    $linkBtn.off('click');

                    if (deferred.state() === 'pending') {
                        deferred.reject();
                    }
                });

                ui.showDialog(self.$dialog);
            }).promise();
        };

        /**
         * @param {Object} layoutInfo
         */
        this.show = function () {
            var linkInfo = context.invoke('editor.getLinkInfo');

            context.invoke('editor.saveRange');
            this.showLinkDialog(linkInfo).then(function (linkInfo) {
                context.invoke('editor.restoreRange');
                context.invoke('editor.createLink', linkInfo);
            }).fail(function () {
                context.invoke('editor.restoreRange');
            });
        };
        context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);
    };

    var LinkPopover = function (context) {
        var self = this;
        var ui = $.summernote.ui;

        var options = context.options;

        this.events = {
            'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {
                self.update();
            },
            'summernote.dialog.shown': function () {
                self.hide();
            }
        };

        this.shouldInitialize = function () {
            return !list.isEmpty(options.popover.link);
        };

        this.initialize = function () {
            this.$popover = ui.popover({
                className: 'note-link-popover',
                callback: function ($node) {
                    var $content = $node.find('.popover-content');
                    $content.prepend('<span><a target="_blank"></a>&nbsp;</span>');
                }
            }).render().appendTo('body');
            var $content = this.$popover.find('.popover-content');

            context.invoke('buttons.build', $content, options.popover.link);
        };

        this.destroy = function () {
            this.$popover.remove();
        };

        this.update = function () {
            // Prevent focusing on editable when invoke('code') is executed
            if (!context.invoke('editor.hasFocus')) {
                this.hide();
                return;
            }

            var rng = context.invoke('editor.createRange');
            if (rng.isCollapsed() && rng.isOnAnchor()) {
                var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                var href = $(anchor).attr('href');
                this.$popover.find('a').attr('href', href).html(href);

                var pos = dom.posFromPlaceholder(anchor);
                this.$popover.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top
                });
            } else {
                this.hide();
            }
        };

        this.hide = function () {
            this.$popover.hide();
        };
    };

    var ImageDialog = function (context) {
        var self = this;
        var ui = $.summernote.ui;

        var $editor = context.layoutInfo.editor;
        var options = context.options;
        var lang = options.langInfo;

        this.initialize = function () {
            var $container = options.dialogsInBody ? $(document.body) : $editor;

            var imageLimitation = '';
            if (options.maximumImageFileSize) {
                var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));
                var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 + ' ' + ' KMGTP'[unit] + 'B';
                imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';
            }

            var body = '<div class="form-group note-group-select-from-files">' + '<label>' + lang.image.selectFromFiles + '</label>' + '<input class="note-image-input form-control" type="file" name="files" accept="image/*" multiple="multiple" />' + imageLimitation + '</div>' + '<div class="form-group note-group-image-url" style="overflow:auto;">' + '<label>' + lang.image.url + '</label>' + '<input class="note-image-url form-control col-md-12" type="text" />' + '</div>';
            var footer = '<button href="#" class="btn btn-primary note-image-btn disabled" disabled>' + lang.image.insert + '</button>';

            this.$dialog = ui.dialog({
                title: lang.image.insert,
                fade: options.dialogsFade,
                body: body,
                footer: footer
            }).render().appendTo($container);
        };

        this.destroy = function () {
            ui.hideDialog(this.$dialog);
            this.$dialog.remove();
        };

        this.bindEnterKey = function ($input, $btn) {
            $input.on('keypress', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    $btn.trigger('click');
                }
            });
        };

        this.show = function () {
            context.invoke('editor.saveRange');
            this.showImageDialog().then(function (data) {
                // [workaround] hide dialog before restore range for IE range focus
                ui.hideDialog(self.$dialog);
                context.invoke('editor.restoreRange');

                if (typeof data === 'string') {
                    // image url
                    context.invoke('editor.insertImage', data);
                } else {
                    // array of files
                    context.invoke('editor.insertImagesOrCallback', data);
                }
            }).fail(function () {
                context.invoke('editor.restoreRange');
            });
        };

        /**
         * show image dialog
         *
         * @param {jQuery} $dialog
         * @return {Promise}
         */
        this.showImageDialog = function () {
            return $.Deferred(function (deferred) {
                var $imageInput = self.$dialog.find('.note-image-input'),
                    $imageUrl = self.$dialog.find('.note-image-url'),
                    $imageBtn = self.$dialog.find('.note-image-btn');

                ui.onDialogShown(self.$dialog, function () {
                    context.triggerEvent('dialog.shown');

                    // Cloning imageInput to clear element.
                    $imageInput.replaceWith($imageInput.clone().on('change', function () {
                        deferred.resolve(this.files || this.value);
                    }).val(''));

                    $imageBtn.click(function (event) {
                        event.preventDefault();

                        deferred.resolve($imageUrl.val());
                    });

                    $imageUrl.on('keyup paste', function () {
                        var url = $imageUrl.val();
                        ui.toggleBtn($imageBtn, url);
                    }).val('').trigger('focus');
                    self.bindEnterKey($imageUrl, $imageBtn);
                });

                ui.onDialogHidden(self.$dialog, function () {
                    $imageInput.off('change');
                    $imageUrl.off('keyup paste keypress');
                    $imageBtn.off('click');

                    if (deferred.state() === 'pending') {
                        deferred.reject();
                    }
                });

                ui.showDialog(self.$dialog);
            });
        };
    };

    var ImagePopover = function (context) {
        var ui = $.summernote.ui;

        var options = context.options;

        this.shouldInitialize = function () {
            return !list.isEmpty(options.popover.image);
        };

        this.initialize = function () {
            this.$popover = ui.popover({
                className: 'note-image-popover'
            }).render().appendTo('body');
            var $content = this.$popover.find('.popover-content');

            context.invoke('buttons.build', $content, options.popover.image);
        };

        this.destroy = function () {
            this.$popover.remove();
        };

        this.update = function (target) {
            if (dom.isImg(target)) {
                var pos = dom.posFromPlaceholder(target);
                this.$popover.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top
                });
            } else {
                this.hide();
            }
        };

        this.hide = function () {
            this.$popover.hide();
        };
    };

    var VideoDialog = function (context) {
        var self = this;
        var ui = $.summernote.ui;

        var $editor = context.layoutInfo.editor;
        var options = context.options;
        var lang = options.langInfo;

        this.initialize = function () {
            var $container = options.dialogsInBody ? $(document.body) : $editor;

            var body = '<div class="form-group row-fluid">' + '<label>' + lang.video.url + ' <small class="text-muted">' + lang.video.providers + '</small></label>' + '<input class="note-video-url form-control span12" type="text" />' + '</div>';
            var footer = '<button href="#" class="btn btn-primary note-video-btn disabled" disabled>' + lang.video.insert + '</button>';

            this.$dialog = ui.dialog({
                title: lang.video.insert,
                fade: options.dialogsFade,
                body: body,
                footer: footer
            }).render().appendTo($container);
        };

        this.destroy = function () {
            ui.hideDialog(this.$dialog);
            this.$dialog.remove();
        };

        this.bindEnterKey = function ($input, $btn) {
            $input.on('keypress', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    $btn.trigger('click');
                }
            });
        };

        this.createVideoNode = function (url) {
            // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)
            var ytRegExp = /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/;
            var ytMatch = url.match(ytRegExp);

            var igRegExp = /(?:www\.|\/\/)instagram\.com\/p\/(.[a-zA-Z0-9_-]*)/;
            var igMatch = url.match(igRegExp);

            var vRegExp = /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/;
            var vMatch = url.match(vRegExp);

            var vimRegExp = /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*([0-9]{6,11})[?]?.*/;
            var vimMatch = url.match(vimRegExp);

            var dmRegExp = /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/;
            var dmMatch = url.match(dmRegExp);

            var youkuRegExp = /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/;
            var youkuMatch = url.match(youkuRegExp);

            var mp4RegExp = /^.+.(mp4|m4v)$/;
            var mp4Match = url.match(mp4RegExp);

            var oggRegExp = /^.+.(ogg|ogv)$/;
            var oggMatch = url.match(oggRegExp);

            var webmRegExp = /^.+.(webm)$/;
            var webmMatch = url.match(webmRegExp);

            var $video;
            if (ytMatch && ytMatch[1].length === 11) {
                var youtubeId = ytMatch[1];
                $video = $('<iframe>').attr('frameborder', 0).attr('src', '//www.youtube.com/embed/' + youtubeId).attr('width', '640').attr('height', '360');
            } else if (igMatch && igMatch[0].length) {
                $video = $('<iframe>').attr('frameborder', 0).attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/').attr('width', '612').attr('height', '710').attr('scrolling', 'no').attr('allowtransparency', 'true');
            } else if (vMatch && vMatch[0].length) {
                $video = $('<iframe>').attr('frameborder', 0).attr('src', vMatch[0] + '/embed/simple').attr('width', '600').attr('height', '600').attr('class', 'vine-embed');
            } else if (vimMatch && vimMatch[3].length) {
                $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('src', '//player.vimeo.com/video/' + vimMatch[3]).attr('width', '640').attr('height', '360');
            } else if (dmMatch && dmMatch[2].length) {
                $video = $('<iframe>').attr('frameborder', 0).attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2]).attr('width', '640').attr('height', '360');
            } else if (youkuMatch && youkuMatch[1].length) {
                $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('height', '498').attr('width', '510').attr('src', '//player.youku.com/embed/' + youkuMatch[1]);
            } else if (mp4Match || oggMatch || webmMatch) {
                $video = $('<video controls>').attr('src', url).attr('width', '640').attr('height', '360');
            } else {
                // this is not a known video link. Now what, Cat? Now what?
                return false;
            }

            $video.addClass('note-video-clip');

            return $video[0];
        };

        this.show = function () {
            var text = context.invoke('editor.getSelectedText');
            context.invoke('editor.saveRange');
            this.showVideoDialog(text).then(function (url) {
                // [workaround] hide dialog before restore range for IE range focus
                ui.hideDialog(self.$dialog);
                context.invoke('editor.restoreRange');

                // build node
                var $node = self.createVideoNode(url);

                if ($node) {
                    // insert video node
                    context.invoke('editor.insertNode', $node);
                }
            }).fail(function () {
                context.invoke('editor.restoreRange');
            });
        };

        /**
         * show image dialog
         *
         * @param {jQuery} $dialog
         * @return {Promise}
         */
        this.showVideoDialog = function (text) {
            return $.Deferred(function (deferred) {
                var $videoUrl = self.$dialog.find('.note-video-url'),
                    $videoBtn = self.$dialog.find('.note-video-btn');

                ui.onDialogShown(self.$dialog, function () {
                    context.triggerEvent('dialog.shown');

                    $videoUrl.val(text).on('input', function () {
                        ui.toggleBtn($videoBtn, $videoUrl.val());
                    }).trigger('focus');

                    $videoBtn.click(function (event) {
                        event.preventDefault();

                        deferred.resolve($videoUrl.val());
                    });

                    self.bindEnterKey($videoUrl, $videoBtn);
                });

                ui.onDialogHidden(self.$dialog, function () {
                    $videoUrl.off('input');
                    $videoBtn.off('click');

                    if (deferred.state() === 'pending') {
                        deferred.reject();
                    }
                });

                ui.showDialog(self.$dialog);
            });
        };
    };

    var HelpDialog = function (context) {
        var self = this;
        var ui = $.summernote.ui;

        var $editor = context.layoutInfo.editor;
        var options = context.options;
        var lang = options.langInfo;

        this.createShortCutList = function () {
            var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];
            return Object.keys(keyMap).map(function (key) {
                var command = keyMap[key];
                var $row = $('<div><div class="help-list-item"/></div>');
                $row.append($('<label><kbd>' + key + '</kdb></label>').css({
                    'width': 180,
                    'margin-right': 10
                })).append($('<span/>').html(context.memo('help.' + command) || command));
                return $row.html();
            }).join('');
        };

        this.initialize = function () {
            var $container = options.dialogsInBody ? $(document.body) : $editor;

            var body = ['<p class="text-center">',
            // '<a href="http://summernote.org/" target="_blank">Summernote 0.8.2</a>  ',
            // '<a href="https://github.com/summernote/summernote" target="_blank">Project</a>  ',
            // '<a href="https://github.com/summernote/summernote/issues" target="_blank">Issues</a>',
            '</p>'].join('');

            this.$dialog = ui.dialog({
                title: lang.options.help,
                fade: options.dialogsFade,
                body: this.createShortCutList(),
                footer: body,
                callback: function ($node) {
                    $node.find('.modal-body').css({
                        'max-height': 300,
                        'overflow-y': 'scroll'
                    });
                }
            }).render().appendTo($container);
        };

        this.destroy = function () {
            ui.hideDialog(this.$dialog);
            this.$dialog.remove();
        };

        /**
         * show help dialog
         *
         * @return {Promise}
         */
        this.showHelpDialog = function () {
            return $.Deferred(function (deferred) {
                ui.onDialogShown(self.$dialog, function () {
                    context.triggerEvent('dialog.shown');
                    deferred.resolve();
                });
                ui.showDialog(self.$dialog);
            }).promise();
        };

        this.show = function () {
            context.invoke('editor.saveRange');
            this.showHelpDialog().then(function () {
                context.invoke('editor.restoreRange');
            });
        };
    };

    var AirPopover = function (context) {
        var self = this;
        var ui = $.summernote.ui;

        var options = context.options;

        var AIR_MODE_POPOVER_X_OFFSET = 20;

        this.events = {
            'summernote.keyup summernote.mouseup summernote.scroll': function () {
                self.update();
            },
            'summernote.change summernote.dialog.shown': function () {
                self.hide();
            },
            'summernote.focusout': function (we, e) {
                // [workaround] Firefox doesn't support relatedTarget on focusout
                //  - Ignore hide action on focus out in FF.
                if (agent.isFF) {
                    return;
                }

                if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {
                    self.hide();
                }
            }
        };

        this.shouldInitialize = function () {
            return options.airMode && !list.isEmpty(options.popover.air);
        };

        this.initialize = function () {
            this.$popover = ui.popover({
                className: 'note-air-popover'
            }).render().appendTo('body');
            var $content = this.$popover.find('.popover-content');

            context.invoke('buttons.build', $content, options.popover.air);
        };

        this.destroy = function () {
            this.$popover.remove();
        };

        this.update = function () {
            var styleInfo = context.invoke('editor.currentStyle');
            if (styleInfo.range && !styleInfo.range.isCollapsed()) {
                var rect = list.last(styleInfo.range.getClientRects());
                if (rect) {
                    var bnd = func.rect2bnd(rect);
                    this.$popover.css({
                        display: 'block',
                        left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,
                        top: bnd.top + bnd.height
                    });
                }
            } else {
                this.hide();
            }
        };

        this.hide = function () {
            this.$popover.hide();
        };
    };

    var HintPopover = function (context) {
        var self = this;
        var ui = $.summernote.ui;

        var POPOVER_DIST = 5;
        var hint = context.options.hint || [];
        var direction = context.options.hintDirection || 'bottom';
        var hints = $.isArray(hint) ? hint : [hint];

        this.events = {
            'summernote.keyup': function (we, e) {
                if (!e.isDefaultPrevented()) {
                    self.handleKeyup(e);
                }
            },
            'summernote.keydown': function (we, e) {
                self.handleKeydown(e);
            },
            'summernote.dialog.shown': function () {
                self.hide();
            }
        };

        this.shouldInitialize = function () {
            return hints.length > 0;
        };

        this.initialize = function () {
            this.lastWordRange = null;
            this.$popover = ui.popover({
                className: 'note-hint-popover',
                hideArrow: true,
                direction: ''
            }).render().appendTo('body');

            this.$popover.hide();

            this.$content = this.$popover.find('.popover-content');

            this.$content.on('click', '.note-hint-item', function () {
                self.$content.find('.active').removeClass('active');
                $(this).addClass('active');
                self.replace();
            });
        };

        this.destroy = function () {
            this.$popover.remove();
        };

        this.selectItem = function ($item) {
            this.$content.find('.active').removeClass('active');
            if (!$item.length) {
                return;
            }
            $item.addClass('active');

            this.$content[0].scrollTop = $item[0].offsetTop - this.$content.innerHeight() / 2;
        };

        this.moveDown = function () {
            var $current = this.$content.find('.note-hint-item.active');
            var $next = $current.next();

            if ($next.length) {
                this.selectItem($next);
            } else {
                var $nextGroup = $current.parent().next();

                if (!$nextGroup.length) {
                    $nextGroup = this.$content.find('.note-hint-group').first();
                }

                this.selectItem($nextGroup.find('.note-hint-item').first());
            }
        };

        this.moveUp = function () {
            var $current = this.$content.find('.note-hint-item.active');
            var $prev = $current.prev();

            if ($prev.length) {
                this.selectItem($prev);
            } else {
                var $prevGroup = $current.parent().prev();

                if (!$prevGroup.length) {
                    $prevGroup = this.$content.find('.note-hint-group').last();
                }

                this.selectItem($prevGroup.find('.note-hint-item').last());
            }
        };

        this.replace = function () {
            var $item = this.$content.find('.note-hint-item.active');

            if ($item.length) {
                var node = this.nodeFromItem($item);
                this.lastWordRange.insertNode(node);
                range.createFromNode(node).collapse().select();

                this.lastWordRange = null;
                this.hide();
                context.invoke('editor.focus');
            }
        };

        this.nodeFromItem = function ($item) {
            var hint = hints[$item.data('index')];
            var item = $item.data('item');
            var node = hint.content ? hint.content(item) : item;
            if (typeof node === 'string') {
                node = dom.createText(node);
            }
            return node;
        };

        this.createItemTemplates = function (hintIdx, items) {
            var hint = hints[hintIdx];
            return items.map(function (item, idx) {
                var $item = $('<div class="note-hint-item"/>');
                $item.append(hint.template ? hint.template(item) : item + '');
                $item.data({
                    'index': hintIdx,
                    'item': item
                });

                if (hintIdx === 0 && idx === 0) {
                    $item.addClass('active');
                }
                return $item;
            });
        };

        this.handleKeydown = function (e) {
            if (!this.$popover.is(':visible')) {
                return;
            }

            if (e.keyCode === key.code.ENTER) {
                e.preventDefault();
                this.replace();
            } else if (e.keyCode === key.code.UP) {
                e.preventDefault();
                this.moveUp();
            } else if (e.keyCode === key.code.DOWN) {
                e.preventDefault();
                this.moveDown();
            }
        };

        this.searchKeyword = function (index, keyword, callback) {
            var hint = hints[index];
            if (hint && hint.match.test(keyword) && hint.search) {
                var matches = hint.match.exec(keyword);
                hint.search(matches[1], callback);
            } else {
                callback();
            }
        };

        this.createGroup = function (idx, keyword) {
            var $group = $('<div class="note-hint-group note-hint-group-' + idx + '"/>');
            this.searchKeyword(idx, keyword, function (items) {
                items = items || [];
                if (items.length) {
                    $group.html(self.createItemTemplates(idx, items));
                    self.show();
                }
            });

            return $group;
        };

        this.handleKeyup = function (e) {
            if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {
                if (e.keyCode === key.code.ENTER) {
                    if (this.$popover.is(':visible')) {}
                }
            } else {
                var wordRange = context.invoke('editor.createRange').getWordRange();
                var keyword = wordRange.toString();
                if (hints.length && keyword) {
                    this.$content.empty();

                    var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));
                    if (bnd) {

                        this.$popover.hide();

                        this.lastWordRange = wordRange;

                        hints.forEach(function (hint, idx) {
                            if (hint.match.test(keyword)) {
                                self.createGroup(idx, keyword).appendTo(self.$content);
                            }
                        });

                        // set position for popover after group is created
                        if (direction === 'top') {
                            this.$popover.css({
                                left: bnd.left,
                                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST
                            });
                        } else {
                            this.$popover.css({
                                left: bnd.left,
                                top: bnd.top + bnd.height + POPOVER_DIST
                            });
                        }
                    }
                } else {
                    this.hide();
                }
            }
        };

        this.show = function () {
            this.$popover.show();
        };

        this.hide = function () {
            this.$popover.hide();
        };
    };

    $.summernote = $.extend($.summernote, {
        version: '0.8.2',
        ui: ui,
        dom: dom,

        plugins: {},

        options: {
            modules: {
                'editor': Editor,
                'clipboard': Clipboard,
                'dropzone': Dropzone,
                'codeview': Codeview,
                'statusbar': Statusbar,
                'fullscreen': Fullscreen,
                'handle': Handle,
                // FIXME: HintPopover must be front of autolink
                //  - Script error about range when Enter key is pressed on hint popover
                'hintPopover': HintPopover,
                'autoLink': AutoLink,
                'autoSync': AutoSync,
                'placeholder': Placeholder,
                'buttons': Buttons,
                'toolbar': Toolbar,
                'linkDialog': LinkDialog,
                'linkPopover': LinkPopover,
                'imageDialog': ImageDialog,
                'imagePopover': ImagePopover,
                'videoDialog': VideoDialog,
                'helpDialog': HelpDialog,
                'airPopover': AirPopover
            },

            buttons: {},

            lang: 'en-US',

            // toolbar
            toolbar: [['style', ['style']], ['font', ['bold', 'underline', 'clear']], ['fontname', ['fontname']], ['color', ['color']], ['para', ['ul', 'ol', 'paragraph']], ['table', ['table']], ['insert', ['link', 'picture', 'video']], ['view', ['fullscreen', 'codeview', 'help']]],

            // popover
            popover: {
                image: [['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']], ['float', ['floatLeft', 'floatRight', 'floatNone']], ['remove', ['removeMedia']]],
                link: [['link', ['linkDialogShow', 'unlink']]],
                air: [['color', ['color']], ['font', ['bold', 'underline', 'clear']], ['para', ['ul', 'paragraph']], ['table', ['table']], ['insert', ['link', 'picture']]]
            },

            // air mode: inline editor
            airMode: false,

            width: null,
            height: null,

            focus: false,
            tabSize: 4,
            styleWithSpan: true,
            shortcuts: true,
            textareaAutoSync: true,
            direction: null,

            styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],

            fontNames: ['Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande', 'Tahoma', 'Times New Roman', 'Verdana'],

            fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],

            // pallete colors(n x n)
            colors: [['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'], ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'], ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'], ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'], ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'], ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'], ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'], ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']],

            lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],

            tableClassName: 'table table-bordered',

            insertTableMaxSize: {
                col: 10,
                row: 10
            },

            dialogsInBody: false,
            dialogsFade: false,

            maximumImageFileSize: null,

            callbacks: {
                onInit: null,
                onFocus: null,
                onBlur: null,
                onEnter: null,
                onKeyup: null,
                onKeydown: null,
                onImageUpload: null,
                onImageUploadError: null
            },

            codemirror: {
                mode: 'text/html',
                htmlMode: true,
                lineNumbers: true
            },

            keyMap: {
                pc: {
                    'ENTER': 'insertParagraph',
                    'CTRL+Z': 'undo',
                    'CTRL+Y': 'redo',
                    'TAB': 'tab',
                    'SHIFT+TAB': 'untab',
                    'CTRL+B': 'bold',
                    'CTRL+I': 'italic',
                    'CTRL+U': 'underline',
                    'CTRL+SHIFT+S': 'strikethrough',
                    'CTRL+BACKSLASH': 'removeFormat',
                    'CTRL+SHIFT+L': 'justifyLeft',
                    'CTRL+SHIFT+E': 'justifyCenter',
                    'CTRL+SHIFT+R': 'justifyRight',
                    'CTRL+SHIFT+J': 'justifyFull',
                    'CTRL+SHIFT+NUM7': 'insertUnorderedList',
                    'CTRL+SHIFT+NUM8': 'insertOrderedList',
                    'CTRL+LEFTBRACKET': 'outdent',
                    'CTRL+RIGHTBRACKET': 'indent',
                    'CTRL+NUM0': 'formatPara',
                    'CTRL+NUM1': 'formatH1',
                    'CTRL+NUM2': 'formatH2',
                    'CTRL+NUM3': 'formatH3',
                    'CTRL+NUM4': 'formatH4',
                    'CTRL+NUM5': 'formatH5',
                    'CTRL+NUM6': 'formatH6',
                    'CTRL+ENTER': 'insertHorizontalRule',
                    'CTRL+K': 'linkDialog.show'
                },

                mac: {
                    'ENTER': 'insertParagraph',
                    'CMD+Z': 'undo',
                    'CMD+SHIFT+Z': 'redo',
                    'TAB': 'tab',
                    'SHIFT+TAB': 'untab',
                    'CMD+B': 'bold',
                    'CMD+I': 'italic',
                    'CMD+U': 'underline',
                    'CMD+SHIFT+S': 'strikethrough',
                    'CMD+BACKSLASH': 'removeFormat',
                    'CMD+SHIFT+L': 'justifyLeft',
                    'CMD+SHIFT+E': 'justifyCenter',
                    'CMD+SHIFT+R': 'justifyRight',
                    'CMD+SHIFT+J': 'justifyFull',
                    'CMD+SHIFT+NUM7': 'insertUnorderedList',
                    'CMD+SHIFT+NUM8': 'insertOrderedList',
                    'CMD+LEFTBRACKET': 'outdent',
                    'CMD+RIGHTBRACKET': 'indent',
                    'CMD+NUM0': 'formatPara',
                    'CMD+NUM1': 'formatH1',
                    'CMD+NUM2': 'formatH2',
                    'CMD+NUM3': 'formatH3',
                    'CMD+NUM4': 'formatH4',
                    'CMD+NUM5': 'formatH5',
                    'CMD+NUM6': 'formatH6',
                    'CMD+ENTER': 'insertHorizontalRule',
                    'CMD+K': 'linkDialog.show'
                }
            },
            icons: {
                'alignCenter': 'fa fa-align-center',
                'alignJustify': 'fa fa-align-justify',
                'alignLeft': 'fa fa-align-left',
                'alignRight': 'fa fa-align-right',
                'indent': 'fa fa-indent',
                'outdent': 'fa fa-outdent',
                'arrowsAlt': 'fa fa-arrows-alt',
                'bold': 'fa fa-bold',
                'caret': 'fa icon-ml-ch fa-angle-down',
                'circle': 'fa fa-circle',
                'close': 'fa fa-close',
                'code': 'fa fa-code',
                'eraser': 'fa fa-eraser',
                'font': 'fa fa-font',
                'frame': 'fa fa-frame',
                'italic': 'fa fa-italic',
                'link': 'fa fa-link',
                'unlink': 'fa fa-chain-broken',
                'magic': 'fa fa-magic',
                'menuCheck': 'fa fa-check',
                'minus': 'fa fa-minus',
                'orderedlist': 'fa fa-list-ol',
                'pencil': 'fa fa-pencil',
                'picture': 'fa fa-image',
                'question': 'fa fa-question',
                'redo': 'icon-action-redo',
                'square': 'fa fa-square',
                'strikethrough': 'fa fa-strikethrough',
                'subscript': 'fa fa-subscript',
                'superscript': 'fa fa-superscript',
                'table': 'fa fa-table',
                'textHeight': 'fa fa-text-height',
                'trash': 'fa fa-trash',
                'underline': 'fa fa-underline',
                'undo': 'icon-action-undo',
                'unorderedlist': 'fa fa-list-ul',
                'video': 'fa fa-file-video-o'
            }
        }
    });
});
System.registerDynamic("github:istvan-ujjmeszaros/bootstrap-touchspin@3.1.2.json", [], true, function() {
  return {
    "main": "dist/jquery.bootstrap-touchspin.js"
  };
});

System.registerDynamic('github:istvan-ujjmeszaros/bootstrap-touchspin@3.1.2/dist/jquery.bootstrap-touchspin.js', [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = System.registry.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    /*
     *  Bootstrap TouchSpin - v3.1.2
     *  A mobile and touch friendly input spinner component for Bootstrap 3.
     *  http://www.virtuosoft.eu/code/bootstrap-touchspin/
     *
     *  Made by Istvn Ujj-Mszros
     *  Under Apache License v2.0 License
     */
    (function ($) {
      'use strict';

      var _currentSpinnerId = 0;

      function _scopedEventName(name, id) {
        return name + '.touchspin_' + id;
      }

      function _scopeEventNames(names, id) {
        return $.map(names, function (name) {
          return _scopedEventName(name, id);
        });
      }

      $.fn.TouchSpin = function (options) {

        if (options === 'destroy') {
          this.each(function () {
            var originalinput = $(this),
                originalinput_data = originalinput.data();
            $(document).off(_scopeEventNames(['mouseup', 'touchend', 'touchcancel', 'mousemove', 'touchmove', 'scroll', 'scrollstart'], originalinput_data.spinnerid).join(' '));
          });
          return;
        }

        var defaults = {
          min: 0,
          max: 100,
          initval: '',
          replacementval: '',
          step: 1,
          decimals: 0,
          stepinterval: 100,
          forcestepdivisibility: 'round', // none | floor | round | ceil
          stepintervaldelay: 500,
          verticalbuttons: false,
          verticalupclass: 'glyphicon glyphicon-chevron-up',
          verticaldownclass: 'glyphicon glyphicon-chevron-down',
          prefix: '',
          postfix: '',
          prefix_extraclass: '',
          postfix_extraclass: '',
          booster: true,
          boostat: 10,
          maxboostedstep: false,
          mousewheel: true,
          buttondown_class: 'btn btn-default',
          buttonup_class: 'btn btn-default',
          buttondown_txt: '-',
          buttonup_txt: '+'
        };

        var attributeMap = {
          min: 'min',
          max: 'max',
          initval: 'init-val',
          replacementval: 'replacement-val',
          step: 'step',
          decimals: 'decimals',
          stepinterval: 'step-interval',
          verticalbuttons: 'vertical-buttons',
          verticalupclass: 'vertical-up-class',
          verticaldownclass: 'vertical-down-class',
          forcestepdivisibility: 'force-step-divisibility',
          stepintervaldelay: 'step-interval-delay',
          prefix: 'prefix',
          postfix: 'postfix',
          prefix_extraclass: 'prefix-extra-class',
          postfix_extraclass: 'postfix-extra-class',
          booster: 'booster',
          boostat: 'boostat',
          maxboostedstep: 'max-boosted-step',
          mousewheel: 'mouse-wheel',
          buttondown_class: 'button-down-class',
          buttonup_class: 'button-up-class',
          buttondown_txt: 'button-down-txt',
          buttonup_txt: 'button-up-txt'
        };

        return this.each(function () {

          var settings,
              originalinput = $(this),
              originalinput_data = originalinput.data(),
              container,
              elements,
              value,
              downSpinTimer,
              upSpinTimer,
              downDelayTimeout,
              upDelayTimeout,
              spincount = 0,
              spinning = false;

          init();

          function init() {
            if (originalinput.data('alreadyinitialized')) {
              return;
            }

            originalinput.data('alreadyinitialized', true);
            _currentSpinnerId += 1;
            originalinput.data('spinnerid', _currentSpinnerId);

            if (!originalinput.is('input')) {
              console.log('Must be an input.');
              return;
            }

            _initSettings();
            _setInitval();
            _checkValue();
            _buildHtml();
            _initElements();
            _hideEmptyPrefixPostfix();
            _bindEvents();
            _bindEventsInterface();
            elements.input.css('display', 'block');
          }

          function _setInitval() {
            if (settings.initval !== '' && originalinput.val() === '') {
              originalinput.val(settings.initval);
            }
          }

          function changeSettings(newsettings) {
            _updateSettings(newsettings);
            _checkValue();

            var value = elements.input.val();

            if (value !== '') {
              value = Number(elements.input.val());
              elements.input.val(value.toFixed(settings.decimals));
            }
          }

          function _initSettings() {
            settings = $.extend({}, defaults, originalinput_data, _parseAttributes(), options);
          }

          function _parseAttributes() {
            var data = {};
            $.each(attributeMap, function (key, value) {
              var attrName = 'bts-' + value + '';
              if (originalinput.is('[data-' + attrName + ']')) {
                data[key] = originalinput.data(attrName);
              }
            });
            return data;
          }

          function _updateSettings(newsettings) {
            settings = $.extend({}, settings, newsettings);

            // Update postfix and prefix texts if those settings were changed.
            if (newsettings.postfix) {
              originalinput.parent().find('.bootstrap-touchspin-postfix').text(newsettings.postfix);
            }
            if (newsettings.prefix) {
              originalinput.parent().find('.bootstrap-touchspin-prefix').text(newsettings.prefix);
            }
          }

          function _buildHtml() {
            var initval = originalinput.val(),
                parentelement = originalinput.parent();

            if (initval !== '') {
              initval = Number(initval).toFixed(settings.decimals);
            }

            originalinput.data('initvalue', initval).val(initval);
            originalinput.addClass('form-control');

            if (parentelement.hasClass('input-group')) {
              _advanceInputGroup(parentelement);
            } else {
              _buildInputGroup();
            }
          }

          function _advanceInputGroup(parentelement) {
            parentelement.addClass('bootstrap-touchspin');

            var prev = originalinput.prev(),
                next = originalinput.next();

            var downhtml,
                uphtml,
                prefixhtml = '<span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span>',
                postfixhtml = '<span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span>';

            if (prev.hasClass('input-group-btn')) {
              downhtml = '<button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button>';
              prev.append(downhtml);
            } else {
              downhtml = '<span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span>';
              $(downhtml).insertBefore(originalinput);
            }

            if (next.hasClass('input-group-btn')) {
              uphtml = '<button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button>';
              next.prepend(uphtml);
            } else {
              uphtml = '<span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span>';
              $(uphtml).insertAfter(originalinput);
            }

            $(prefixhtml).insertBefore(originalinput);
            $(postfixhtml).insertAfter(originalinput);

            container = parentelement;
          }

          function _buildInputGroup() {
            var html;

            if (settings.verticalbuttons) {
              html = '<div class="input-group bootstrap-touchspin"><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn-vertical"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-up" type="button"><i class="' + settings.verticalupclass + '"></i></button><button class="' + settings.buttonup_class + ' bootstrap-touchspin-down" type="button"><i class="' + settings.verticaldownclass + '"></i></button></span></div>';
            } else {
              html = '<div class="input-group bootstrap-touchspin"><span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span></div>';
            }

            container = $(html).insertBefore(originalinput);

            $('.bootstrap-touchspin-prefix', container).after(originalinput);

            if (originalinput.hasClass('input-sm')) {
              container.addClass('input-group-sm');
            } else if (originalinput.hasClass('input-lg')) {
              container.addClass('input-group-lg');
            }
          }

          function _initElements() {
            elements = {
              down: $('.bootstrap-touchspin-down', container),
              up: $('.bootstrap-touchspin-up', container),
              input: $('input', container),
              prefix: $('.bootstrap-touchspin-prefix', container).addClass(settings.prefix_extraclass),
              postfix: $('.bootstrap-touchspin-postfix', container).addClass(settings.postfix_extraclass)
            };
          }

          function _hideEmptyPrefixPostfix() {
            if (settings.prefix === '') {
              elements.prefix.hide();
            }

            if (settings.postfix === '') {
              elements.postfix.hide();
            }
          }

          function _bindEvents() {
            originalinput.on('keydown', function (ev) {
              var code = ev.keyCode || ev.which;

              if (code === 38) {
                if (spinning !== 'up') {
                  upOnce();
                  startUpSpin();
                }
                ev.preventDefault();
              } else if (code === 40) {
                if (spinning !== 'down') {
                  downOnce();
                  startDownSpin();
                }
                ev.preventDefault();
              }
            });

            originalinput.on('keyup', function (ev) {
              var code = ev.keyCode || ev.which;

              if (code === 38) {
                stopSpin();
              } else if (code === 40) {
                stopSpin();
              }
            });

            originalinput.on('blur', function () {
              _checkValue();
            });

            elements.down.on('keydown', function (ev) {
              var code = ev.keyCode || ev.which;

              if (code === 32 || code === 13) {
                if (spinning !== 'down') {
                  downOnce();
                  startDownSpin();
                }
                ev.preventDefault();
              }
            });

            elements.down.on('keyup', function (ev) {
              var code = ev.keyCode || ev.which;

              if (code === 32 || code === 13) {
                stopSpin();
              }
            });

            elements.up.on('keydown', function (ev) {
              var code = ev.keyCode || ev.which;

              if (code === 32 || code === 13) {
                if (spinning !== 'up') {
                  upOnce();
                  startUpSpin();
                }
                ev.preventDefault();
              }
            });

            elements.up.on('keyup', function (ev) {
              var code = ev.keyCode || ev.which;

              if (code === 32 || code === 13) {
                stopSpin();
              }
            });

            elements.down.on('mousedown.touchspin', function (ev) {
              elements.down.off('touchstart.touchspin'); // android 4 workaround

              if (originalinput.is(':disabled')) {
                return;
              }

              downOnce();
              startDownSpin();

              ev.preventDefault();
              ev.stopPropagation();
            });

            elements.down.on('touchstart.touchspin', function (ev) {
              elements.down.off('mousedown.touchspin'); // android 4 workaround

              if (originalinput.is(':disabled')) {
                return;
              }

              downOnce();
              startDownSpin();

              ev.preventDefault();
              ev.stopPropagation();
            });

            elements.up.on('mousedown.touchspin', function (ev) {
              elements.up.off('touchstart.touchspin'); // android 4 workaround

              if (originalinput.is(':disabled')) {
                return;
              }

              upOnce();
              startUpSpin();

              ev.preventDefault();
              ev.stopPropagation();
            });

            elements.up.on('touchstart.touchspin', function (ev) {
              elements.up.off('mousedown.touchspin'); // android 4 workaround

              if (originalinput.is(':disabled')) {
                return;
              }

              upOnce();
              startUpSpin();

              ev.preventDefault();
              ev.stopPropagation();
            });

            elements.up.on('mouseout touchleave touchend touchcancel', function (ev) {
              if (!spinning) {
                return;
              }

              ev.stopPropagation();
              stopSpin();
            });

            elements.down.on('mouseout touchleave touchend touchcancel', function (ev) {
              if (!spinning) {
                return;
              }

              ev.stopPropagation();
              stopSpin();
            });

            elements.down.on('mousemove touchmove', function (ev) {
              if (!spinning) {
                return;
              }

              ev.stopPropagation();
              ev.preventDefault();
            });

            elements.up.on('mousemove touchmove', function (ev) {
              if (!spinning) {
                return;
              }

              ev.stopPropagation();
              ev.preventDefault();
            });

            $(document).on(_scopeEventNames(['mouseup', 'touchend', 'touchcancel'], _currentSpinnerId).join(' '), function (ev) {
              if (!spinning) {
                return;
              }

              ev.preventDefault();
              stopSpin();
            });

            $(document).on(_scopeEventNames(['mousemove', 'touchmove', 'scroll', 'scrollstart'], _currentSpinnerId).join(' '), function (ev) {
              if (!spinning) {
                return;
              }

              ev.preventDefault();
              stopSpin();
            });

            originalinput.on('mousewheel DOMMouseScroll', function (ev) {
              if (!settings.mousewheel || !originalinput.is(':focus')) {
                return;
              }

              var delta = ev.originalEvent.wheelDelta || -ev.originalEvent.deltaY || -ev.originalEvent.detail;

              ev.stopPropagation();
              ev.preventDefault();

              if (delta < 0) {
                downOnce();
              } else {
                upOnce();
              }
            });
          }

          function _bindEventsInterface() {
            originalinput.on('touchspin.uponce', function () {
              stopSpin();
              upOnce();
            });

            originalinput.on('touchspin.downonce', function () {
              stopSpin();
              downOnce();
            });

            originalinput.on('touchspin.startupspin', function () {
              startUpSpin();
            });

            originalinput.on('touchspin.startdownspin', function () {
              startDownSpin();
            });

            originalinput.on('touchspin.stopspin', function () {
              stopSpin();
            });

            originalinput.on('touchspin.updatesettings', function (e, newsettings) {
              changeSettings(newsettings);
            });
          }

          function _forcestepdivisibility(value) {
            switch (settings.forcestepdivisibility) {
              case 'round':
                return (Math.round(value / settings.step) * settings.step).toFixed(settings.decimals);
              case 'floor':
                return (Math.floor(value / settings.step) * settings.step).toFixed(settings.decimals);
              case 'ceil':
                return (Math.ceil(value / settings.step) * settings.step).toFixed(settings.decimals);
              default:
                return value;
            }
          }

          function _checkValue() {
            var val, parsedval, returnval;

            val = originalinput.val();

            if (val === '') {
              if (settings.replacementval !== '') {
                originalinput.val(settings.replacementval);
                originalinput.trigger('change');
              }
              return;
            }

            if (settings.decimals > 0 && val === '.') {
              return;
            }

            parsedval = parseFloat(val);

            if (isNaN(parsedval)) {
              if (settings.replacementval !== '') {
                parsedval = settings.replacementval;
              } else {
                parsedval = 0;
              }
            }

            returnval = parsedval;

            if (parsedval.toString() !== val) {
              returnval = parsedval;
            }

            if (parsedval < settings.min) {
              returnval = settings.min;
            }

            if (parsedval > settings.max) {
              returnval = settings.max;
            }

            returnval = _forcestepdivisibility(returnval);

            if (Number(val).toString() !== returnval.toString()) {
              originalinput.val(returnval);
              originalinput.trigger('change');
            }
          }

          function _getBoostedStep() {
            if (!settings.booster) {
              return settings.step;
            } else {
              var boosted = Math.pow(2, Math.floor(spincount / settings.boostat)) * settings.step;

              if (settings.maxboostedstep) {
                if (boosted > settings.maxboostedstep) {
                  boosted = settings.maxboostedstep;
                  value = Math.round(value / boosted) * boosted;
                }
              }

              return Math.max(settings.step, boosted);
            }
          }

          function upOnce() {
            _checkValue();

            value = parseFloat(elements.input.val());
            if (isNaN(value)) {
              value = 0;
            }

            var initvalue = value,
                boostedstep = _getBoostedStep();

            value = value + boostedstep;

            if (value > settings.max) {
              value = settings.max;
              originalinput.trigger('touchspin.on.max');
              stopSpin();
            }

            elements.input.val(Number(value).toFixed(settings.decimals));

            if (initvalue !== value) {
              originalinput.trigger('change');
            }
          }

          function downOnce() {
            _checkValue();

            value = parseFloat(elements.input.val());
            if (isNaN(value)) {
              value = 0;
            }

            var initvalue = value,
                boostedstep = _getBoostedStep();

            value = value - boostedstep;

            if (value < settings.min) {
              value = settings.min;
              originalinput.trigger('touchspin.on.min');
              stopSpin();
            }

            elements.input.val(value.toFixed(settings.decimals));

            if (initvalue !== value) {
              originalinput.trigger('change');
            }
          }

          function startDownSpin() {
            stopSpin();

            spincount = 0;
            spinning = 'down';

            originalinput.trigger('touchspin.on.startspin');
            originalinput.trigger('touchspin.on.startdownspin');

            downDelayTimeout = setTimeout(function () {
              downSpinTimer = setInterval(function () {
                spincount++;
                downOnce();
              }, settings.stepinterval);
            }, settings.stepintervaldelay);
          }

          function startUpSpin() {
            stopSpin();

            spincount = 0;
            spinning = 'up';

            originalinput.trigger('touchspin.on.startspin');
            originalinput.trigger('touchspin.on.startupspin');

            upDelayTimeout = setTimeout(function () {
              upSpinTimer = setInterval(function () {
                spincount++;
                upOnce();
              }, settings.stepinterval);
            }, settings.stepintervaldelay);
          }

          function stopSpin() {
            clearTimeout(downDelayTimeout);
            clearTimeout(upDelayTimeout);
            clearInterval(downSpinTimer);
            clearInterval(upSpinTimer);

            switch (spinning) {
              case 'up':
                originalinput.trigger('touchspin.on.stopupspin');
                originalinput.trigger('touchspin.on.stopspin');
                break;
              case 'down':
                originalinput.trigger('touchspin.on.stopdownspin');
                originalinput.trigger('touchspin.on.stopspin');
                break;
            }

            spincount = 0;
            spinning = false;
          }
        });
      };
    })(jQuery);
  })(this);

  return _retrieveGlobal();
});
System.registerDynamic("reactiveadmintemplate/scripts/modules/product/init.js", ["jquery-ui/ui/widgets/sortable", "bootstrap-table", "x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js", "tableexport.jquery.plugin", "bootstrap-table/src/extensions/editable/bootstrap-table-editable", "bootstrap-table/src/extensions/export/bootstrap-table-export", "../form/editor/summernote", "touchspin"], true, function ($__require, exports, module) {
    'use strict';

    var global = this || self,
        GLOBAL = global;
    Object.defineProperty(exports, "__esModule", { value: true });
    /*!
     * @version: 1.1.2
     * @name: main
     *
     * @author: https://themeforest.net/user/flexlayers
     */
    $__require("jquery-ui/ui/widgets/sortable");
    $__require("bootstrap-table");
    $__require("x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js");
    $__require("tableexport.jquery.plugin");
    $__require("bootstrap-table/src/extensions/editable/bootstrap-table-editable");
    $__require("bootstrap-table/src/extensions/export/bootstrap-table-export");
    $__require("../form/editor/summernote");
    $__require("touchspin");
    $(function () {
        var $table = $('#product-list-table'),
            $remove = $('#remove-table-row'),
            $new = $('#new-table-row'),
            selections;
        initTable();
        $('#product-description').summernote({
            height: 400,
            toolbar: [['para', ['paragraph']], ['color', ['color']], ['font', ['bold', 'italic']], ['text', ['underline', 'strikethrough', 'clear']], ['style', ['fontsize']], ['insert', ['link', 'picture', 'video']], ['view', ['fullscreen']]],
            placeholder: 'Message:'
        });
        function initSpin() {
            $table.find('input.spin').TouchSpin({
                min: 0,
                max: 100,
                step: 1,
                decimals: 0,
                boostat: 5,
                maxboostedstep: 100
            });
        }
        function initTable() {
            //$.fn.editable.defaults.mode = 'inline';
            var customCeckbox = true;
            $table.bootstrapTable({
                icons: {
                    paginationSwitchDown: 'icon-arrow-down-circle', paginationSwitchUp: 'icon-arrow-up-circle', refresh: 'icon-refresh',
                    toggle: 'icon-list', columns: 'icon-grid', detailOpen: 'icon-plus', detailClose: 'icon-minus', 'export': 'icon-share-alt'
                },
                pageSize: 7, pageList: [7, 15, 25, 'All'],
                mobileResponsive: true, minWidth: 767,
                responseHandler: responseHandler, detailFormatter: detailFormatter,
                columns: [[{ field: 'state', checkbox: true, align: 'center' }, { title: 'ID', width: 40, field: 'id', align: 'center', sortable: true, footerFormatter: totalTextFormatter }, { field: 'image', title: 'Image', formatter: imageFormatter, align: 'center' }, { field: 'name', title: 'Name', sortable: true, footerFormatter: totalNameFormatter, align: 'center',
                    editable: { mode: 'inline' }
                }, { field: 'qty', title: 'QTY', sortable: true, formatter: qtyFormatter, align: 'center' }, { field: 'price', title: 'Price', sortable: true, align: 'center', footerFormatter: totalPriceFormatter,
                    editable: { type: 'text', title: 'Price', mode: 'inline',
                        validate: function (value) {
                            value = $.trim(value);
                            if (!value) {
                                return 'This field is required';
                            }
                            if (!/^\$/.test(value)) {
                                return 'This field needs to start width $.';
                            }
                            return '';
                        }
                    }
                }, { field: 'link', title: 'Edit', align: 'center', formatter: linkFormatter }]]
            });
            $table.on('all.bs.table', styleCheckboxes);
            // sometimes footer render error.
            setTimeout(function () {
                $table.bootstrapTable('resetView');
            }, 200);
            $table.on('check.bs.table uncheck.bs.table check-all.bs.table uncheck-all.bs.table', function () {
                $remove.prop('disabled', !$table.bootstrapTable('getSelections').length);
                // save your data, here just save the current page
                selections = getIdSelections();
                // push or splice the selections if you want to save all data selections
            });
            $table.on('reset-view.bs.table toggle.bs.table post-body.bs.table', initSpin);
            $remove.click(function () {
                var ids = getIdSelections();
                $table.bootstrapTable('remove', {
                    field: 'id',
                    values: ids
                });
                $remove.prop('disabled', true);
            });
            $new.click(function () {
                var randomId = $table.bootstrapTable('getData').length;
                $table.bootstrapTable('insertRow', {
                    index: 0,
                    row: {
                        id: randomId,
                        name: 'Item ' + randomId,
                        price: '$0',
                        image: 'assets/img/products/no-img.jpg',
                        qty: 0,
                        link: '/product-single.html'
                    }
                });
                $new.prop('disabled', false);
            });
        }
        function getIdSelections() {
            return $.map($table.bootstrapTable('getSelections'), function (row) {
                return row.id;
            });
        }
        function responseHandler(res) {
            $.each(res.rows, function (i, row) {
                row.state = $.inArray(row.id, selections) !== -1;
            });
            return res;
        }
        function detailFormatter() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var html = [];
            var row = args[1];
            $.each(row, function (key, value) {
                html.push('<div class="row mb-1"><div class="col-3"><b>' + key + ':</b></div><div class="col-9">' + value + '</div></div>');
            });
            return html.join('');
        }
        function imageFormatter(value, row) {
            return '<img src="' + row.image + '" class="img-fluid product-list-image">';
        }
        function qtyFormatter(value, row) {
            return "<input id=\"max-qty\" class=\"spin form-control\" aria-describedby=\"Max Qty in the Cart\" value=\"" + row.qty + "\" placeholder=\"Enter Number\">";
        }
        function linkFormatter(value, row, index) {
            return "<a class=\"like\" target=\"_blank\" href=\"" + row.link + "\" title=\"Like\"><i class=\"fa fa-edit icon-mr-ch\"></i>Edit</a>";
        }
        function totalTextFormatter(data) {
            return 'Total';
        }
        function totalNameFormatter(data) {
            return data.length;
        }
        function totalPriceFormatter(data) {
            var total = 0;
            $.each(data, function (i, row) {
                total += +row.price.substring(1);
            });
            return '$' + total;
        }
        function getHeight() {
            var _height = $(window).height() - $table.parents('.panel').find('.panel-header').outerHeight() - 250;
            var _table_height = $table.height() - 20;
            if (_table_height < _height) {
                return _table_height;
            }
            return _height;
        }
        function styleCheckboxes() {
            $('input[name="btSelectItem"], input[name="btSelectGroup"], input[name="btSelectAll"], .fixed-table-toolbar [type="checkbox"]').each(function () {
                if (!$(this).hasClass('custom-control-input')) {
                    $(this).addClass('custom-control-input');
                    var $label = $(this).parent().is('label') ? $(this).parent().addClass('custom-control custom-checkbox') : $(this).wrap('<label class="custom-control custom-checkbox"></label>').parent();
                    $label.contents().filter(function () {
                        return this.nodeType === 3;
                    }).wrap('<span class="custom-control-description"></span>');
                    $('<span class="custom-control-indicator"></span>').appendTo($label);
                }
            });
        }
    });
});
System.registerDynamic("npm:jquery-sparkline@2.4.0.json", [], true, function() {
  return {
    "main": "jquery.sparkline.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "jquery.sparkline.js": {
        "format": "amd"
      },
      "jquery.sparkline.min.js": {
        "format": "amd"
      },
      "src/header.js": {
        "format": "amd"
      }
    },
    "map": {
      "./package": "./package.json"
    }
  };
});

/**
*
* jquery.sparkline.js
*
* v2.4.1
* (c) Splunk, Inc
* Contact: Gareth Watts (gareth@splunk.com)
* http://omnipotent.net/jquery.sparkline/
*
* Generates inline sparkline charts from data supplied either to the method
* or inline in HTML
*
* Compatible with Internet Explorer 6.0+ and modern browsers equipped with the canvas tag
* (Firefox 2.0+, Safari, Opera, etc)
*
* License: New BSD License
*
* Copyright (c) 2012, Splunk Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright notice,
*       this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright notice,
*       this list of conditions and the following disclaimer in the documentation
*       and/or other materials provided with the distribution.
*     * Neither the name of Splunk Inc nor the names of its contributors may
*       be used to endorse or promote products derived from this software without
*       specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
* SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*
* Usage:
*  $(selector).sparkline(values, options)
*
* If values is undefined or set to 'html' then the data values are read from the specified tag:
*   <p>Sparkline: <span class="sparkline">1,4,6,6,8,5,3,5</span></p>
*   $('.sparkline').sparkline();
* There must be no spaces in the enclosed data set
*
* Otherwise values must be an array of numbers or null values
*    <p>Sparkline: <span id="sparkline1">This text replaced if the browser is compatible</span></p>
*    $('#sparkline1').sparkline([1,4,6,6,8,5,3,5])
*    $('#sparkline2').sparkline([1,4,6,null,null,5,3,5])
*
* Values can also be specified in an HTML comment, or as a values attribute:
*    <p>Sparkline: <span class="sparkline"><!--1,4,6,6,8,5,3,5 --></span></p>
*    <p>Sparkline: <span class="sparkline" values="1,4,6,6,8,5,3,5"></span></p>
*    $('.sparkline').sparkline();
*
* For line charts, x values can also be specified:
*   <p>Sparkline: <span class="sparkline">1:1,2.7:4,3.4:6,5:6,6:8,8.7:5,9:3,10:5</span></p>
*    $('#sparkline1').sparkline([ [1,1], [2.7,4], [3.4,6], [5,6], [6,8], [8.7,5], [9,3], [10,5] ])
*
* By default, options should be passed in as the second argument to the sparkline function:
*   $('.sparkline').sparkline([1,2,3,4], {type: 'bar'})
*
* Options can also be set by passing them on the tag itself.  This feature is disabled by default though
* as there's a slight performance overhead:
*   $('.sparkline').sparkline([1,2,3,4], {enableTagOptions: true})
*   <p>Sparkline: <span class="sparkline" sparkType="bar" sparkBarColor="red">loading</span></p>
* Prefix all options supplied as tag attribute with "spark" (configurable by setting tagOptionsPrefix)
*
* Supported options:
*   lineColor - Color of the line used for the chart
*   fillColor - Color used to fill in the chart - Set to '' or false for a transparent chart
*   width - Width of the chart - Defaults to 3 times the number of values in pixels
*   height - Height of the chart - Defaults to the height of the containing element
*   chartRangeMin - Specify the minimum value to use for the Y range of the chart - Defaults to the minimum value supplied
*   chartRangeMax - Specify the maximum value to use for the Y range of the chart - Defaults to the maximum value supplied
*   chartRangeClip - Clip out of range values to the max/min specified by chartRangeMin and chartRangeMax
*   chartRangeMinX - Specify the minimum value to use for the X range of the chart - Defaults to the minimum value supplied
*   chartRangeMaxX - Specify the maximum value to use for the X range of the chart - Defaults to the maximum value supplied
*   composite - If true then don't erase any existing chart attached to the tag, but draw
*           another chart over the top - Note that width and height are ignored if an
*           existing chart is detected.
*   tagValuesAttribute - Name of tag attribute to check for data values - Defaults to 'values'
*   enableTagOptions - Whether to check tags for sparkline options
*   tagOptionsPrefix - Prefix used for options supplied as tag attributes - Defaults to 'spark'
*   disableHiddenCheck - If set to true, then the plugin will assume that charts will never be drawn into a
*           hidden dom element, avoding a browser reflow
*   disableInteraction - If set to true then all mouseover/click interaction behaviour will be disabled,
*       making the plugin perform much like it did in 1.x
*   disableTooltips - If set to true then tooltips will be disabled - Defaults to false (tooltips enabled)
*   disableHighlight - If set to true then highlighting of selected chart elements on mouseover will be disabled
*       defaults to false (highlights enabled)
*   highlightLighten - Factor to lighten/darken highlighted chart values by - Defaults to 1.4 for a 40% increase
*   tooltipContainer - Specify which DOM element the tooltip should be rendered into - defaults to document.body
*   tooltipClassname - Optional CSS classname to apply to tooltips - If not specified then a default style will be applied
*   tooltipOffsetX - How many pixels away from the mouse pointer to render the tooltip on the X axis
*   tooltipOffsetY - How many pixels away from the mouse pointer to render the tooltip on the r axis
*   tooltipFormatter  - Optional callback that allows you to override the HTML displayed in the tooltip
*       callback is given arguments of (sparkline, options, fields)
*   tooltipChartTitle - If specified then the tooltip uses the string specified by this setting as a title
*   tooltipFormat - A format string or SPFormat object  (or an array thereof for multiple entries)
*       to control the format of the tooltip
*   tooltipPrefix - A string to prepend to each field displayed in a tooltip
*   tooltipSuffix - A string to append to each field displayed in a tooltip
*   tooltipSkipNull - If true then null values will not have a tooltip displayed (defaults to true)
*   tooltipValueLookups - An object or range map to map field values to tooltip strings
*       (eg. to map -1 to "Lost", 0 to "Draw", and 1 to "Win")
*   numberFormatter - Optional callback for formatting numbers in tooltips
*   numberDigitGroupSep - Character to use for group separator in numbers "1,234" - Defaults to ","
*   numberDecimalMark - Character to use for the decimal point when formatting numbers - Defaults to "."
*   numberDigitGroupCount - Number of digits between group separator - Defaults to 3
*
* There are 7 types of sparkline, selected by supplying a "type" option of 'line' (default),
* 'bar', 'tristate', 'bullet', 'discrete', 'pie' or 'box'
*    line - Line chart.  Options:
*       spotColor - Set to '' to not end each line in a circular spot
*       minSpotColor - If set, color of spot at minimum value
*       maxSpotColor - If set, color of spot at maximum value
*       spotRadius - Radius in pixels
*       lineWidth - Width of line in pixels
*       normalRangeMin
*       normalRangeMax - If set draws a filled horizontal bar between these two values marking the "normal"
*                      or expected range of values
*       normalRangeColor - Color to use for the above bar
*       drawNormalOnTop - Draw the normal range above the chart fill color if true
*       defaultPixelsPerValue - Defaults to 3 pixels of width for each value in the chart
*       highlightSpotColor - The color to use for drawing a highlight spot on mouseover - Set to null to disable
*       highlightLineColor - The color to use for drawing a highlight line on mouseover - Set to null to disable
*       valueSpots - Specify which points to draw spots on, and in which color.  Accepts a range map
*
*   bar - Bar chart.  Options:
*       barColor - Color of bars for postive values
*       negBarColor - Color of bars for negative values
*       zeroColor - Color of bars with zero values
*       nullColor - Color of bars with null values - Defaults to omitting the bar entirely
*       barWidth - Width of bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*       barSpacing - Gap between bars in pixels
*       zeroAxis - Centers the y-axis around zero if true
*
*   tristate - Charts values of win (>0), lose (<0) or draw (=0)
*       posBarColor - Color of win values
*       negBarColor - Color of lose values
*       zeroBarColor - Color of draw values
*       barWidth - Width of bars in pixels
*       barSpacing - Gap between bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*
*   discrete - Options:
*       lineHeight - Height of each line in pixels - Defaults to 30% of the graph height
*       thesholdValue - Values less than this value will be drawn using thresholdColor instead of lineColor
*       thresholdColor
*
*   bullet - Values for bullet graphs msut be in the order: target, performance, range1, range2, range3, ...
*       options:
*       targetColor - The color of the vertical target marker
*       targetWidth - The width of the target marker in pixels
*       performanceColor - The color of the performance measure horizontal bar
*       rangeColors - Colors to use for each qualitative range background color
*
*   pie - Pie chart. Options:
*       sliceColors - An array of colors to use for pie slices
*       offset - Angle in degrees to offset the first slice - Try -90 or +90
*       borderWidth - Width of border to draw around the pie chart, in pixels - Defaults to 0 (no border)
*       borderColor - Color to use for the pie chart border - Defaults to #000
*
*   box - Box plot. Options:
*       raw - Set to true to supply pre-computed plot points as values
*             values should be: low_outlier, low_whisker, q1, median, q3, high_whisker, high_outlier
*             When set to false you can supply any number of values and the box plot will
*             be computed for you.  Default is false.
*       showOutliers - Set to true (default) to display outliers as circles
*       outlierIQR - Interquartile range used to determine outliers.  Default 1.5
*       boxLineColor - Outline color of the box
*       boxFillColor - Fill color for the box
*       whiskerColor - Line color used for whiskers
*       outlierLineColor - Outline color of outlier circles
*       outlierFillColor - Fill color of the outlier circles
*       spotRadius - Radius of outlier circles
*       medianColor - Line color of the median line
*       target - Draw a target cross hair at the supplied value (default undefined)
*
*
*
*   Examples:
*   $('#sparkline1').sparkline(myvalues, { lineColor: '#f00', fillColor: false });
*   $('.barsparks').sparkline('html', { type:'bar', height:'40px', barWidth:5 });
*   $('#tristate').sparkline([1,1,-1,1,0,0,-1], { type:'tristate' }):
*   $('#discrete').sparkline([1,3,4,5,5,3,4,5], { type:'discrete' });
*   $('#bullet').sparkline([10,12,12,9,7], { type:'bullet' });
*   $('#pie').sparkline([1,1,2], { type:'pie' });
*/

/*jslint regexp: true, browser: true, jquery: true, white: true, nomen: false, plusplus: false, maxerr: 500, indent: 4 */

(function (document, Math, undefined) {
    // performance/minified-size optimization
    (function (factory) {
        if ('function' === 'function' && true) {
            System.registerDynamic('npm:jquery-sparkline@2.4.0/jquery.sparkline.js', ['jquery'], false, function ($__require, $__exports, $__module) {
                if (typeof factory === 'function') {
                    return factory.call(this, $__require('jquery'));
                } else {
                    return factory;
                }
            });
        } else if (jQuery && !jQuery.fn.sparkline) {
            factory(jQuery);
        }
    })(function ($) {
        'use strict';

        var UNSET_OPTION = {},
            getDefaults,
            createClass,
            SPFormat,
            clipval,
            quartile,
            normalizeValue,
            normalizeValues,
            remove,
            isNumber,
            all,
            sum,
            addCSS,
            ensureArray,
            formatNumber,
            RangeMap,
            MouseHandler,
            Tooltip,
            barHighlightMixin,
            line,
            bar,
            tristate,
            discrete,
            bullet,
            pie,
            box,
            defaultStyles,
            initStyles,
            VShape,
            VCanvas_base,
            VCanvas_canvas,
            VCanvas_vml,
            pending,
            shapeCount = 0;

        /**
         * Default configuration settings
         */
        getDefaults = function () {
            return {
                // Settings common to most/all chart types
                common: {
                    type: 'line',
                    lineColor: '#00f',
                    fillColor: '#cdf',
                    defaultPixelsPerValue: 3,
                    width: 'auto',
                    height: 'auto',
                    composite: false,
                    tagValuesAttribute: 'values',
                    tagOptionsPrefix: 'spark',
                    enableTagOptions: false,
                    enableHighlight: true,
                    highlightLighten: 1.4,
                    tooltipSkipNull: true,
                    tooltipPrefix: '',
                    tooltipSuffix: '',
                    disableHiddenCheck: false,
                    numberFormatter: false,
                    numberDigitGroupCount: 3,
                    numberDigitGroupSep: ',',
                    numberDecimalMark: '.',
                    disableTooltips: false,
                    disableInteraction: false
                },
                // Defaults for line charts
                line: {
                    spotColor: '#f80',
                    highlightSpotColor: '#5f5',
                    highlightLineColor: '#f22',
                    spotRadius: 1.5,
                    minSpotColor: '#f80',
                    maxSpotColor: '#f80',
                    lineWidth: 1,
                    normalRangeMin: undefined,
                    normalRangeMax: undefined,
                    normalRangeColor: '#ccc',
                    drawNormalOnTop: false,
                    chartRangeMin: undefined,
                    chartRangeMax: undefined,
                    chartRangeMinX: undefined,
                    chartRangeMaxX: undefined,
                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{y}}{{suffix}}')
                },
                // Defaults for bar charts
                bar: {
                    barColor: '#3366cc',
                    negBarColor: '#f44',
                    stackedBarColor: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00', '#dd4477', '#0099c6', '#990099'],
                    zeroColor: undefined,
                    nullColor: undefined,
                    zeroAxis: true,
                    barWidth: 4,
                    barSpacing: 1,
                    chartRangeMax: undefined,
                    chartRangeMin: undefined,
                    chartRangeClip: false,
                    colorMap: undefined,
                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{value}}{{suffix}}')
                },
                // Defaults for tristate charts
                tristate: {
                    barWidth: 4,
                    barSpacing: 1,
                    posBarColor: '#6f6',
                    negBarColor: '#f44',
                    zeroBarColor: '#999',
                    colorMap: {},
                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value:map}}'),
                    tooltipValueLookups: { map: { '-1': 'Loss', '0': 'Draw', '1': 'Win' } }
                },
                // Defaults for discrete charts
                discrete: {
                    lineHeight: 'auto',
                    thresholdColor: undefined,
                    thresholdValue: 0,
                    chartRangeMax: undefined,
                    chartRangeMin: undefined,
                    chartRangeClip: false,
                    tooltipFormat: new SPFormat('{{prefix}}{{value}}{{suffix}}')
                },
                // Defaults for bullet charts
                bullet: {
                    targetColor: '#f33',
                    targetWidth: 3, // width of the target bar in pixels
                    performanceColor: '#33f',
                    rangeColors: ['#d3dafe', '#a8b6ff', '#7f94ff'],
                    base: undefined, // set this to a number to change the base start number
                    tooltipFormat: new SPFormat('{{fieldkey:fields}} - {{value}}'),
                    tooltipValueLookups: { fields: { r: 'Range', p: 'Performance', t: 'Target' } }
                },
                // Defaults for pie charts
                pie: {
                    offset: 0,
                    sliceColors: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00', '#dd4477', '#0099c6', '#990099'],
                    borderWidth: 0,
                    borderColor: '#000',
                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value}} ({{percent.1}}%)')
                },
                // Defaults for box plots
                box: {
                    raw: false,
                    boxLineColor: '#000',
                    boxFillColor: '#cdf',
                    whiskerColor: '#000',
                    outlierLineColor: '#333',
                    outlierFillColor: '#fff',
                    medianColor: '#f00',
                    showOutliers: true,
                    outlierIQR: 1.5,
                    spotRadius: 1.5,
                    target: undefined,
                    targetColor: '#4a2',
                    chartRangeMax: undefined,
                    chartRangeMin: undefined,
                    tooltipFormat: new SPFormat('{{field:fields}}: {{value}}'),
                    tooltipFormatFieldlistKey: 'field',
                    tooltipValueLookups: { fields: { lq: 'Lower Quartile', med: 'Median',
                            uq: 'Upper Quartile', lo: 'Left Outlier', ro: 'Right Outlier',
                            lw: 'Left Whisker', rw: 'Right Whisker' } }
                }
            };
        };

        // You can have tooltips use a css class other than jqstooltip by specifying tooltipClassname
        defaultStyles = '.jqstooltip { ' + 'position: absolute;' + 'left: 0px;' + 'top: 0px;' + 'visibility: hidden;' + 'background: rgb(0, 0, 0) transparent;' + 'background-color: rgba(0,0,0,0.6);' + 'filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);' + '-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)";' + 'color: white;' + 'font: 10px arial, san serif;' + 'text-align: left;' + 'white-space: nowrap;' + 'padding: 5px;' + 'border: 1px solid white;' + 'box-sizing: content-box;' + 'z-index: 10000;' + '}' + '.jqsfield { ' + 'color: white;' + 'font: 10px arial, san serif;' + 'text-align: left;' + '}';

        /**
         * Utilities
         */

        createClass = function () /* [baseclass, [mixin, ...]], definition */{
            var Class, args;
            Class = function () {
                this.init.apply(this, arguments);
            };
            if (arguments.length > 1) {
                if (arguments[0]) {
                    Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);
                    Class._super = arguments[0].prototype;
                } else {
                    Class.prototype = arguments[arguments.length - 1];
                }
                if (arguments.length > 2) {
                    args = Array.prototype.slice.call(arguments, 1, -1);
                    args.unshift(Class.prototype);
                    $.extend.apply($, args);
                }
            } else {
                Class.prototype = arguments[0];
            }
            Class.prototype.cls = Class;
            return Class;
        };

        /**
         * Wraps a format string for tooltips
         * {{x}}
         * {{x.2}
         * {{x:months}}
         */
        $.SPFormatClass = SPFormat = createClass({
            fre: /\{\{([\w.]+?)(:(.+?))?\}\}/g,
            precre: /(\w+)\.(\d+)/,

            init: function (format, fclass) {
                this.format = format;
                this.fclass = fclass;
            },

            render: function (fieldset, lookups, options) {
                var self = this,
                    fields = fieldset,
                    match,
                    token,
                    lookupkey,
                    fieldvalue,
                    prec;
                return this.format.replace(this.fre, function () {
                    var lookup;
                    token = arguments[1];
                    lookupkey = arguments[3];
                    match = self.precre.exec(token);
                    if (match) {
                        prec = match[2];
                        token = match[1];
                    } else {
                        prec = false;
                    }
                    fieldvalue = fields[token];
                    if (fieldvalue === undefined) {
                        return '';
                    }
                    if (lookupkey && lookups && lookups[lookupkey]) {
                        lookup = lookups[lookupkey];
                        if (lookup.get) {
                            // RangeMap
                            return lookups[lookupkey].get(fieldvalue) || fieldvalue;
                        } else {
                            return lookups[lookupkey][fieldvalue] || fieldvalue;
                        }
                    }
                    if (isNumber(fieldvalue)) {
                        if (options.get('numberFormatter')) {
                            fieldvalue = options.get('numberFormatter')(fieldvalue);
                        } else {
                            fieldvalue = formatNumber(fieldvalue, prec, options.get('numberDigitGroupCount'), options.get('numberDigitGroupSep'), options.get('numberDecimalMark'));
                        }
                    }
                    return fieldvalue;
                });
            }
        });

        // convience method to avoid needing the new operator
        $.spformat = function (format, fclass) {
            return new SPFormat(format, fclass);
        };

        clipval = function (val, min, max) {
            if (val < min) {
                return min;
            }
            if (val > max) {
                return max;
            }
            return val;
        };

        quartile = function (values, q) {
            var vl;
            if (q === 2) {
                vl = Math.floor(values.length / 2);
                return values.length % 2 ? values[vl] : (values[vl - 1] + values[vl]) / 2;
            } else {
                if (values.length % 2) {
                    // odd
                    vl = (values.length * q + q) / 4;
                    return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];
                } else {
                    //even
                    vl = (values.length * q + 2) / 4;
                    return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];
                }
            }
        };

        normalizeValue = function (val) {
            var nf;
            switch (val) {
                case 'undefined':
                    val = undefined;
                    break;
                case 'null':
                    val = null;
                    break;
                case 'true':
                    val = true;
                    break;
                case 'false':
                    val = false;
                    break;
                default:
                    nf = parseFloat(val);
                    if (val == nf) {
                        val = nf;
                    }
            }
            return val;
        };

        normalizeValues = function (vals) {
            var i,
                result = [];
            for (i = vals.length; i--;) {
                result[i] = normalizeValue(vals[i]);
            }
            return result;
        };

        remove = function (vals, filter) {
            var i,
                vl,
                result = [];
            for (i = 0, vl = vals.length; i < vl; i++) {
                if (vals[i] !== filter) {
                    result.push(vals[i]);
                }
            }
            return result;
        };

        isNumber = function (num) {
            return !isNaN(parseFloat(num)) && isFinite(num);
        };

        formatNumber = function (num, prec, groupsize, groupsep, decsep) {
            var p, i;
            num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split('');
            p = (p = $.inArray('.', num)) < 0 ? num.length : p;
            if (p < num.length) {
                num[p] = decsep;
            }
            for (i = p - groupsize; i > 0; i -= groupsize) {
                num.splice(i, 0, groupsep);
            }
            return num.join('');
        };

        // determine if all values of an array match a value
        // returns true if the array is empty
        all = function (val, arr, ignoreNull) {
            var i;
            for (i = arr.length; i--;) {
                if (ignoreNull && arr[i] === null) continue;
                if (arr[i] !== val) {
                    return false;
                }
            }
            return true;
        };

        // sums the numeric values in an array, ignoring other values
        sum = function (vals) {
            var total = 0,
                i;
            for (i = vals.length; i--;) {
                total += typeof vals[i] === 'number' ? vals[i] : 0;
            }
            return total;
        };

        ensureArray = function (val) {
            return $.isArray(val) ? val : [val];
        };

        // http://paulirish.com/2008/bookmarklet-inject-new-css-rules/
        addCSS = function (css) {
            var tag, iefail;
            if (document.createStyleSheet) {
                try {
                    document.createStyleSheet().cssText = css;
                    return;
                } catch (e) {
                    // IE <= 9 maxes out at 31 stylesheets; inject into page instead.
                    iefail = true;
                }
            }
            tag = document.createElement('style');
            tag.type = 'text/css';
            document.getElementsByTagName('head')[0].appendChild(tag);
            if (iefail) {
                document.styleSheets[document.styleSheets.length - 1].cssText = css;
            } else {
                tag[typeof document.body.style.WebkitAppearance == 'string' ? /* webkit only */'innerText' : 'innerHTML'] = css;
            }
        };

        // Provide a cross-browser interface to a few simple drawing primitives
        $.fn.simpledraw = function (width, height, useExisting, interact) {
            var target, mhandler;
            if (useExisting && (target = this.data('_jqs_vcanvas'))) {
                return target;
            }

            if ($.fn.sparkline.canvas === false) {
                // We've already determined that neither Canvas nor VML are available
                return false;
            } else if ($.fn.sparkline.canvas === undefined) {
                // No function defined yet -- need to see if we support Canvas or VML
                var el = document.createElement('canvas');
                if (!!(el.getContext && el.getContext('2d'))) {
                    // Canvas is available
                    $.fn.sparkline.canvas = function (width, height, target, interact) {
                        return new VCanvas_canvas(width, height, target, interact);
                    };
                } else if (document.namespaces && !document.namespaces.v) {
                    // VML is available
                    document.namespaces.add('v', 'urn:schemas-microsoft-com:vml', '#default#VML');
                    $.fn.sparkline.canvas = function (width, height, target, interact) {
                        return new VCanvas_vml(width, height, target);
                    };
                } else {
                    // Neither Canvas nor VML are available
                    $.fn.sparkline.canvas = false;
                    return false;
                }
            }

            if (width === undefined) {
                width = $(this).innerWidth();
            }
            if (height === undefined) {
                height = $(this).innerHeight();
            }

            target = $.fn.sparkline.canvas(width, height, this, interact);

            mhandler = $(this).data('_jqs_mhandler');
            if (mhandler) {
                mhandler.registerCanvas(target);
            }
            return target;
        };

        $.fn.cleardraw = function () {
            var target = this.data('_jqs_vcanvas');
            if (target) {
                target.reset();
            }
        };

        $.RangeMapClass = RangeMap = createClass({
            init: function (map) {
                var key,
                    range,
                    rangelist = [];
                for (key in map) {
                    if (map.hasOwnProperty(key) && typeof key === 'string' && key.indexOf(':') > -1) {
                        range = key.split(':');
                        range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);
                        range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);
                        range[2] = map[key];
                        rangelist.push(range);
                    }
                }
                this.map = map;
                this.rangelist = rangelist || false;
            },

            get: function (value) {
                var rangelist = this.rangelist,
                    i,
                    range,
                    result;
                if ((result = this.map[value]) !== undefined) {
                    return result;
                }
                if (rangelist) {
                    for (i = rangelist.length; i--;) {
                        range = rangelist[i];
                        if (range[0] <= value && range[1] >= value) {
                            return range[2];
                        }
                    }
                }
                return undefined;
            }
        });

        // Convenience function
        $.range_map = function (map) {
            return new RangeMap(map);
        };

        MouseHandler = createClass({
            init: function (el, options) {
                var $el = $(el);
                this.$el = $el;
                this.options = options;
                this.currentPageX = 0;
                this.currentPageY = 0;
                this.el = el;
                this.splist = [];
                this.tooltip = null;
                this.over = false;
                this.displayTooltips = !options.get('disableTooltips');
                this.highlightEnabled = !options.get('disableHighlight');
            },

            registerSparkline: function (sp) {
                this.splist.push(sp);
                if (this.over) {
                    this.updateDisplay();
                }
            },

            registerCanvas: function (canvas) {
                var $canvas = $(canvas.canvas);
                this.canvas = canvas;
                this.$canvas = $canvas;
                $canvas.mouseenter($.proxy(this.mouseenter, this));
                $canvas.mouseleave($.proxy(this.mouseleave, this));
                $canvas.click($.proxy(this.mouseclick, this));
            },

            reset: function (removeTooltip) {
                this.splist = [];
                if (this.tooltip && removeTooltip) {
                    this.tooltip.remove();
                    this.tooltip = undefined;
                }
            },

            mouseclick: function (e) {
                var clickEvent = $.Event('sparklineClick');
                clickEvent.originalEvent = e;
                clickEvent.sparklines = this.splist;
                this.$el.trigger(clickEvent);
            },

            mouseenter: function (e) {
                $(document.body).unbind('mousemove.jqs');
                $(document.body).bind('mousemove.jqs', $.proxy(this.mousemove, this));
                this.over = true;
                this.currentPageX = e.pageX;
                this.currentPageY = e.pageY;
                this.currentEl = e.target;
                if (!this.tooltip && this.displayTooltips) {
                    this.tooltip = new Tooltip(this.options);
                    this.tooltip.updatePosition(e.pageX, e.pageY);
                }
                this.updateDisplay();
            },

            mouseleave: function () {
                $(document.body).unbind('mousemove.jqs');
                var splist = this.splist,
                    spcount = splist.length,
                    needsRefresh = false,
                    sp,
                    i;
                this.over = false;
                this.currentEl = null;

                if (this.tooltip) {
                    this.tooltip.remove();
                    this.tooltip = null;
                }

                for (i = 0; i < spcount; i++) {
                    sp = splist[i];
                    if (sp.clearRegionHighlight()) {
                        needsRefresh = true;
                    }
                }

                if (needsRefresh) {
                    this.canvas.render();
                }
            },

            mousemove: function (e) {
                this.currentPageX = e.pageX;
                this.currentPageY = e.pageY;
                this.currentEl = e.target;
                if (this.tooltip) {
                    this.tooltip.updatePosition(e.pageX, e.pageY);
                }
                this.updateDisplay();
            },

            updateDisplay: function () {
                var splist = this.splist,
                    spcount = splist.length,
                    needsRefresh = false,
                    offset = this.$canvas.offset(),
                    localX = this.currentPageX - offset.left,
                    localY = this.currentPageY - offset.top,
                    tooltiphtml,
                    sp,
                    i,
                    result,
                    changeEvent;
                if (!this.over) {
                    return;
                }
                for (i = 0; i < spcount; i++) {
                    sp = splist[i];
                    result = sp.setRegionHighlight(this.currentEl, localX, localY);
                    if (result) {
                        needsRefresh = true;
                    }
                }
                if (needsRefresh) {
                    changeEvent = $.Event('sparklineRegionChange');
                    changeEvent.sparklines = this.splist;
                    this.$el.trigger(changeEvent);
                    if (this.tooltip) {
                        tooltiphtml = '';
                        for (i = 0; i < spcount; i++) {
                            sp = splist[i];
                            tooltiphtml += sp.getCurrentRegionTooltip();
                        }
                        this.tooltip.setContent(tooltiphtml);
                    }
                    if (!this.disableHighlight) {
                        this.canvas.render();
                    }
                }
                if (result === null) {
                    this.mouseleave();
                }
            }
        });

        Tooltip = createClass({
            sizeStyle: 'position: static !important;' + 'display: block !important;' + 'visibility: hidden !important;' + 'float: left !important;',

            init: function (options) {
                var tooltipClassname = options.get('tooltipClassname', 'jqstooltip'),
                    sizetipStyle = this.sizeStyle,
                    offset;
                this.container = options.get('tooltipContainer') || document.body;
                this.tooltipOffsetX = options.get('tooltipOffsetX', 10);
                this.tooltipOffsetY = options.get('tooltipOffsetY', 12);
                // remove any previous lingering tooltip
                $('#jqssizetip').remove();
                $('#jqstooltip').remove();
                this.sizetip = $('<div/>', {
                    id: 'jqssizetip',
                    style: sizetipStyle,
                    'class': tooltipClassname
                });
                this.tooltip = $('<div/>', {
                    id: 'jqstooltip',
                    'class': tooltipClassname
                }).appendTo(this.container);
                // account for the container's location
                offset = this.tooltip.offset();
                this.offsetLeft = offset.left;
                this.offsetTop = offset.top;
                this.hidden = true;
                $(window).unbind('resize.jqs scroll.jqs');
                $(window).bind('resize.jqs scroll.jqs', $.proxy(this.updateWindowDims, this));
                this.updateWindowDims();
            },

            updateWindowDims: function () {
                this.scrollTop = $(window).scrollTop();
                this.scrollLeft = $(window).scrollLeft();
                this.scrollRight = this.scrollLeft + $(window).width();
                this.updatePosition();
            },

            getSize: function (content) {
                this.sizetip.html(content).appendTo(this.container);
                this.width = this.sizetip.width() + 1;
                this.height = this.sizetip.height();
                this.sizetip.remove();
            },

            setContent: function (content) {
                if (!content) {
                    this.tooltip.css('visibility', 'hidden');
                    this.hidden = true;
                    return;
                }
                this.getSize(content);
                this.tooltip.html(content).css({
                    'width': this.width,
                    'height': this.height,
                    'visibility': 'visible'
                });
                if (this.hidden) {
                    this.hidden = false;
                    this.updatePosition();
                }
            },

            updatePosition: function (x, y) {
                if (x === undefined) {
                    if (this.mousex === undefined) {
                        return;
                    }
                    x = this.mousex - this.offsetLeft;
                    y = this.mousey - this.offsetTop;
                } else {
                    this.mousex = x = x - this.offsetLeft;
                    this.mousey = y = y - this.offsetTop;
                }
                if (!this.height || !this.width || this.hidden) {
                    return;
                }

                y -= this.height + this.tooltipOffsetY;
                x += this.tooltipOffsetX;

                if (y < this.scrollTop) {
                    y = this.scrollTop;
                }
                if (x < this.scrollLeft) {
                    x = this.scrollLeft;
                } else if (x + this.width > this.scrollRight) {
                    x = this.scrollRight - this.width;
                }

                this.tooltip.css({
                    'left': x,
                    'top': y
                });
            },

            remove: function () {
                this.tooltip.remove();
                this.sizetip.remove();
                this.sizetip = this.tooltip = undefined;
                $(window).unbind('resize.jqs scroll.jqs');
            }
        });

        initStyles = function () {
            addCSS(defaultStyles);
        };

        $(initStyles);

        pending = [];
        $.fn.sparkline = function (userValues, userOptions) {
            return this.each(function () {
                var options = new $.fn.sparkline.options(this, userOptions),
                    $this = $(this),
                    render,
                    i;
                render = function () {
                    var values, width, height, tmp, mhandler, sp, vals;
                    if (userValues === 'html' || userValues === undefined) {
                        vals = this.getAttribute(options.get('tagValuesAttribute'));
                        if (vals === undefined || vals === null) {
                            vals = $this.html();
                        }
                        values = vals.replace(/(^\s*<!--)|(-->\s*$)|\s+/g, '').split(',');
                    } else {
                        values = userValues;
                    }

                    width = options.get('width') === 'auto' ? values.length * options.get('defaultPixelsPerValue') : options.get('width');
                    if (options.get('height') === 'auto') {
                        if (!options.get('composite') || !$.data(this, '_jqs_vcanvas')) {
                            // must be a better way to get the line height
                            tmp = document.createElement('span');
                            tmp.innerHTML = 'a';
                            $this.html(tmp);
                            height = $(tmp).innerHeight() || $(tmp).height();
                            $(tmp).remove();
                            tmp = null;
                        }
                    } else {
                        height = options.get('height');
                    }

                    if (!options.get('disableInteraction')) {
                        mhandler = $.data(this, '_jqs_mhandler');
                        if (!mhandler) {
                            mhandler = new MouseHandler(this, options);
                            $.data(this, '_jqs_mhandler', mhandler);
                        } else if (!options.get('composite')) {
                            mhandler.reset();
                        }
                    } else {
                        mhandler = false;
                    }

                    if (options.get('composite') && !$.data(this, '_jqs_vcanvas')) {
                        if (!$.data(this, '_jqs_errnotify')) {
                            alert('Attempted to attach a composite sparkline to an element with no existing sparkline');
                            $.data(this, '_jqs_errnotify', true);
                        }
                        return;
                    }

                    sp = new $.fn.sparkline[options.get('type')](this, values, options, width, height);

                    sp.render();

                    if (mhandler) {
                        mhandler.registerSparkline(sp);
                    }
                };
                if ($(this).html() && !options.get('disableHiddenCheck') && $(this).is(':hidden') || !$(this).parents('body').length) {
                    if (!options.get('composite') && $.data(this, '_jqs_pending')) {
                        // remove any existing references to the element
                        for (i = pending.length; i; i--) {
                            if (pending[i - 1][0] == this) {
                                pending.splice(i - 1, 1);
                            }
                        }
                    }
                    pending.push([this, render]);
                    $.data(this, '_jqs_pending', true);
                } else {
                    render.call(this);
                }
            });
        };

        $.fn.sparkline.defaults = getDefaults();

        $.sparkline_display_visible = function () {
            var el, i, pl;
            var done = [];
            for (i = 0, pl = pending.length; i < pl; i++) {
                el = pending[i][0];
                if ($(el).is(':visible') && !$(el).parents().is(':hidden')) {
                    pending[i][1].call(el);
                    $.data(pending[i][0], '_jqs_pending', false);
                    done.push(i);
                } else if (!$(el).closest('html').length && !$.data(el, '_jqs_pending')) {
                    // element has been inserted and removed from the DOM
                    // If it was not yet inserted into the dom then the .data request
                    // will return true.
                    // removing from the dom causes the data to be removed.
                    $.data(pending[i][0], '_jqs_pending', false);
                    done.push(i);
                }
            }
            for (i = done.length; i; i--) {
                pending.splice(done[i - 1], 1);
            }
        };

        /**
         * User option handler
         */
        $.fn.sparkline.options = createClass({
            init: function (tag, userOptions) {
                var extendedOptions, defaults, base, tagOptionType;
                this.userOptions = userOptions = userOptions || {};
                this.tag = tag;
                this.tagValCache = {};
                defaults = $.fn.sparkline.defaults;
                base = defaults.common;
                this.tagOptionsPrefix = userOptions.enableTagOptions && (userOptions.tagOptionsPrefix || base.tagOptionsPrefix);

                tagOptionType = this.getTagSetting('type');
                if (tagOptionType === UNSET_OPTION) {
                    extendedOptions = defaults[userOptions.type || base.type];
                } else {
                    extendedOptions = defaults[tagOptionType];
                }
                this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);
            },

            getTagSetting: function (key) {
                var prefix = this.tagOptionsPrefix,
                    val,
                    i,
                    pairs,
                    keyval;
                if (prefix === false || prefix === undefined) {
                    return UNSET_OPTION;
                }
                if (this.tagValCache.hasOwnProperty(key)) {
                    val = this.tagValCache.key;
                } else {
                    val = this.tag.getAttribute(prefix + key);
                    if (val === undefined || val === null) {
                        val = UNSET_OPTION;
                    } else if (val.substr(0, 1) === '[') {
                        val = val.substr(1, val.length - 2).split(',');
                        for (i = val.length; i--;) {
                            val[i] = normalizeValue(val[i].replace(/(^\s*)|(\s*$)/g, ''));
                        }
                    } else if (val.substr(0, 1) === '{') {
                        pairs = val.substr(1, val.length - 2).split(',');
                        val = {};
                        for (i = pairs.length; i--;) {
                            keyval = pairs[i].split(':', 2);
                            val[keyval[0].replace(/(^\s*)|(\s*$)/g, '')] = normalizeValue(keyval[1].replace(/(^\s*)|(\s*$)/g, ''));
                        }
                    } else {
                        val = normalizeValue(val);
                    }
                    this.tagValCache.key = val;
                }
                return val;
            },

            get: function (key, defaultval) {
                var tagOption = this.getTagSetting(key),
                    result;
                if (tagOption !== UNSET_OPTION) {
                    return tagOption;
                }
                return (result = this.mergedOptions[key]) === undefined ? defaultval : result;
            }
        });

        $.fn.sparkline._base = createClass({
            disabled: false,

            init: function (el, values, options, width, height) {
                this.el = el;
                this.$el = $(el);
                this.values = values;
                this.options = options;
                this.width = width;
                this.height = height;
                this.currentRegion = undefined;
            },

            /**
             * Setup the canvas
             */
            initTarget: function () {
                var interactive = !this.options.get('disableInteraction');
                if (!(this.target = this.$el.simpledraw(this.width, this.height, this.options.get('composite'), interactive))) {
                    this.disabled = true;
                } else {
                    this.canvasWidth = this.target.pixelWidth;
                    this.canvasHeight = this.target.pixelHeight;
                }
            },

            /**
             * Actually render the chart to the canvas
             */
            render: function () {
                if (this.disabled) {
                    this.el.innerHTML = '';
                    return false;
                }
                return true;
            },

            /**
             * Return a region id for a given x/y co-ordinate
             */
            getRegion: function (x, y) {},

            /**
             * Highlight an item based on the moused-over x,y co-ordinate
             */
            setRegionHighlight: function (el, x, y) {
                var currentRegion = this.currentRegion,
                    highlightEnabled = !this.options.get('disableHighlight'),
                    newRegion;
                if (x > this.canvasWidth || y > this.canvasHeight || x < 0 || y < 0) {
                    return null;
                }
                newRegion = this.getRegion(el, x, y);
                if (currentRegion !== newRegion) {
                    if (currentRegion !== undefined && highlightEnabled) {
                        this.removeHighlight();
                    }
                    this.currentRegion = newRegion;
                    if (newRegion !== undefined && highlightEnabled) {
                        this.renderHighlight();
                    }
                    return true;
                }
                return false;
            },

            /**
             * Reset any currently highlighted item
             */
            clearRegionHighlight: function () {
                if (this.currentRegion !== undefined) {
                    this.removeHighlight();
                    this.currentRegion = undefined;
                    return true;
                }
                return false;
            },

            renderHighlight: function () {
                this.changeHighlight(true);
            },

            removeHighlight: function () {
                this.changeHighlight(false);
            },

            changeHighlight: function (highlight) {},

            /**
             * Fetch the HTML to display as a tooltip
             */
            getCurrentRegionTooltip: function () {
                var options = this.options,
                    header = '',
                    entries = [],
                    fields,
                    formats,
                    formatlen,
                    fclass,
                    text,
                    i,
                    showFields,
                    showFieldsKey,
                    newFields,
                    fv,
                    formatter,
                    format,
                    fieldlen,
                    j;
                if (this.currentRegion === undefined) {
                    return '';
                }
                fields = this.getCurrentRegionFields();
                formatter = options.get('tooltipFormatter');
                if (formatter) {
                    return formatter(this, options, fields);
                }
                if (options.get('tooltipChartTitle')) {
                    header += '<div class="jqs jqstitle">' + options.get('tooltipChartTitle') + '</div>\n';
                }
                formats = this.options.get('tooltipFormat');
                if (!formats) {
                    return '';
                }
                if (!$.isArray(formats)) {
                    formats = [formats];
                }
                if (!$.isArray(fields)) {
                    fields = [fields];
                }
                showFields = this.options.get('tooltipFormatFieldlist');
                showFieldsKey = this.options.get('tooltipFormatFieldlistKey');
                if (showFields && showFieldsKey) {
                    // user-selected ordering of fields
                    newFields = [];
                    for (i = fields.length; i--;) {
                        fv = fields[i][showFieldsKey];
                        if ((j = $.inArray(fv, showFields)) != -1) {
                            newFields[j] = fields[i];
                        }
                    }
                    fields = newFields;
                }
                formatlen = formats.length;
                fieldlen = fields.length;
                for (i = 0; i < formatlen; i++) {
                    format = formats[i];
                    if (typeof format === 'string') {
                        format = new SPFormat(format);
                    }
                    fclass = format.fclass || 'jqsfield';
                    for (j = 0; j < fieldlen; j++) {
                        if (!fields[j].isNull || !options.get('tooltipSkipNull')) {
                            $.extend(fields[j], {
                                prefix: options.get('tooltipPrefix'),
                                suffix: options.get('tooltipSuffix')
                            });
                            text = format.render(fields[j], options.get('tooltipValueLookups'), options);
                            entries.push('<div class="' + fclass + '">' + text + '</div>');
                        }
                    }
                }
                if (entries.length) {
                    return header + entries.join('\n');
                }
                return '';
            },

            getCurrentRegionFields: function () {},

            calcHighlightColor: function (color, options) {
                var highlightColor = options.get('highlightColor'),
                    lighten = options.get('highlightLighten'),
                    parse,
                    mult,
                    rgbnew,
                    i;
                if (highlightColor) {
                    return highlightColor;
                }
                if (lighten) {
                    // extract RGB values
                    parse = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(color) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color);
                    if (parse) {
                        rgbnew = [];
                        mult = color.length === 4 ? 16 : 1;
                        for (i = 0; i < 3; i++) {
                            rgbnew[i] = clipval(Math.round(parseInt(parse[i + 1], 16) * mult * lighten), 0, 255);
                        }
                        return 'rgb(' + rgbnew.join(',') + ')';
                    }
                }
                return color;
            }

        });

        barHighlightMixin = {
            changeHighlight: function (highlight) {
                var currentRegion = this.currentRegion,
                    target = this.target,
                    shapeids = this.regionShapes[currentRegion],
                    newShapes;
                // will be null if the region value was null
                if (shapeids) {
                    newShapes = this.renderRegion(currentRegion, highlight);
                    if ($.isArray(newShapes) || $.isArray(shapeids)) {
                        target.replaceWithShapes(shapeids, newShapes);
                        this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {
                            return newShape.id;
                        });
                    } else {
                        target.replaceWithShape(shapeids, newShapes);
                        this.regionShapes[currentRegion] = newShapes.id;
                    }
                }
            },

            render: function () {
                var values = this.values,
                    target = this.target,
                    regionShapes = this.regionShapes,
                    shapes,
                    ids,
                    i,
                    j;

                if (!this.cls._super.render.call(this)) {
                    return;
                }
                for (i = values.length; i--;) {
                    shapes = this.renderRegion(i);
                    if (shapes) {
                        if ($.isArray(shapes)) {
                            ids = [];
                            for (j = shapes.length; j--;) {
                                shapes[j].append();
                                ids.push(shapes[j].id);
                            }
                            regionShapes[i] = ids;
                        } else {
                            shapes.append();
                            regionShapes[i] = shapes.id; // store just the shapeid
                        }
                    } else {
                        // null value
                        regionShapes[i] = null;
                    }
                }
                target.render();
            }
        };

        /**
         * Line charts
         */
        $.fn.sparkline.line = line = createClass($.fn.sparkline._base, {
            type: 'line',

            init: function (el, values, options, width, height) {
                line._super.init.call(this, el, values, options, width, height);
                this.vertices = [];
                this.regionMap = [];
                this.xvalues = [];
                this.yvalues = [];
                this.yminmax = [];
                this.hightlightSpotId = null;
                this.lastShapeId = null;
                this.initTarget();
            },

            getRegion: function (el, x, y) {
                var i,
                    regionMap = this.regionMap; // maps regions to value positions
                for (i = regionMap.length; i--;) {
                    if (regionMap[i] !== null && x >= regionMap[i][0] && x <= regionMap[i][1]) {
                        return regionMap[i][2];
                    }
                }
                return undefined;
            },

            getCurrentRegionFields: function () {
                var currentRegion = this.currentRegion;
                return {
                    isNull: this.yvalues[currentRegion] === null,
                    x: this.xvalues[currentRegion],
                    y: this.yvalues[currentRegion],
                    color: this.options.get('lineColor'),
                    fillColor: this.options.get('fillColor'),
                    offset: currentRegion
                };
            },

            renderHighlight: function () {
                var currentRegion = this.currentRegion,
                    target = this.target,
                    vertex = this.vertices[currentRegion],
                    options = this.options,
                    spotRadius = options.get('spotRadius'),
                    highlightSpotColor = options.get('highlightSpotColor'),
                    highlightLineColor = options.get('highlightLineColor'),
                    highlightSpot,
                    highlightLine;

                if (!vertex) {
                    return;
                }
                if (spotRadius && highlightSpotColor) {
                    highlightSpot = target.drawCircle(vertex[0], vertex[1], spotRadius, undefined, highlightSpotColor);
                    this.highlightSpotId = highlightSpot.id;
                    target.insertAfterShape(this.lastShapeId, highlightSpot);
                }
                if (highlightLineColor) {
                    highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0], this.canvasTop + this.canvasHeight, highlightLineColor);
                    this.highlightLineId = highlightLine.id;
                    target.insertAfterShape(this.lastShapeId, highlightLine);
                }
            },

            removeHighlight: function () {
                var target = this.target;
                if (this.highlightSpotId) {
                    target.removeShapeId(this.highlightSpotId);
                    this.highlightSpotId = null;
                }
                if (this.highlightLineId) {
                    target.removeShapeId(this.highlightLineId);
                    this.highlightLineId = null;
                }
            },

            scanValues: function () {
                var values = this.values,
                    valcount = values.length,
                    xvalues = this.xvalues,
                    yvalues = this.yvalues,
                    yminmax = this.yminmax,
                    i,
                    val,
                    isStr,
                    isArray,
                    sp;
                for (i = 0; i < valcount; i++) {
                    val = values[i];
                    isStr = typeof values[i] === 'string';
                    isArray = typeof values[i] === 'object' && values[i] instanceof Array;
                    sp = isStr && values[i].split(':');
                    if (isStr && sp.length === 2) {
                        // x:y
                        xvalues.push(Number(sp[0]));
                        yvalues.push(Number(sp[1]));
                        yminmax.push(Number(sp[1]));
                    } else if (isArray) {
                        xvalues.push(val[0]);
                        yvalues.push(val[1]);
                        yminmax.push(val[1]);
                    } else {
                        xvalues.push(i);
                        if (values[i] === null || values[i] === 'null') {
                            yvalues.push(null);
                        } else {
                            yvalues.push(Number(val));
                            yminmax.push(Number(val));
                        }
                    }
                }
                if (this.options.get('xvalues')) {
                    xvalues = this.options.get('xvalues');
                }

                this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);
                this.miny = this.minyorg = Math.min.apply(Math, yminmax);

                this.maxx = Math.max.apply(Math, xvalues);
                this.minx = Math.min.apply(Math, xvalues);

                this.xvalues = xvalues;
                this.yvalues = yvalues;
                this.yminmax = yminmax;
            },

            processRangeOptions: function () {
                var options = this.options,
                    normalRangeMin = options.get('normalRangeMin'),
                    normalRangeMax = options.get('normalRangeMax');

                if (normalRangeMin !== undefined) {
                    if (normalRangeMin < this.miny) {
                        this.miny = normalRangeMin;
                    }
                    if (normalRangeMax > this.maxy) {
                        this.maxy = normalRangeMax;
                    }
                }
                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.miny)) {
                    this.miny = options.get('chartRangeMin');
                }
                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.maxy)) {
                    this.maxy = options.get('chartRangeMax');
                }
                if (options.get('chartRangeMinX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMinX') < this.minx)) {
                    this.minx = options.get('chartRangeMinX');
                }
                if (options.get('chartRangeMaxX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMaxX') > this.maxx)) {
                    this.maxx = options.get('chartRangeMaxX');
                }
            },

            drawNormalRange: function (canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {
                var normalRangeMin = this.options.get('normalRangeMin'),
                    normalRangeMax = this.options.get('normalRangeMax'),
                    ytop = canvasTop + Math.round(canvasHeight - canvasHeight * ((normalRangeMax - this.miny) / rangey)),
                    height = Math.round(canvasHeight * (normalRangeMax - normalRangeMin) / rangey);
                this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get('normalRangeColor')).append();
            },

            render: function () {
                var options = this.options,
                    target = this.target,
                    canvasWidth = this.canvasWidth,
                    canvasHeight = this.canvasHeight,
                    vertices = this.vertices,
                    spotRadius = options.get('spotRadius'),
                    regionMap = this.regionMap,
                    rangex,
                    rangey,
                    yvallast,
                    canvasTop,
                    canvasLeft,
                    vertex,
                    path,
                    paths,
                    x,
                    y,
                    xnext,
                    xpos,
                    xposnext,
                    last,
                    next,
                    yvalcount,
                    lineShapes,
                    fillShapes,
                    plen,
                    valueSpots,
                    hlSpotsEnabled,
                    color,
                    xvalues,
                    yvalues,
                    i;

                if (!line._super.render.call(this)) {
                    return;
                }

                this.scanValues();
                this.processRangeOptions();

                xvalues = this.xvalues;
                yvalues = this.yvalues;

                if (!this.yminmax.length || this.yvalues.length < 2) {
                    // empty or all null valuess
                    return;
                }

                canvasTop = canvasLeft = 0;

                rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;
                rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;
                yvallast = this.yvalues.length - 1;

                if (spotRadius && (canvasWidth < spotRadius * 4 || canvasHeight < spotRadius * 4)) {
                    spotRadius = 0;
                }
                if (spotRadius) {
                    // adjust the canvas size as required so that spots will fit
                    hlSpotsEnabled = options.get('highlightSpotColor') && !options.get('disableInteraction');
                    if (hlSpotsEnabled || options.get('minSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.miny) {
                        canvasHeight -= Math.ceil(spotRadius);
                    }
                    if (hlSpotsEnabled || options.get('maxSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.maxy) {
                        canvasHeight -= Math.ceil(spotRadius);
                        canvasTop += Math.ceil(spotRadius);
                    }
                    if (hlSpotsEnabled || (options.get('minSpotColor') || options.get('maxSpotColor')) && (yvalues[0] === this.miny || yvalues[0] === this.maxy)) {
                        canvasLeft += Math.ceil(spotRadius);
                        canvasWidth -= Math.ceil(spotRadius);
                    }
                    if (hlSpotsEnabled || options.get('spotColor') || options.get('minSpotColor') || options.get('maxSpotColor') && (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy)) {
                        canvasWidth -= Math.ceil(spotRadius);
                    }
                }

                canvasHeight--;

                if (options.get('normalRangeMin') !== undefined && !options.get('drawNormalOnTop')) {
                    this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
                }

                path = [];
                paths = [path];
                last = next = null;
                yvalcount = yvalues.length;
                for (i = 0; i < yvalcount; i++) {
                    x = xvalues[i];
                    xnext = xvalues[i + 1];
                    y = yvalues[i];
                    xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));
                    xposnext = i < yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;
                    next = xpos + (xposnext - xpos) / 2;
                    regionMap[i] = [last || 0, next, i];
                    last = next;
                    if (y === null) {
                        if (i) {
                            if (yvalues[i - 1] !== null) {
                                path = [];
                                paths.push(path);
                            }
                            vertices.push(null);
                        }
                    } else {
                        if (y < this.miny) {
                            y = this.miny;
                        }
                        if (y > this.maxy) {
                            y = this.maxy;
                        }
                        if (!path.length) {
                            // previous value was null
                            path.push([xpos, canvasTop + canvasHeight]);
                        }
                        vertex = [xpos, canvasTop + Math.round(canvasHeight - canvasHeight * ((y - this.miny) / rangey))];
                        path.push(vertex);
                        vertices.push(vertex);
                    }
                }

                lineShapes = [];
                fillShapes = [];
                plen = paths.length;
                for (i = 0; i < plen; i++) {
                    path = paths[i];
                    if (path.length) {
                        if (options.get('fillColor')) {
                            path.push([path[path.length - 1][0], canvasTop + canvasHeight]);
                            fillShapes.push(path.slice(0));
                            path.pop();
                        }
                        // if there's only a single point in this path, then we want to display it
                        // as a vertical line which means we keep path[0]  as is
                        if (path.length > 2) {
                            // else we want the first value
                            path[0] = [path[0][0], path[1][1]];
                        }
                        lineShapes.push(path);
                    }
                }

                // draw the fill first, then optionally the normal range, then the line on top of that
                plen = fillShapes.length;
                for (i = 0; i < plen; i++) {
                    target.drawShape(fillShapes[i], options.get('fillColor'), options.get('fillColor')).append();
                }

                if (options.get('normalRangeMin') !== undefined && options.get('drawNormalOnTop')) {
                    this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
                }

                plen = lineShapes.length;
                for (i = 0; i < plen; i++) {
                    target.drawShape(lineShapes[i], options.get('lineColor'), undefined, options.get('lineWidth')).append();
                }

                if (spotRadius && options.get('valueSpots')) {
                    valueSpots = options.get('valueSpots');
                    if (valueSpots.get === undefined) {
                        valueSpots = new RangeMap(valueSpots);
                    }
                    for (i = 0; i < yvalcount; i++) {
                        color = valueSpots.get(yvalues[i]);
                        if (color) {
                            target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[i] - this.miny) / rangey)), spotRadius, undefined, color).append();
                        }
                    }
                }
                if (spotRadius && options.get('spotColor') && yvalues[yvallast] !== null) {
                    target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[yvallast] - this.miny) / rangey)), spotRadius, undefined, options.get('spotColor')).append();
                }
                if (this.maxy !== this.minyorg) {
                    if (spotRadius && options.get('minSpotColor')) {
                        x = xvalues[$.inArray(this.minyorg, yvalues)];
                        target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.minyorg - this.miny) / rangey)), spotRadius, undefined, options.get('minSpotColor')).append();
                    }
                    if (spotRadius && options.get('maxSpotColor')) {
                        x = xvalues[$.inArray(this.maxyorg, yvalues)];
                        target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.maxyorg - this.miny) / rangey)), spotRadius, undefined, options.get('maxSpotColor')).append();
                    }
                }

                this.lastShapeId = target.getLastShapeId();
                this.canvasTop = canvasTop;
                target.render();
            }
        });

        /**
         * Bar charts
         */
        $.fn.sparkline.bar = bar = createClass($.fn.sparkline._base, barHighlightMixin, {
            type: 'bar',

            init: function (el, values, options, width, height) {
                var barWidth = parseInt(options.get('barWidth'), 10),
                    barSpacing = parseInt(options.get('barSpacing'), 10),
                    chartRangeMin = options.get('chartRangeMin'),
                    chartRangeMax = options.get('chartRangeMax'),
                    chartRangeClip = options.get('chartRangeClip'),
                    stackMin = Infinity,
                    stackMax = -Infinity,
                    isStackString,
                    groupMin,
                    groupMax,
                    stackRanges,
                    numValues,
                    i,
                    vlen,
                    range,
                    zeroAxis,
                    xaxisOffset,
                    min,
                    max,
                    clipMin,
                    clipMax,
                    stacked,
                    vlist,
                    j,
                    slen,
                    svals,
                    val,
                    yoffset,
                    yMaxCalc,
                    canvasHeightEf;
                bar._super.init.call(this, el, values, options, width, height);

                // scan values to determine whether to stack bars
                for (i = 0, vlen = values.length; i < vlen; i++) {
                    val = values[i];
                    isStackString = typeof val === 'string' && val.indexOf(':') > -1;
                    if (isStackString || $.isArray(val)) {
                        stacked = true;
                        if (isStackString) {
                            val = values[i] = normalizeValues(val.split(':'));
                        }
                        val = remove(val, null); // min/max will treat null as zero
                        groupMin = Math.min.apply(Math, val);
                        groupMax = Math.max.apply(Math, val);
                        if (groupMin < stackMin) {
                            stackMin = groupMin;
                        }
                        if (groupMax > stackMax) {
                            stackMax = groupMax;
                        }
                    }
                }

                this.stacked = stacked;
                this.regionShapes = {};
                this.barWidth = barWidth;
                this.barSpacing = barSpacing;
                this.totalBarWidth = barWidth + barSpacing;
                this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;

                this.initTarget();

                if (chartRangeClip) {
                    clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;
                    clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;
                }

                numValues = [];
                stackRanges = stacked ? [] : numValues;
                var stackTotals = [];
                var stackRangesNeg = [];
                for (i = 0, vlen = values.length; i < vlen; i++) {
                    if (stacked) {
                        vlist = values[i];
                        values[i] = svals = [];
                        stackTotals[i] = 0;
                        stackRanges[i] = stackRangesNeg[i] = 0;
                        for (j = 0, slen = vlist.length; j < slen; j++) {
                            val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];
                            if (val !== null) {
                                if (val > 0) {
                                    stackTotals[i] += val;
                                }
                                if (stackMin < 0 && stackMax > 0) {
                                    if (val < 0) {
                                        stackRangesNeg[i] += Math.abs(val);
                                    } else {
                                        stackRanges[i] += val;
                                    }
                                } else {
                                    stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));
                                }
                                numValues.push(val);
                            }
                        }
                    } else {
                        val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];
                        val = values[i] = normalizeValue(val);
                        if (val !== null) {
                            numValues.push(val);
                        }
                    }
                }
                this.max = max = Math.max.apply(Math, numValues);
                this.min = min = Math.min.apply(Math, numValues);
                this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;
                this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;

                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < min)) {
                    min = options.get('chartRangeMin');
                }
                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > max)) {
                    max = options.get('chartRangeMax');
                }

                this.zeroAxis = zeroAxis = options.get('zeroAxis', true);
                if (min <= 0 && max >= 0 && zeroAxis) {
                    xaxisOffset = 0;
                } else if (zeroAxis == false) {
                    xaxisOffset = min;
                } else if (min > 0) {
                    xaxisOffset = min;
                } else {
                    xaxisOffset = max;
                }
                this.xaxisOffset = xaxisOffset;

                range = stacked ? Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg) : max - min;

                // as we plot zero/min values a single pixel line, we add a pixel to all other
                // values - Reduce the effective canvas size to suit
                this.canvasHeightEf = zeroAxis && min < 0 ? this.canvasHeight - 2 : this.canvasHeight - 1;

                if (min < xaxisOffset) {
                    yMaxCalc = stacked && max >= 0 ? stackMax : max;
                    yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;
                    if (yoffset !== Math.ceil(yoffset)) {
                        this.canvasHeightEf -= 2;
                        yoffset = Math.ceil(yoffset);
                    }
                } else {
                    yoffset = this.canvasHeight;
                }
                this.yoffset = yoffset;

                if ($.isArray(options.get('colorMap'))) {
                    this.colorMapByIndex = options.get('colorMap');
                    this.colorMapByValue = null;
                } else {
                    this.colorMapByIndex = null;
                    this.colorMapByValue = options.get('colorMap');
                    if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
                        this.colorMapByValue = new RangeMap(this.colorMapByValue);
                    }
                }

                this.range = range;
            },

            getRegion: function (el, x, y) {
                var result = Math.floor(x / this.totalBarWidth);
                return result < 0 || result >= this.values.length ? undefined : result;
            },

            getCurrentRegionFields: function () {
                var currentRegion = this.currentRegion,
                    values = ensureArray(this.values[currentRegion]),
                    result = [],
                    value,
                    i;
                for (i = values.length; i--;) {
                    value = values[i];
                    result.push({
                        isNull: value === null,
                        value: value,
                        color: this.calcColor(i, value, currentRegion),
                        offset: currentRegion
                    });
                }
                return result;
            },

            calcColor: function (stacknum, value, valuenum) {
                var colorMapByIndex = this.colorMapByIndex,
                    colorMapByValue = this.colorMapByValue,
                    options = this.options,
                    color,
                    newColor;
                if (this.stacked) {
                    color = options.get('stackedBarColor');
                } else {
                    color = value < 0 ? options.get('negBarColor') : options.get('barColor');
                }
                if (value === 0 && options.get('zeroColor') !== undefined) {
                    color = options.get('zeroColor');
                }
                if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
                    color = newColor;
                } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
                    color = colorMapByIndex[valuenum];
                }
                return $.isArray(color) ? color[stacknum % color.length] : color;
            },

            /**
             * Render bar(s) for a region
             */
            renderRegion: function (valuenum, highlight) {
                var vals = this.values[valuenum],
                    options = this.options,
                    xaxisOffset = this.xaxisOffset,
                    result = [],
                    range = this.range,
                    stacked = this.stacked,
                    target = this.target,
                    x = valuenum * this.totalBarWidth,
                    canvasHeightEf = this.canvasHeightEf,
                    yoffset = this.yoffset,
                    y,
                    height,
                    color,
                    isNull,
                    yoffsetNeg,
                    i,
                    valcount,
                    val,
                    minPlotted,
                    allMin;

                vals = $.isArray(vals) ? vals : [vals];
                valcount = vals.length;
                val = vals[0];
                isNull = all(null, vals);
                allMin = all(xaxisOffset, vals, true);

                if (isNull) {
                    if (options.get('nullColor')) {
                        color = highlight ? options.get('nullColor') : this.calcHighlightColor(options.get('nullColor'), options);
                        y = yoffset > 0 ? yoffset - 1 : yoffset;
                        return target.drawRect(x, y, this.barWidth - 1, 0, color, color);
                    } else {
                        return undefined;
                    }
                }
                yoffsetNeg = yoffset;
                for (i = 0; i < valcount; i++) {
                    val = vals[i];

                    if (stacked && val === xaxisOffset) {
                        if (!allMin || minPlotted) {
                            continue;
                        }
                        minPlotted = true;
                    }

                    if (range > 0) {
                        height = Math.floor(canvasHeightEf * (Math.abs(val - xaxisOffset) / range)) + 1;
                    } else {
                        height = 1;
                    }
                    if (val < xaxisOffset || val === xaxisOffset && yoffset === 0) {
                        y = yoffsetNeg;
                        yoffsetNeg += height;
                    } else {
                        y = yoffset - height;
                        yoffset -= height;
                    }
                    color = this.calcColor(i, val, valuenum);
                    if (highlight) {
                        color = this.calcHighlightColor(color, options);
                    }
                    result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));
                }
                if (result.length === 1) {
                    return result[0];
                }
                return result;
            }
        });

        /**
         * Tristate charts
         */
        $.fn.sparkline.tristate = tristate = createClass($.fn.sparkline._base, barHighlightMixin, {
            type: 'tristate',

            init: function (el, values, options, width, height) {
                var barWidth = parseInt(options.get('barWidth'), 10),
                    barSpacing = parseInt(options.get('barSpacing'), 10);
                tristate._super.init.call(this, el, values, options, width, height);

                this.regionShapes = {};
                this.barWidth = barWidth;
                this.barSpacing = barSpacing;
                this.totalBarWidth = barWidth + barSpacing;
                this.values = $.map(values, Number);
                this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;

                if ($.isArray(options.get('colorMap'))) {
                    this.colorMapByIndex = options.get('colorMap');
                    this.colorMapByValue = null;
                } else {
                    this.colorMapByIndex = null;
                    this.colorMapByValue = options.get('colorMap');
                    if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
                        this.colorMapByValue = new RangeMap(this.colorMapByValue);
                    }
                }
                this.initTarget();
            },

            getRegion: function (el, x, y) {
                return Math.floor(x / this.totalBarWidth);
            },

            getCurrentRegionFields: function () {
                var currentRegion = this.currentRegion;
                return {
                    isNull: this.values[currentRegion] === undefined,
                    value: this.values[currentRegion],
                    color: this.calcColor(this.values[currentRegion], currentRegion),
                    offset: currentRegion
                };
            },

            calcColor: function (value, valuenum) {
                var values = this.values,
                    options = this.options,
                    colorMapByIndex = this.colorMapByIndex,
                    colorMapByValue = this.colorMapByValue,
                    color,
                    newColor;

                if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
                    color = newColor;
                } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
                    color = colorMapByIndex[valuenum];
                } else if (values[valuenum] < 0) {
                    color = options.get('negBarColor');
                } else if (values[valuenum] > 0) {
                    color = options.get('posBarColor');
                } else {
                    color = options.get('zeroBarColor');
                }
                return color;
            },

            renderRegion: function (valuenum, highlight) {
                var values = this.values,
                    options = this.options,
                    target = this.target,
                    canvasHeight,
                    height,
                    halfHeight,
                    x,
                    y,
                    color;

                canvasHeight = target.pixelHeight;
                halfHeight = Math.round(canvasHeight / 2);

                x = valuenum * this.totalBarWidth;
                if (values[valuenum] < 0) {
                    y = halfHeight;
                    height = halfHeight - 1;
                } else if (values[valuenum] > 0) {
                    y = 0;
                    height = halfHeight - 1;
                } else {
                    y = halfHeight - 1;
                    height = 2;
                }
                color = this.calcColor(values[valuenum], valuenum);
                if (color === null) {
                    return;
                }
                if (highlight) {
                    color = this.calcHighlightColor(color, options);
                }
                return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);
            }
        });

        /**
         * Discrete charts
         */
        $.fn.sparkline.discrete = discrete = createClass($.fn.sparkline._base, barHighlightMixin, {
            type: 'discrete',

            init: function (el, values, options, width, height) {
                discrete._super.init.call(this, el, values, options, width, height);

                this.regionShapes = {};
                this.values = values = $.map(values, Number);
                this.min = Math.min.apply(Math, values);
                this.max = Math.max.apply(Math, values);
                this.range = this.max - this.min;
                this.width = width = options.get('width') === 'auto' ? values.length * 2 : this.width;
                this.interval = Math.floor(width / values.length);
                this.itemWidth = width / values.length;
                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.min)) {
                    this.min = options.get('chartRangeMin');
                }
                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.max)) {
                    this.max = options.get('chartRangeMax');
                }
                this.initTarget();
                if (this.target) {
                    this.lineHeight = options.get('lineHeight') === 'auto' ? Math.round(this.canvasHeight * 0.3) : options.get('lineHeight');
                }
            },

            getRegion: function (el, x, y) {
                return Math.floor(x / this.itemWidth);
            },

            getCurrentRegionFields: function () {
                var currentRegion = this.currentRegion;
                return {
                    isNull: this.values[currentRegion] === undefined,
                    value: this.values[currentRegion],
                    offset: currentRegion
                };
            },

            renderRegion: function (valuenum, highlight) {
                var values = this.values,
                    options = this.options,
                    min = this.min,
                    max = this.max,
                    range = this.range,
                    interval = this.interval,
                    target = this.target,
                    canvasHeight = this.canvasHeight,
                    lineHeight = this.lineHeight,
                    pheight = canvasHeight - lineHeight,
                    ytop,
                    val,
                    color,
                    x;

                val = clipval(values[valuenum], min, max);
                x = valuenum * interval;
                ytop = Math.round(pheight - pheight * ((val - min) / range));
                color = options.get('thresholdColor') && val < options.get('thresholdValue') ? options.get('thresholdColor') : options.get('lineColor');
                if (highlight) {
                    color = this.calcHighlightColor(color, options);
                }
                return target.drawLine(x, ytop, x, ytop + lineHeight, color);
            }
        });

        /**
         * Bullet charts
         */
        $.fn.sparkline.bullet = bullet = createClass($.fn.sparkline._base, {
            type: 'bullet',

            init: function (el, values, options, width, height) {
                var min, max, vals;
                bullet._super.init.call(this, el, values, options, width, height);

                // values: target, performance, range1, range2, range3
                this.values = values = normalizeValues(values);
                // target or performance could be null
                vals = values.slice();
                vals[0] = vals[0] === null ? vals[2] : vals[0];
                vals[1] = values[1] === null ? vals[2] : vals[1];
                min = Math.min.apply(Math, values);
                max = Math.max.apply(Math, values);
                if (options.get('base') === undefined) {
                    min = min < 0 ? min : 0;
                } else {
                    min = options.get('base');
                }
                this.min = min;
                this.max = max;
                this.range = max - min;
                this.shapes = {};
                this.valueShapes = {};
                this.regiondata = {};
                this.width = width = options.get('width') === 'auto' ? '4.0em' : width;
                this.target = this.$el.simpledraw(width, height, options.get('composite'));
                if (!values.length) {
                    this.disabled = true;
                }
                this.initTarget();
            },

            getRegion: function (el, x, y) {
                var shapeid = this.target.getShapeAt(el, x, y);
                return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;
            },

            getCurrentRegionFields: function () {
                var currentRegion = this.currentRegion;
                return {
                    fieldkey: currentRegion.substr(0, 1),
                    value: this.values[currentRegion.substr(1)],
                    region: currentRegion
                };
            },

            changeHighlight: function (highlight) {
                var currentRegion = this.currentRegion,
                    shapeid = this.valueShapes[currentRegion],
                    shape;
                delete this.shapes[shapeid];
                switch (currentRegion.substr(0, 1)) {
                    case 'r':
                        shape = this.renderRange(currentRegion.substr(1), highlight);
                        break;
                    case 'p':
                        shape = this.renderPerformance(highlight);
                        break;
                    case 't':
                        shape = this.renderTarget(highlight);
                        break;
                }
                this.valueShapes[currentRegion] = shape.id;
                this.shapes[shape.id] = currentRegion;
                this.target.replaceWithShape(shapeid, shape);
            },

            renderRange: function (rn, highlight) {
                var rangeval = this.values[rn],
                    rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)),
                    color = this.options.get('rangeColors')[rn - 2];
                if (highlight) {
                    color = this.calcHighlightColor(color, this.options);
                }
                return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);
            },

            renderPerformance: function (highlight) {
                var perfval = this.values[1],
                    perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)),
                    color = this.options.get('performanceColor');
                if (highlight) {
                    color = this.calcHighlightColor(color, this.options);
                }
                return this.target.drawRect(0, Math.round(this.canvasHeight * 0.3), perfwidth - 1, Math.round(this.canvasHeight * 0.4) - 1, color, color);
            },

            renderTarget: function (highlight) {
                var targetval = this.values[0],
                    x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - this.options.get('targetWidth') / 2),
                    targettop = Math.round(this.canvasHeight * 0.10),
                    targetheight = this.canvasHeight - targettop * 2,
                    color = this.options.get('targetColor');
                if (highlight) {
                    color = this.calcHighlightColor(color, this.options);
                }
                return this.target.drawRect(x, targettop, this.options.get('targetWidth') - 1, targetheight - 1, color, color);
            },

            render: function () {
                var vlen = this.values.length,
                    target = this.target,
                    i,
                    shape;
                if (!bullet._super.render.call(this)) {
                    return;
                }
                for (i = 2; i < vlen; i++) {
                    shape = this.renderRange(i).append();
                    this.shapes[shape.id] = 'r' + i;
                    this.valueShapes['r' + i] = shape.id;
                }
                if (this.values[1] !== null) {
                    shape = this.renderPerformance().append();
                    this.shapes[shape.id] = 'p1';
                    this.valueShapes.p1 = shape.id;
                }
                if (this.values[0] !== null) {
                    shape = this.renderTarget().append();
                    this.shapes[shape.id] = 't0';
                    this.valueShapes.t0 = shape.id;
                }
                target.render();
            }
        });

        /**
         * Pie charts
         */
        $.fn.sparkline.pie = pie = createClass($.fn.sparkline._base, {
            type: 'pie',

            init: function (el, values, options, width, height) {
                var total = 0,
                    i;

                pie._super.init.call(this, el, values, options, width, height);

                this.shapes = {}; // map shape ids to value offsets
                this.valueShapes = {}; // maps value offsets to shape ids
                this.values = values = $.map(values, Number);

                if (options.get('width') === 'auto') {
                    this.width = this.height;
                }

                if (values.length > 0) {
                    for (i = values.length; i--;) {
                        total += values[i];
                    }
                }
                this.total = total;
                this.initTarget();
                this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);
            },

            getRegion: function (el, x, y) {
                var shapeid = this.target.getShapeAt(el, x, y);
                return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;
            },

            getCurrentRegionFields: function () {
                var currentRegion = this.currentRegion;
                return {
                    isNull: this.values[currentRegion] === undefined,
                    value: this.values[currentRegion],
                    percent: this.values[currentRegion] / this.total * 100,
                    color: this.options.get('sliceColors')[currentRegion % this.options.get('sliceColors').length],
                    offset: currentRegion
                };
            },

            changeHighlight: function (highlight) {
                var currentRegion = this.currentRegion,
                    newslice = this.renderSlice(currentRegion, highlight),
                    shapeid = this.valueShapes[currentRegion];
                delete this.shapes[shapeid];
                this.target.replaceWithShape(shapeid, newslice);
                this.valueShapes[currentRegion] = newslice.id;
                this.shapes[newslice.id] = currentRegion;
            },

            renderSlice: function (valuenum, highlight) {
                var target = this.target,
                    options = this.options,
                    radius = this.radius,
                    borderWidth = options.get('borderWidth'),
                    offset = options.get('offset'),
                    circle = 2 * Math.PI,
                    values = this.values,
                    total = this.total,
                    next = offset ? 2 * Math.PI * (offset / 360) : 0,
                    start,
                    end,
                    i,
                    vlen,
                    color;

                vlen = values.length;
                for (i = 0; i < vlen; i++) {
                    start = next;
                    end = next;
                    if (total > 0) {
                        // avoid divide by zero
                        end = next + circle * (values[i] / total);
                    }
                    if (valuenum === i) {
                        color = options.get('sliceColors')[i % options.get('sliceColors').length];
                        if (highlight) {
                            color = this.calcHighlightColor(color, options);
                        }

                        return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);
                    }
                    next = end;
                }
            },

            render: function () {
                var target = this.target,
                    values = this.values,
                    options = this.options,
                    radius = this.radius,
                    borderWidth = options.get('borderWidth'),
                    donutWidth = options.get('donutWidth'),
                    shape,
                    i;

                if (!pie._super.render.call(this)) {
                    return;
                }
                if (borderWidth) {
                    target.drawCircle(radius, radius, Math.floor(radius - borderWidth / 2), options.get('borderColor'), undefined, borderWidth).append();
                }
                for (i = values.length; i--;) {
                    if (values[i]) {
                        // don't render zero values
                        shape = this.renderSlice(i).append();
                        this.valueShapes[i] = shape.id; // store just the shapeid
                        this.shapes[shape.id] = i;
                    }
                }
                if (donutWidth) {
                    target.drawCircle(radius, radius, radius - donutWidth, options.get('donutColor'), options.get('donutColor'), 0).append();
                }
                target.render();
            }
        });

        /**
         * Box plots
         */
        $.fn.sparkline.box = box = createClass($.fn.sparkline._base, {
            type: 'box',

            init: function (el, values, options, width, height) {
                box._super.init.call(this, el, values, options, width, height);
                this.values = $.map(values, Number);
                this.width = options.get('width') === 'auto' ? '4.0em' : width;
                this.initTarget();
                if (!this.values.length) {
                    this.disabled = 1;
                }
            },

            /**
             * Simulate a single region
             */
            getRegion: function () {
                return 1;
            },

            getCurrentRegionFields: function () {
                var result = [{ field: 'lq', value: this.quartiles[0] }, { field: 'med', value: this.quartiles[1] }, { field: 'uq', value: this.quartiles[2] }];
                if (this.loutlier !== undefined) {
                    result.push({ field: 'lo', value: this.loutlier });
                }
                if (this.routlier !== undefined) {
                    result.push({ field: 'ro', value: this.routlier });
                }
                if (this.lwhisker !== undefined) {
                    result.push({ field: 'lw', value: this.lwhisker });
                }
                if (this.rwhisker !== undefined) {
                    result.push({ field: 'rw', value: this.rwhisker });
                }
                return result;
            },

            render: function () {
                var target = this.target,
                    values = this.values,
                    vlen = values.length,
                    options = this.options,
                    canvasWidth = this.canvasWidth,
                    canvasHeight = this.canvasHeight,
                    minValue = options.get('chartRangeMin') === undefined ? Math.min.apply(Math, values) : options.get('chartRangeMin'),
                    maxValue = options.get('chartRangeMax') === undefined ? Math.max.apply(Math, values) : options.get('chartRangeMax'),
                    canvasLeft = 0,
                    lwhisker,
                    loutlier,
                    iqr,
                    q1,
                    q2,
                    q3,
                    rwhisker,
                    routlier,
                    i,
                    size,
                    unitSize;

                if (!box._super.render.call(this)) {
                    return;
                }

                if (options.get('raw')) {
                    if (options.get('showOutliers') && values.length > 5) {
                        loutlier = values[0];
                        lwhisker = values[1];
                        q1 = values[2];
                        q2 = values[3];
                        q3 = values[4];
                        rwhisker = values[5];
                        routlier = values[6];
                    } else {
                        lwhisker = values[0];
                        q1 = values[1];
                        q2 = values[2];
                        q3 = values[3];
                        rwhisker = values[4];
                    }
                } else {
                    values.sort(function (a, b) {
                        return a - b;
                    });
                    q1 = quartile(values, 1);
                    q2 = quartile(values, 2);
                    q3 = quartile(values, 3);
                    iqr = q3 - q1;
                    if (options.get('showOutliers')) {
                        lwhisker = rwhisker = undefined;
                        for (i = 0; i < vlen; i++) {
                            if (lwhisker === undefined && values[i] > q1 - iqr * options.get('outlierIQR')) {
                                lwhisker = values[i];
                            }
                            if (values[i] < q3 + iqr * options.get('outlierIQR')) {
                                rwhisker = values[i];
                            }
                        }
                        loutlier = values[0];
                        routlier = values[vlen - 1];
                    } else {
                        lwhisker = values[0];
                        rwhisker = values[vlen - 1];
                    }
                }
                this.quartiles = [q1, q2, q3];
                this.lwhisker = lwhisker;
                this.rwhisker = rwhisker;
                this.loutlier = loutlier;
                this.routlier = routlier;

                unitSize = canvasWidth / (maxValue - minValue + 1);
                if (options.get('showOutliers')) {
                    canvasLeft = Math.ceil(options.get('spotRadius'));
                    canvasWidth -= 2 * Math.ceil(options.get('spotRadius'));
                    unitSize = canvasWidth / (maxValue - minValue + 1);
                    if (loutlier < lwhisker) {
                        target.drawCircle((loutlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();
                    }
                    if (routlier > rwhisker) {
                        target.drawCircle((routlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();
                    }
                }

                // box
                target.drawRect(Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q3 - q1) * unitSize), Math.round(canvasHeight * 0.8), options.get('boxLineColor'), options.get('boxFillColor')).append();
                // left whisker
                target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();
                target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append();
                // right whisker
                target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q3 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();
                target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append();
                // median line
                target.drawLine(Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.9), options.get('medianColor')).append();
                if (options.get('target')) {
                    size = Math.ceil(options.get('spotRadius'));
                    target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 - size), Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 + size), options.get('targetColor')).append();
                    target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft - size), Math.round(canvasHeight / 2), Math.round((options.get('target') - minValue) * unitSize + canvasLeft + size), Math.round(canvasHeight / 2), options.get('targetColor')).append();
                }
                target.render();
            }
        });

        // Setup a very simple "virtual canvas" to make drawing the few shapes we need easier
        // This is accessible as $(foo).simpledraw()

        VShape = createClass({
            init: function (target, id, type, args) {
                this.target = target;
                this.id = id;
                this.type = type;
                this.args = args;
            },
            append: function () {
                this.target.appendShape(this);
                return this;
            }
        });

        VCanvas_base = createClass({
            _pxregex: /(\d+)(px)?\s*$/i,

            init: function (width, height, target) {
                if (!width) {
                    return;
                }
                this.width = width;
                this.height = height;
                this.target = target;
                this.lastShapeId = null;
                if (target[0]) {
                    target = target[0];
                }
                $.data(target, '_jqs_vcanvas', this);
            },

            drawLine: function (x1, y1, x2, y2, lineColor, lineWidth) {
                return this.drawShape([[x1, y1], [x2, y2]], lineColor, lineWidth);
            },

            drawShape: function (path, lineColor, fillColor, lineWidth) {
                return this._genShape('Shape', [path, lineColor, fillColor, lineWidth]);
            },

            drawCircle: function (x, y, radius, lineColor, fillColor, lineWidth) {
                return this._genShape('Circle', [x, y, radius, lineColor, fillColor, lineWidth]);
            },

            drawPieSlice: function (x, y, radius, startAngle, endAngle, lineColor, fillColor) {
                return this._genShape('PieSlice', [x, y, radius, startAngle, endAngle, lineColor, fillColor]);
            },

            drawRect: function (x, y, width, height, lineColor, fillColor) {
                return this._genShape('Rect', [x, y, width, height, lineColor, fillColor]);
            },

            getElement: function () {
                return this.canvas;
            },

            /**
             * Return the most recently inserted shape id
             */
            getLastShapeId: function () {
                return this.lastShapeId;
            },

            /**
             * Clear and reset the canvas
             */
            reset: function () {
                alert('reset not implemented');
            },

            _insert: function (el, target) {
                $(target).html(el);
            },

            /**
             * Calculate the pixel dimensions of the canvas
             */
            _calculatePixelDims: function (width, height, canvas) {
                // XXX This should probably be a configurable option
                var match;
                match = this._pxregex.exec(height);
                if (match) {
                    this.pixelHeight = match[1];
                } else {
                    this.pixelHeight = $(canvas).height();
                }
                match = this._pxregex.exec(width);
                if (match) {
                    this.pixelWidth = match[1];
                } else {
                    this.pixelWidth = $(canvas).width();
                }
            },

            /**
             * Generate a shape object and id for later rendering
             */
            _genShape: function (shapetype, shapeargs) {
                var id = shapeCount++;
                shapeargs.unshift(id);
                return new VShape(this, id, shapetype, shapeargs);
            },

            /**
             * Add a shape to the end of the render queue
             */
            appendShape: function (shape) {
                alert('appendShape not implemented');
            },

            /**
             * Replace one shape with another
             */
            replaceWithShape: function (shapeid, shape) {
                alert('replaceWithShape not implemented');
            },

            /**
             * Insert one shape after another in the render queue
             */
            insertAfterShape: function (shapeid, shape) {
                alert('insertAfterShape not implemented');
            },

            /**
             * Remove a shape from the queue
             */
            removeShapeId: function (shapeid) {
                alert('removeShapeId not implemented');
            },

            /**
             * Find a shape at the specified x/y co-ordinates
             */
            getShapeAt: function (el, x, y) {
                alert('getShapeAt not implemented');
            },

            /**
             * Render all queued shapes onto the canvas
             */
            render: function () {
                alert('render not implemented');
            }
        });

        VCanvas_canvas = createClass(VCanvas_base, {
            init: function (width, height, target, interact) {
                VCanvas_canvas._super.init.call(this, width, height, target);
                this.canvas = document.createElement('canvas');
                if (target[0]) {
                    target = target[0];
                }
                $.data(target, '_jqs_vcanvas', this);
                $(this.canvas).css({ display: 'inline-block', width: width, height: height, verticalAlign: 'top' });
                this._insert(this.canvas, target);
                this._calculatePixelDims(width, height, this.canvas);
                this.canvas.width = this.pixelWidth;
                this.canvas.height = this.pixelHeight;
                this.interact = interact;
                this.shapes = {};
                this.shapeseq = [];
                this.currentTargetShapeId = undefined;
                $(this.canvas).css({ width: this.pixelWidth, height: this.pixelHeight });
            },

            _getContext: function (lineColor, fillColor, lineWidth) {
                var context = this.canvas.getContext('2d');
                if (lineColor !== undefined) {
                    context.strokeStyle = lineColor;
                }
                context.lineWidth = lineWidth === undefined ? 1 : lineWidth;
                if (fillColor !== undefined) {
                    context.fillStyle = fillColor;
                }
                return context;
            },

            reset: function () {
                var context = this._getContext();
                context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
                this.shapes = {};
                this.shapeseq = [];
                this.currentTargetShapeId = undefined;
            },

            _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {
                var context = this._getContext(lineColor, fillColor, lineWidth),
                    i,
                    plen;
                context.beginPath();
                context.moveTo(path[0][0] + 0.5, path[0][1] + 0.5);
                for (i = 1, plen = path.length; i < plen; i++) {
                    context.lineTo(path[i][0] + 0.5, path[i][1] + 0.5); // the 0.5 offset gives us crisp pixel-width lines
                }
                if (lineColor !== undefined) {
                    context.stroke();
                }
                if (fillColor !== undefined) {
                    context.fill();
                }
                if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {
                    this.currentTargetShapeId = shapeid;
                }
            },

            _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
                var context = this._getContext(lineColor, fillColor, lineWidth);
                context.beginPath();
                context.arc(x, y, radius, 0, 2 * Math.PI, false);
                if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {
                    this.currentTargetShapeId = shapeid;
                }
                if (lineColor !== undefined) {
                    context.stroke();
                }
                if (fillColor !== undefined) {
                    context.fill();
                }
            },

            _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
                var context = this._getContext(lineColor, fillColor);
                context.beginPath();
                context.moveTo(x, y);
                context.arc(x, y, radius, startAngle, endAngle, false);
                context.lineTo(x, y);
                context.closePath();
                if (lineColor !== undefined) {
                    context.stroke();
                }
                if (fillColor) {
                    context.fill();
                }
                if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {
                    this.currentTargetShapeId = shapeid;
                }
            },

            _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {
                return this._drawShape(shapeid, [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]], lineColor, fillColor);
            },

            appendShape: function (shape) {
                this.shapes[shape.id] = shape;
                this.shapeseq.push(shape.id);
                this.lastShapeId = shape.id;
                return shape.id;
            },

            replaceWithShape: function (shapeid, shape) {
                var shapeseq = this.shapeseq,
                    i;
                this.shapes[shape.id] = shape;
                for (i = shapeseq.length; i--;) {
                    if (shapeseq[i] == shapeid) {
                        shapeseq[i] = shape.id;
                    }
                }
                delete this.shapes[shapeid];
            },

            replaceWithShapes: function (shapeids, shapes) {
                var shapeseq = this.shapeseq,
                    shapemap = {},
                    sid,
                    i,
                    first;

                for (i = shapeids.length; i--;) {
                    shapemap[shapeids[i]] = true;
                }
                for (i = shapeseq.length; i--;) {
                    sid = shapeseq[i];
                    if (shapemap[sid]) {
                        shapeseq.splice(i, 1);
                        delete this.shapes[sid];
                        first = i;
                    }
                }
                for (i = shapes.length; i--;) {
                    shapeseq.splice(first, 0, shapes[i].id);
                    this.shapes[shapes[i].id] = shapes[i];
                }
            },

            insertAfterShape: function (shapeid, shape) {
                var shapeseq = this.shapeseq,
                    i;
                for (i = shapeseq.length; i--;) {
                    if (shapeseq[i] === shapeid) {
                        shapeseq.splice(i + 1, 0, shape.id);
                        this.shapes[shape.id] = shape;
                        return;
                    }
                }
            },

            removeShapeId: function (shapeid) {
                var shapeseq = this.shapeseq,
                    i;
                for (i = shapeseq.length; i--;) {
                    if (shapeseq[i] === shapeid) {
                        shapeseq.splice(i, 1);
                        break;
                    }
                }
                delete this.shapes[shapeid];
            },

            getShapeAt: function (el, x, y) {
                this.targetX = x;
                this.targetY = y;
                this.render();
                return this.currentTargetShapeId;
            },

            render: function () {
                var shapeseq = this.shapeseq,
                    shapes = this.shapes,
                    shapeCount = shapeseq.length,
                    context = this._getContext(),
                    shapeid,
                    shape,
                    i;
                context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
                for (i = 0; i < shapeCount; i++) {
                    shapeid = shapeseq[i];
                    shape = shapes[shapeid];
                    this['_draw' + shape.type].apply(this, shape.args);
                }
                if (!this.interact) {
                    // not interactive so no need to keep the shapes array
                    this.shapes = {};
                    this.shapeseq = [];
                }
            }

        });

        VCanvas_vml = createClass(VCanvas_base, {
            init: function (width, height, target) {
                var groupel;
                VCanvas_vml._super.init.call(this, width, height, target);
                if (target[0]) {
                    target = target[0];
                }
                $.data(target, '_jqs_vcanvas', this);
                this.canvas = document.createElement('span');
                $(this.canvas).css({ display: 'inline-block', position: 'relative', overflow: 'hidden', width: width, height: height, margin: '0px', padding: '0px', verticalAlign: 'top' });
                this._insert(this.canvas, target);
                this._calculatePixelDims(width, height, this.canvas);
                this.canvas.width = this.pixelWidth;
                this.canvas.height = this.pixelHeight;
                groupel = '<v:group coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '"' + ' style="position:absolute;top:0;left:0;width:' + this.pixelWidth + 'px;height=' + this.pixelHeight + 'px;"></v:group>';
                this.canvas.insertAdjacentHTML('beforeEnd', groupel);
                this.group = $(this.canvas).children()[0];
                this.rendered = false;
                this.prerender = '';
            },

            _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {
                var vpath = [],
                    initial,
                    stroke,
                    fill,
                    closed,
                    vel,
                    plen,
                    i;
                for (i = 0, plen = path.length; i < plen; i++) {
                    vpath[i] = '' + path[i][0] + ',' + path[i][1];
                }
                initial = vpath.splice(0, 1);
                lineWidth = lineWidth === undefined ? 1 : lineWidth;
                stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
                fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
                closed = vpath[0] === vpath[vpath.length - 1] ? 'x ' : '';
                vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' + ' id="jqsshape' + shapeid + '" ' + stroke + fill + ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;" ' + ' path="m ' + initial + ' l ' + vpath.join(', ') + ' ' + closed + 'e">' + ' </v:shape>';
                return vel;
            },

            _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
                var stroke, fill, vel;
                x -= radius;
                y -= radius;
                stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
                fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
                vel = '<v:oval ' + ' id="jqsshape' + shapeid + '" ' + stroke + fill + ' style="position:absolute;top:' + y + 'px; left:' + x + 'px; width:' + radius * 2 + 'px; height:' + radius * 2 + 'px"></v:oval>';
                return vel;
            },

            _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
                var vpath, startx, starty, endx, endy, stroke, fill, vel;
                if (startAngle === endAngle) {
                    return ''; // VML seems to have problem when start angle equals end angle.
                }
                if (endAngle - startAngle === 2 * Math.PI) {
                    startAngle = 0.0; // VML seems to have a problem when drawing a full circle that doesn't start 0
                    endAngle = 2 * Math.PI;
                }

                startx = x + Math.round(Math.cos(startAngle) * radius);
                starty = y + Math.round(Math.sin(startAngle) * radius);
                endx = x + Math.round(Math.cos(endAngle) * radius);
                endy = y + Math.round(Math.sin(endAngle) * radius);

                if (startx === endx && starty === endy) {
                    if (endAngle - startAngle < Math.PI) {
                        // Prevent very small slices from being mistaken as a whole pie
                        return '';
                    }
                    // essentially going to be the entire circle, so ignore startAngle
                    startx = endx = x + radius;
                    starty = endy = y;
                }

                if (startx === endx && starty === endy && endAngle - startAngle < Math.PI) {
                    return '';
                }

                vpath = [x - radius, y - radius, x + radius, y + radius, startx, starty, endx, endy];
                stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="1px" strokeColor="' + lineColor + '" ';
                fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
                vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' + ' id="jqsshape' + shapeid + '" ' + stroke + fill + ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;" ' + ' path="m ' + x + ',' + y + ' wa ' + vpath.join(', ') + ' x e">' + ' </v:shape>';
                return vel;
            },

            _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {
                return this._drawShape(shapeid, [[x, y], [x, y + height], [x + width, y + height], [x + width, y], [x, y]], lineColor, fillColor);
            },

            reset: function () {
                this.group.innerHTML = '';
            },

            appendShape: function (shape) {
                var vel = this['_draw' + shape.type].apply(this, shape.args);
                if (this.rendered) {
                    this.group.insertAdjacentHTML('beforeEnd', vel);
                } else {
                    this.prerender += vel;
                }
                this.lastShapeId = shape.id;
                return shape.id;
            },

            replaceWithShape: function (shapeid, shape) {
                var existing = $('#jqsshape' + shapeid),
                    vel = this['_draw' + shape.type].apply(this, shape.args);
                existing[0].outerHTML = vel;
            },

            replaceWithShapes: function (shapeids, shapes) {
                // replace the first shapeid with all the new shapes then toast the remaining old shapes
                var existing = $('#jqsshape' + shapeids[0]),
                    replace = '',
                    slen = shapes.length,
                    i;
                for (i = 0; i < slen; i++) {
                    replace += this['_draw' + shapes[i].type].apply(this, shapes[i].args);
                }
                existing[0].outerHTML = replace;
                for (i = 1; i < shapeids.length; i++) {
                    $('#jqsshape' + shapeids[i]).remove();
                }
            },

            insertAfterShape: function (shapeid, shape) {
                var existing = $('#jqsshape' + shapeid),
                    vel = this['_draw' + shape.type].apply(this, shape.args);
                existing[0].insertAdjacentHTML('afterEnd', vel);
            },

            removeShapeId: function (shapeid) {
                var existing = $('#jqsshape' + shapeid);
                this.group.removeChild(existing[0]);
            },

            getShapeAt: function (el, x, y) {
                var shapeid = el.id.substr(8);
                return shapeid;
            },

            render: function () {
                if (!this.rendered) {
                    // batch the intial render into a single repaint
                    this.group.innerHTML = this.prerender;
                    this.rendered = true;
                }
            }
        });
    });
})(document, Math);
System.registerDynamic("reactiveadmintemplate/scripts/modules/charts/spark.js", ["sparkline"], true, function ($__require, exports, module) {
    'use strict';

    var global = this || self,
        GLOBAL = global;
    Object.defineProperty(exports, "__esModule", { value: true });
    /*!
     * @version: 1.1.2
     * @name: spark
     *
     * @author: https://themeforest.net/user/flexlayers
     */
    $__require("sparkline");
    $(function () {
        var sparkOptions = {};
        $('.spark-line').each(function () {
            var _this = this;
            var opIndex = $(this).data('options');
            var options = {
                enableTagOptions: true,
                // disableInteraction: true,
                width: $(this).hasClass('spark-line-full') ? '100%' : 'auto',
                highlightLineColor: "#7f260f"
            };
            if (opIndex && sparkOptions[opIndex]) options = $.extend(true, {}, options, sparkOptions[opIndex]);
            var sparklineLogin = function () {
                $(_this).sparkline('html', options);
            };
            sparklineLogin();
            $(this).parents('.grid-stack-item').on('grid-stack-item-updated panel-fullscreen-maximized panel-fullscreen-minimized panel-fullscreen-in panel-fullscreen-out', function () {
                sparklineLogin();
            });
        });
    });
});
System.registerDynamic("reactiveadmintemplate/scripts/prod.js", ["./app", "./modules/product/photo-editor/init", "./modules/charts/chart", "./modules/product/init", "./modules/charts/spark"], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: true });
  /*!
   * @version: 1.1.2
   * @name: prod
   *
   * @author: https://themeforest.net/user/flexlayers
   */
  $__require("./app");
  $__require("./modules/product/photo-editor/init");
  $__require("./modules/charts/chart");
  $__require("./modules/product/init");
  $__require("./modules/charts/spark");
});